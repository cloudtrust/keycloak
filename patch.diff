diff --git a/core/src/main/java/org/keycloak/representations/idm/CredentialRepresentation.java b/core/src/main/java/org/keycloak/representations/idm/CredentialRepresentation.java
index 95c7ca3d1a..55fd1d7768 100755
--- a/core/src/main/java/org/keycloak/representations/idm/CredentialRepresentation.java
+++ b/core/src/main/java/org/keycloak/representations/idm/CredentialRepresentation.java
@@ -26,152 +26,90 @@ import org.keycloak.common.util.MultivaluedHashMap;
 public class CredentialRepresentation {
     public static final String SECRET = "secret";
     public static final String PASSWORD = "password";
-    public static final String PASSWORD_TOKEN = "password-token";
     public static final String TOTP = "totp";
     public static final String HOTP = "hotp";
-    public static final String CLIENT_CERT = "cert";
     public static final String KERBEROS = "kerberos";
 
-    protected String type;
-    protected String device;
-
-    // Plain-text value of credential (used for example during import from manually created JSON file)
-    protected String value;
-
-    // Value stored in DB (used for example during export/import)
-    protected String hashedSaltedValue;
-    protected String salt;
-    protected Integer hashIterations;
-    protected Integer counter;
-    private String algorithm;
-    private Integer digits;
-    private Integer period;
+    private String id;
+    private String type;
+    private String userLabel;
     private Long createdDate;
-    private MultivaluedHashMap<String, String> config;
+    private String secretData;
+    private String credentialData;
+
+    private String value;
 
     // only used when updating a credential.  Might set required action
     protected Boolean temporary;
 
+    public String getId() {
+        return id;
+    }
+    public void setId(String id) {
+        this.id = id;
+    }
+
     public String getType() {
         return type;
     }
-
     public void setType(String type) {
         this.type = type;
     }
 
-    public String getValue() {
-        return value;
+    public String getUserLabel() {
+        return userLabel;
     }
-
-    public void setValue(String value) {
-        this.value = value;
+    public void setUserLabel(String userLabel) {
+        this.userLabel = userLabel;
     }
 
-    public String getDevice() {
-        return device;
+    public String getSecretData() {
+        return secretData;
     }
-
-    public void setDevice(String device) {
-        this.device = device;
+    public void setSecretData(String secretData) {
+        this.secretData = secretData;
     }
 
-    public String getHashedSaltedValue() {
-        return hashedSaltedValue;
+    public String getCredentialData() {
+        return credentialData;
     }
-
-    public void setHashedSaltedValue(String hashedSaltedValue) {
-        this.hashedSaltedValue = hashedSaltedValue;
+    public void setCredentialData(String credentialData) {
+        this.credentialData = credentialData;
     }
 
-    public String getSalt() {
-        return salt;
+    public Long getCreatedDate() {
+        return createdDate;
     }
-
-    public void setSalt(String salt) {
-        this.salt = salt;
+    public void setCreatedDate(Long createdDate) {
+        this.createdDate = createdDate;
     }
 
-    public Integer getHashIterations() {
-        return hashIterations;
-    }
 
-    public void setHashIterations(Integer hashIterations) {
-        this.hashIterations = hashIterations;
+    public String getValue() {
+        return value;
+    }
+    public void setValue(String value) {
+        this.value = value;
     }
 
     public Boolean isTemporary() {
         return temporary;
     }
-
     public void setTemporary(Boolean temporary) {
         this.temporary = temporary;
     }
 
-    public Integer getCounter() {
-        return counter;
-    }
-
-    public void setCounter(Integer counter) {
-        this.counter = counter;
-    }
-
-    public String getAlgorithm() {
-        return algorithm;
-    }
-
-    public void setAlgorithm(String algorithm) {
-        this.algorithm = algorithm;
-    }
-
-    public Integer getDigits() {
-        return digits;
-    }
-
-    public void setDigits(Integer digits) {
-        this.digits = digits;
-    }
-
-    public Integer getPeriod() {
-        return period;
-    }
-
-    public void setPeriod(Integer period) {
-        this.period = period;
-    }
-
-    public Long getCreatedDate() {
-        return createdDate;
-    }
-
-    public void setCreatedDate(Long createdDate) {
-        this.createdDate = createdDate;
-    }
-
-    public MultivaluedHashMap<String, String> getConfig() {
-        return config;
-    }
-
-    public void setConfig(MultivaluedHashMap<String, String> config) {
-        this.config = config;
-    }
-
     @Override
     public int hashCode() {
         final int prime = 31;
         int result = 1;
-        result = prime * result + ((algorithm == null) ? 0 : algorithm.hashCode());
-        result = prime * result + ((config == null) ? 0 : config.hashCode());
-        result = prime * result + ((counter == null) ? 0 : counter.hashCode());
         result = prime * result + ((createdDate == null) ? 0 : createdDate.hashCode());
-        result = prime * result + ((device == null) ? 0 : device.hashCode());
-        result = prime * result + ((digits == null) ? 0 : digits.hashCode());
-        result = prime * result + ((hashIterations == null) ? 0 : hashIterations.hashCode());
-        result = prime * result + ((hashedSaltedValue == null) ? 0 : hashedSaltedValue.hashCode());
-        result = prime * result + ((period == null) ? 0 : period.hashCode());
-        result = prime * result + ((salt == null) ? 0 : salt.hashCode());
+        result = prime * result + ((userLabel == null) ? 0 : userLabel.hashCode());
+        result = prime * result + ((secretData == null) ? 0 : secretData.hashCode());
+        result = prime * result + ((credentialData == null) ? 0 : credentialData.hashCode());
         result = prime * result + ((temporary == null) ? 0 : temporary.hashCode());
         result = prime * result + ((type == null) ? 0 : type.hashCode());
+        result = prime * result + ((id == null) ? 0 : id.hashCode());
         result = prime * result + ((value == null) ? 0 : value.hashCode());
         return result;
     }
@@ -185,55 +123,25 @@ public class CredentialRepresentation {
         if (getClass() != obj.getClass())
             return false;
         CredentialRepresentation other = (CredentialRepresentation) obj;
-        if (algorithm == null) {
-            if (other.algorithm != null)
-                return false;
-        } else if (!algorithm.equals(other.algorithm))
-            return false;
-        if (config == null) {
-            if (other.config != null)
+        if (secretData == null) {
+            if (other.secretData != null)
                 return false;
-        } else if (!config.equals(other.config))
+        } else if (!secretData.equals(other.secretData))
             return false;
-        if (counter == null) {
-            if (other.counter != null)
+        if (credentialData == null) {
+            if (other.credentialData != null)
                 return false;
-        } else if (!counter.equals(other.counter))
+        } else if (!credentialData.equals(other.credentialData))
             return false;
         if (createdDate == null) {
             if (other.createdDate != null)
                 return false;
         } else if (!createdDate.equals(other.createdDate))
             return false;
-        if (device == null) {
-            if (other.device != null)
-                return false;
-        } else if (!device.equals(other.device))
-            return false;
-        if (digits == null) {
-            if (other.digits != null)
-                return false;
-        } else if (!digits.equals(other.digits))
-            return false;
-        if (hashIterations == null) {
-            if (other.hashIterations != null)
-                return false;
-        } else if (!hashIterations.equals(other.hashIterations))
-            return false;
-        if (hashedSaltedValue == null) {
-            if (other.hashedSaltedValue != null)
+        if (userLabel == null) {
+            if (other.userLabel != null)
                 return false;
-        } else if (!hashedSaltedValue.equals(other.hashedSaltedValue))
-            return false;
-        if (period == null) {
-            if (other.period != null)
-                return false;
-        } else if (!period.equals(other.period))
-            return false;
-        if (salt == null) {
-            if (other.salt != null)
-                return false;
-        } else if (!salt.equals(other.salt))
+        } else if (!userLabel.equals(other.userLabel))
             return false;
         if (temporary == null) {
             if (other.temporary != null)
@@ -245,6 +153,11 @@ public class CredentialRepresentation {
                 return false;
         } else if (!type.equals(other.type))
             return false;
+        if (id == null) {
+            if (other.id != null)
+                return false;
+        } else if (!id.equals(other.id))
+            return false;
         if (value == null) {
             if (other.value != null)
                 return false;
@@ -252,4 +165,6 @@ public class CredentialRepresentation {
             return false;
         return true;
     }
+
+
 }
diff --git a/distribution/feature-packs/server-feature-pack/src/main/resources/modules/system/layers/keycloak/org/keycloak/keycloak-server-spi/main/module.xml b/distribution/feature-packs/server-feature-pack/src/main/resources/modules/system/layers/keycloak/org/keycloak/keycloak-server-spi/main/module.xml
index daed0af506..5592d6fd1a 100755
--- a/distribution/feature-packs/server-feature-pack/src/main/resources/modules/system/layers/keycloak/org/keycloak/keycloak-server-spi/main/module.xml
+++ b/distribution/feature-packs/server-feature-pack/src/main/resources/modules/system/layers/keycloak/org/keycloak/keycloak-server-spi/main/module.xml
@@ -30,5 +30,9 @@
         <module name="org.apache.httpcomponents"/>
         <module name="org.jboss.resteasy.resteasy-jaxrs"/>
         <module name="javax.transaction.api"/>
+        <module name="com.fasterxml.jackson.core.jackson-core"/>
+        <module name="com.fasterxml.jackson.core.jackson-annotations"/>
+        <module name="com.fasterxml.jackson.core.jackson-databind"/>
+        <module name="com.fasterxml.jackson.jaxrs.jackson-jaxrs-json-provider"/>
     </dependencies>
 </module>
diff --git a/federation/kerberos/src/main/java/org/keycloak/federation/kerberos/KerberosFederationProvider.java b/federation/kerberos/src/main/java/org/keycloak/federation/kerberos/KerberosFederationProvider.java
index a6938098ee..2dbed3afa7 100755
--- a/federation/kerberos/src/main/java/org/keycloak/federation/kerberos/KerberosFederationProvider.java
+++ b/federation/kerberos/src/main/java/org/keycloak/federation/kerberos/KerberosFederationProvider.java
@@ -34,6 +34,7 @@ import org.keycloak.models.RoleModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
 import org.keycloak.models.UserManager;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.storage.ReadOnlyException;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.UserStorageProviderModel;
@@ -132,7 +133,7 @@ public class KerberosFederationProvider implements UserStorageProvider,
 
     @Override
     public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
-        if (!(input instanceof UserCredentialModel) || !CredentialModel.PASSWORD.equals(input.getType())) return false;
+        if (!(input instanceof UserCredentialModel) || !PasswordCredentialModel.TYPE.equals(input.getType())) return false;
         if (kerberosConfig.getEditMode() == EditMode.READ_ONLY) {
             throw new ReadOnlyException("Can't change password in Keycloak database. Change password with your Kerberos server");
         }
@@ -151,12 +152,12 @@ public class KerberosFederationProvider implements UserStorageProvider,
 
     @Override
     public boolean supportsCredentialType(String credentialType) {
-        return credentialType.equals(CredentialModel.KERBEROS) || (kerberosConfig.isAllowPasswordAuthentication() && credentialType.equals(CredentialModel.PASSWORD));
+        return credentialType.equals(UserCredentialModel.KERBEROS) || (kerberosConfig.isAllowPasswordAuthentication() && credentialType.equals(PasswordCredentialModel.TYPE));
     }
 
     @Override
     public boolean supportsCredentialAuthenticationFor(String type) {
-        return CredentialModel.KERBEROS.equals(type);
+        return UserCredentialModel.KERBEROS.equals(type);
     }
 
     @Override
@@ -167,8 +168,8 @@ public class KerberosFederationProvider implements UserStorageProvider,
     @Override
     public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
         if (!(input instanceof UserCredentialModel)) return false;
-        if (input.getType().equals(UserCredentialModel.PASSWORD) && !session.userCredentialManager().isConfiguredLocally(realm, user, UserCredentialModel.PASSWORD)) {
-            return validPassword(user.getUsername(), ((UserCredentialModel)input).getValue());
+        if (input.getType().equals(PasswordCredentialModel.TYPE) && !session.userCredentialManager().isConfiguredLocally(realm, user, PasswordCredentialModel.TYPE)) {
+            return validPassword(user.getUsername(), input.getChallengeResponse());
         } else {
             return false; // invalid cred type
         }
@@ -188,7 +189,7 @@ public class KerberosFederationProvider implements UserStorageProvider,
         if (!(input instanceof UserCredentialModel)) return null;
         UserCredentialModel credential = (UserCredentialModel)input;
         if (credential.getType().equals(UserCredentialModel.KERBEROS)) {
-            String spnegoToken = credential.getValue();
+            String spnegoToken = credential.getChallengeResponse();
             SPNEGOAuthenticator spnegoAuthenticator = factory.createSPNEGOAuthenticator(spnegoToken, kerberosConfig);
 
             spnegoAuthenticator.authenticate();
diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java
index f95050aa4e..fba8c9cd93 100755
--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java
+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java
@@ -40,14 +40,12 @@ import org.keycloak.federation.kerberos.impl.KerberosUsernamePasswordAuthenticat
 import org.keycloak.federation.kerberos.impl.SPNEGOAuthenticator;
 import org.keycloak.models.*;
 import org.keycloak.models.cache.CachedUserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.models.utils.DefaultRoles;
 import org.keycloak.models.utils.ReadOnlyUserModelDelegate;
 import org.keycloak.policy.PasswordPolicyManagerProvider;
 import org.keycloak.policy.PolicyError;
 import org.keycloak.models.cache.UserCache;
-import org.keycloak.models.credential.PasswordUserCredentialModel;
-import org.keycloak.models.utils.KeycloakModelUtils;
-import org.keycloak.models.utils.ReadOnlyUserModelDelegate;
 import org.keycloak.storage.ReadOnlyException;
 import org.keycloak.storage.StorageId;
 import org.keycloak.storage.UserStorageProvider;
@@ -110,7 +108,7 @@ public class LDAPStorageProvider implements UserStorageProvider,
         this.mapperManager = new LDAPStorageMapperManager(this);
         this.userManager = new LDAPStorageUserManager(this);
 
-        supportedCredentialTypes.add(UserCredentialModel.PASSWORD);
+        supportedCredentialTypes.add(PasswordCredentialModel.TYPE);
         if (kerberosConfig.isAllowKerberosAuthentication()) {
             supportedCredentialTypes.add(UserCredentialModel.KERBEROS);
         }
@@ -218,7 +216,7 @@ public class LDAPStorageProvider implements UserStorageProvider,
 
     @Override
     public boolean supportsCredentialAuthenticationFor(String type) {
-        return type.equals(CredentialModel.KERBEROS) && kerberosConfig.isAllowKerberosAuthentication();
+        return type.equals(UserCredentialModel.KERBEROS) && kerberosConfig.isAllowKerberosAuthentication();
     }
 
     @Override
@@ -608,14 +606,13 @@ public class LDAPStorageProvider implements UserStorageProvider,
 
     @Override
     public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
-        if (!CredentialModel.PASSWORD.equals(input.getType()) || ! (input instanceof PasswordUserCredentialModel)) return false;
+        if (!PasswordCredentialModel.TYPE.equals(input.getType()) || ! (input instanceof UserCredentialModel)) return false;
         if (editMode == UserStorageProvider.EditMode.READ_ONLY) {
             throw new ReadOnlyException("Federated storage is not writable");
 
         } else if (editMode == UserStorageProvider.EditMode.WRITABLE) {
             LDAPIdentityStore ldapIdentityStore = getLdapIdentityStore();
-            PasswordUserCredentialModel cred = (PasswordUserCredentialModel)input;
-            String password = cred.getValue();
+            String password = input.getChallengeResponse();
             LDAPObject ldapUser = loadAndValidateUser(realm, user);
             if (ldapIdentityStore.getConfig().isValidatePasswordPolicy()) {
 		PolicyError error = session.getProvider(PasswordPolicyManagerProvider.class).validate(realm, user, password);
@@ -624,16 +621,16 @@ public class LDAPStorageProvider implements UserStorageProvider,
             try {
                 LDAPOperationDecorator operationDecorator = null;
                 if (updater != null) {
-                    operationDecorator = updater.beforePasswordUpdate(user, ldapUser, cred);
+                    operationDecorator = updater.beforePasswordUpdate(user, ldapUser, (UserCredentialModel)input);
                 }
 
                 ldapIdentityStore.updatePassword(ldapUser, password, operationDecorator);
 
-                if (updater != null) updater.passwordUpdated(user, ldapUser, cred);
+                if (updater != null) updater.passwordUpdated(user, ldapUser, (UserCredentialModel)input);
                 return true;
             } catch (ModelException me) {
                 if (updater != null) {
-                    updater.passwordUpdateFailed(user, ldapUser, cred, me);
+                    updater.passwordUpdateFailed(user, ldapUser, (UserCredentialModel)input, me);
                     return false;
                 } else {
                     throw me;
@@ -673,8 +670,8 @@ public class LDAPStorageProvider implements UserStorageProvider,
     @Override
     public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
         if (!(input instanceof UserCredentialModel)) return false;
-        if (input.getType().equals(UserCredentialModel.PASSWORD) && !session.userCredentialManager().isConfiguredLocally(realm, user, UserCredentialModel.PASSWORD)) {
-            return validPassword(realm, user, ((UserCredentialModel)input).getValue());
+        if (input.getType().equals(PasswordCredentialModel.TYPE) && !session.userCredentialManager().isConfiguredLocally(realm, user, PasswordCredentialModel.TYPE)) {
+            return validPassword(realm, user, input.getChallengeResponse());
         } else {
             return false; // invalid cred type
         }
@@ -686,7 +683,7 @@ public class LDAPStorageProvider implements UserStorageProvider,
         UserCredentialModel credential = (UserCredentialModel)cred;
         if (credential.getType().equals(UserCredentialModel.KERBEROS)) {
             if (kerberosConfig.isAllowKerberosAuthentication()) {
-                String spnegoToken = credential.getValue();
+                String spnegoToken = credential.getChallengeResponse();
                 SPNEGOAuthenticator spnegoAuthenticator = factory.createSPNEGOAuthenticator(spnegoToken, kerberosConfig);
 
                 spnegoAuthenticator.authenticate();
diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/PasswordUpdateCallback.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/PasswordUpdateCallback.java
index b6ef4b1d9b..1dc47246af 100644
--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/PasswordUpdateCallback.java
+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/PasswordUpdateCallback.java
@@ -17,8 +17,8 @@
 package org.keycloak.storage.ldap.mappers;
 
 import org.keycloak.models.ModelException;
+import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
-import org.keycloak.models.credential.PasswordUserCredentialModel;
 import org.keycloak.storage.ldap.idm.model.LDAPObject;
 
 /**
@@ -27,9 +27,9 @@ import org.keycloak.storage.ldap.idm.model.LDAPObject;
  */
 public interface PasswordUpdateCallback {
 
-    LDAPOperationDecorator beforePasswordUpdate(UserModel user, LDAPObject ldapUser, PasswordUserCredentialModel password);
+    LDAPOperationDecorator beforePasswordUpdate(UserModel user, LDAPObject ldapUser, UserCredentialModel password);
 
-    void passwordUpdated(UserModel user, LDAPObject ldapUser, PasswordUserCredentialModel password);
+    void passwordUpdated(UserModel user, LDAPObject ldapUser, UserCredentialModel password);
 
-    void passwordUpdateFailed(UserModel user, LDAPObject ldapUser, PasswordUserCredentialModel password, ModelException exception) throws ModelException;
+    void passwordUpdateFailed(UserModel user, LDAPObject ldapUser, UserCredentialModel password, ModelException exception) throws ModelException;
 }
diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java
index efc0f0bc65..f991fec724 100644
--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java
+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msad/MSADUserAccountControlStorageMapper.java
@@ -19,13 +19,11 @@ package org.keycloak.storage.ldap.mappers.msad;
 
 import org.jboss.logging.Logger;
 import org.keycloak.component.ComponentModel;
-import org.keycloak.credential.CredentialInput;
 import org.keycloak.models.LDAPConstants;
 import org.keycloak.models.ModelException;
 import org.keycloak.models.RealmModel;
+import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
-import org.keycloak.models.credential.PasswordUserCredentialModel;
-import org.keycloak.models.utils.UserModelDelegate;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.ldap.LDAPStorageProvider;
 import org.keycloak.storage.ldap.idm.model.LDAPObject;
@@ -75,7 +73,7 @@ public class MSADUserAccountControlStorageMapper extends AbstractLDAPStorageMapp
     }
 
     @Override
-    public LDAPOperationDecorator beforePasswordUpdate(UserModel user, LDAPObject ldapUser, PasswordUserCredentialModel password) {
+    public LDAPOperationDecorator beforePasswordUpdate(UserModel user, LDAPObject ldapUser, UserCredentialModel password) {
         // Not apply policies if password is reset by admin (not by user himself)
         if (password.isAdminRequest()) {
             return null;
@@ -86,7 +84,7 @@ public class MSADUserAccountControlStorageMapper extends AbstractLDAPStorageMapp
     }
 
     @Override
-    public void passwordUpdated(UserModel user, LDAPObject ldapUser, PasswordUserCredentialModel password) {
+    public void passwordUpdated(UserModel user, LDAPObject ldapUser, UserCredentialModel password) {
         logger.debugf("Going to update userAccountControl for ldap user '%s' after successful password update", ldapUser.getDn().toString());
 
         // Normally it's read-only
@@ -106,7 +104,7 @@ public class MSADUserAccountControlStorageMapper extends AbstractLDAPStorageMapp
     }
 
     @Override
-    public void passwordUpdateFailed(UserModel user, LDAPObject ldapUser, PasswordUserCredentialModel password, ModelException exception) {
+    public void passwordUpdateFailed(UserModel user, LDAPObject ldapUser, UserCredentialModel password, ModelException exception) {
         throw processFailedPasswordUpdateException(exception);
     }
 
diff --git a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msadlds/MSADLDSUserAccountControlStorageMapper.java b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msadlds/MSADLDSUserAccountControlStorageMapper.java
index 7276b31405..efb1f45231 100644
--- a/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msadlds/MSADLDSUserAccountControlStorageMapper.java
+++ b/federation/ldap/src/main/java/org/keycloak/storage/ldap/mappers/msadlds/MSADLDSUserAccountControlStorageMapper.java
@@ -19,12 +19,11 @@ package org.keycloak.storage.ldap.mappers.msadlds;
 
 import org.jboss.logging.Logger;
 import org.keycloak.component.ComponentModel;
-import org.keycloak.credential.CredentialInput;
 import org.keycloak.models.LDAPConstants;
 import org.keycloak.models.ModelException;
 import org.keycloak.models.RealmModel;
+import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
-import org.keycloak.models.credential.PasswordUserCredentialModel;
 import org.keycloak.models.utils.UserModelDelegate;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.ldap.LDAPStorageProvider;
@@ -73,12 +72,12 @@ public class MSADLDSUserAccountControlStorageMapper extends AbstractLDAPStorageM
     }
 
     @Override
-    public LDAPOperationDecorator beforePasswordUpdate(UserModel user, LDAPObject ldapUser, PasswordUserCredentialModel password) {
+    public LDAPOperationDecorator beforePasswordUpdate(UserModel user, LDAPObject ldapUser, UserCredentialModel password) {
         return null; // Not supported for now. Not sure if LDAP_SERVER_POLICY_HINTS_OID works in MSAD LDS
     }
 
     @Override
-    public void passwordUpdated(UserModel user, LDAPObject ldapUser, PasswordUserCredentialModel password) {
+    public void passwordUpdated(UserModel user, LDAPObject ldapUser, UserCredentialModel password) {
         logger.debugf("Going to update pwdLastSet for ldap user '%s' after successful password update", ldapUser.getDn().toString());
 
         // Normally it's read-only
@@ -96,7 +95,7 @@ public class MSADLDSUserAccountControlStorageMapper extends AbstractLDAPStorageM
     }
 
     @Override
-    public void passwordUpdateFailed(UserModel user, LDAPObject ldapUser, PasswordUserCredentialModel password, ModelException exception) {
+    public void passwordUpdateFailed(UserModel user, LDAPObject ldapUser, UserCredentialModel password, ModelException exception) {
         throw processFailedPasswordUpdateException(exception);
     }
 
diff --git a/federation/sssd/src/main/java/org/keycloak/federation/sssd/SSSDFederationProvider.java b/federation/sssd/src/main/java/org/keycloak/federation/sssd/SSSDFederationProvider.java
index 709eac7e64..c26a559ffe 100755
--- a/federation/sssd/src/main/java/org/keycloak/federation/sssd/SSSDFederationProvider.java
+++ b/federation/sssd/src/main/java/org/keycloak/federation/sssd/SSSDFederationProvider.java
@@ -26,11 +26,13 @@ import org.keycloak.federation.sssd.api.Sssd;
 import org.keycloak.federation.sssd.api.Sssd.User;
 import org.keycloak.federation.sssd.impl.PAMAuthenticator;
 import org.keycloak.models.*;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.models.utils.KeycloakModelUtils;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.UserStorageProviderModel;
 import org.keycloak.storage.user.ImportedUserValidation;
 import org.keycloak.storage.user.UserLookupProvider;
+import sun.security.util.Password;
 
 import java.util.Collections;
 import java.util.HashSet;
@@ -63,7 +65,7 @@ public class SSSDFederationProvider implements UserStorageProvider,
     }
 
     static {
-        supportedCredentialTypes.add(UserCredentialModel.PASSWORD);
+        supportedCredentialTypes.add(PasswordCredentialModel.TYPE);
     }
 
 
@@ -163,12 +165,12 @@ public class SSSDFederationProvider implements UserStorageProvider,
 
     @Override
     public boolean supportsCredentialType(String credentialType) {
-        return CredentialModel.PASSWORD.equals(credentialType);
+        return PasswordCredentialModel.TYPE.equals(credentialType);
     }
 
     @Override
     public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
-        return CredentialModel.PASSWORD.equals(credentialType);
+        return PasswordCredentialModel.TYPE.equals(credentialType);
     }
 
     @Override
@@ -176,7 +178,7 @@ public class SSSDFederationProvider implements UserStorageProvider,
         if (!supportsCredentialType(input.getType()) || !(input instanceof UserCredentialModel)) return false;
 
         UserCredentialModel cred = (UserCredentialModel)input;
-        PAMAuthenticator pam = factory.createPAMAuthenticator(user.getUsername(), cred.getValue());
+        PAMAuthenticator pam = factory.createPAMAuthenticator(user.getUsername(), cred.getChallengeResponse());
         return (pam.authenticate() != null);
     }
 
diff --git a/integration/admin-client/src/main/java/org/keycloak/admin/client/resource/UserResource.java b/integration/admin-client/src/main/java/org/keycloak/admin/client/resource/UserResource.java
index f00f9423bb..7386155694 100755
--- a/integration/admin-client/src/main/java/org/keycloak/admin/client/resource/UserResource.java
+++ b/integration/admin-client/src/main/java/org/keycloak/admin/client/resource/UserResource.java
@@ -83,9 +83,15 @@ public interface UserResource {
     @Path("logout")
     public void logout();
 
-    @PUT
-    @Path("remove-totp")
-    public void removeTotp();
+
+
+    @GET
+    @Path("credentials")
+    List<CredentialRepresentation> credentials();
+
+    @DELETE
+    @Path("credentials/{credentialId}")
+    void removeCredential(@PathParam("credentialId")String credentialId);
 
     /**
      * Disables or deletes all credentials for specific types.
diff --git a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmAdapter.java b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmAdapter.java
index 62aee89e66..b99a93374b 100755
--- a/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmAdapter.java
+++ b/model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmAdapter.java
@@ -1200,6 +1200,11 @@ public class RealmAdapter implements CachedRealmModel {
         return cached.getExecutionsById().get(id);
     }
 
+    public AuthenticationExecutionModel getAuthenticationExecutionByFlowId(String flowId) {
+        getDelegateForUpdate();
+        return updated.getAuthenticationExecutionByFlowId(flowId);
+    }
+
     @Override
     public AuthenticationExecutionModel addAuthenticatorExecution(AuthenticationExecutionModel model) {
         getDelegateForUpdate();
diff --git a/model/jpa/src/main/java/org/keycloak/authorization/jpa/store/ResourceAdapter.java b/model/jpa/src/main/java/org/keycloak/authorization/jpa/store/ResourceAdapter.java
index a7a295e92c..44f72263d9 100644
--- a/model/jpa/src/main/java/org/keycloak/authorization/jpa/store/ResourceAdapter.java
+++ b/model/jpa/src/main/java/org/keycloak/authorization/jpa/store/ResourceAdapter.java
@@ -137,7 +137,8 @@ public class ResourceAdapter extends AbstractAuthorizationModel implements Resou
 
     @Override
     public ResourceServer getResourceServer() {
-        return storeFactory.getResourceServerStore().findById(entity.getResourceServer().getId());
+        ResourceServer temp = storeFactory.getResourceServerStore().findById(entity.getResourceServer().getId());
+        return temp;
     }
 
     @Override
diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/JpaUpdate7_0_0_Credentials.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/JpaUpdate7_0_0_Credentials.java
new file mode 100644
index 0000000000..8c9b47a170
--- /dev/null
+++ b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/JpaUpdate7_0_0_Credentials.java
@@ -0,0 +1,99 @@
+package org.keycloak.connections.jpa.updater.liquibase.custom;
+
+import liquibase.exception.CustomChangeException;
+import liquibase.statement.core.UpdateStatement;
+import liquibase.structure.core.Table;
+import org.keycloak.models.credential.OTPCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
+
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+
+public class JpaUpdate7_0_0_Credentials extends CustomKeycloakTask {
+
+    @Override
+    protected void generateStatementsImpl() throws CustomChangeException {
+        String credentialTableName = database.correctObjectName("CREDENTIAL", Table.class);
+        try (PreparedStatement statement = jdbcConnection.prepareStatement("SELECT HASH_ITERATIONS, SALT, TYPE, VALUE, COUNTER, DIGITS, PERIOD, ALGORITHM FROM " + credentialTableName);
+             ResultSet rs = statement.executeQuery()) {
+            String previousId = null;
+            while (rs.next()) {
+                String hashIterations = rs.getString("HASH_ITERATIONS").trim();
+                if (rs.wasNull()) {
+                    hashIterations = "";
+                }
+                String salt = rs.getString("SALT").trim();
+                if (rs.wasNull()) {
+                    salt = "";
+                }
+                String type = rs.getString("TYPE").trim();
+                if (rs.wasNull()) {
+                    type = "";
+                }
+                String value = rs.getString("VALUE").trim();
+                if (rs.wasNull()) {
+                    value = "";
+                }
+                String counter = rs.getString("COUNTER").trim();
+                if (rs.wasNull()) {
+                    counter = "";
+                }
+                String digits = rs.getString("DIGITS").trim();
+                if (rs.wasNull()) {
+                    digits = "";
+                }
+                String period = rs.getString("PERIOD").trim();
+                if (rs.wasNull()) {
+                    period = "";
+                }
+                String algorithm = rs.getString("ALGORITHM").trim();
+                if (rs.wasNull()) {
+                    algorithm = "";
+                }
+
+                statements.add(
+                        new UpdateStatement(null, null, credentialTableName)
+                                .addNewColumnValue("SECRET_DATA", "{\"hash\":\"" + value + "\",\"salt\":\"" + salt + "\"}")
+                                .addNewColumnValue("CREDENTIAL_DATA", "{\"hashIterations\":" + hashIterations + ",\"algorithm\":\"" + algorithm + "\"}")
+                                .addNewColumnValue("TYPE", PasswordCredentialModel.TYPE)
+                                .setWhereClause("TYPE='password'")
+                );
+                statements.add(
+                        new UpdateStatement(null, null, credentialTableName)
+                                .addNewColumnValue("SECRET_DATA", "{\"value\":\"" + value + "\"}")
+                                .addNewColumnValue("CREDENTIAL_DATA", "{\"subType\":\"" + type + "\",\"digits\":" + digits + ",\"counter\":" + counter + ",\"algorithm\":\"" + algorithm + "\"}")
+                                .addNewColumnValue("TYPE", OTPCredentialModel.TYPE)
+                                .setWhereClause("TYPE='hotp'")
+                );
+                statements.add(
+                        new UpdateStatement(null, null, credentialTableName)
+                                .addNewColumnValue("SECRET_DATA", "{\"value\":\"" + value + "\"}")
+                                .addNewColumnValue("CREDENTIAL_DATA", "{\"subType\":\"" + type + "\",\"digits\":" + digits + ",\"period\":" + period + ",\"algorithm\":\"" + algorithm + "\"}")
+                                .addNewColumnValue("TYPE", OTPCredentialModel.TYPE)
+                                .setWhereClause("TYPE='totp'")
+                );
+
+                statements.add(
+                        new UpdateStatement(null, null, credentialTableName)
+                                .addNewColumnValue("PREVIOUS_CREDENTIAL_LINK", previousId)
+                .setWhereClause("ID='"+ rs.getString("ID") + "'"));
+                if (previousId != null){
+                    statements.add(
+                            new UpdateStatement(null, null, credentialTableName)
+                                    .addNewColumnValue("NEXT_CREDENTIAL_LINK", rs.getString("ID"))
+                                    .setWhereClause("ID='"+ previousId +"'"));
+                }
+
+                previousId = rs.getString("ID");
+                confirmationMessage.append("Updated " + statements.size() + " records in CREDENTIAL table");
+            }
+        } catch (Exception e) {
+            throw new CustomChangeException(getTaskId() + ": Exception when updating data from previous version", e);
+        }
+    }
+
+    @Override
+    protected String getTaskId() {
+        return "Update 7.0.0";
+    }
+}
diff --git a/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/JpaUpdate7_0_0_FederatedUserCredentials.java b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/JpaUpdate7_0_0_FederatedUserCredentials.java
new file mode 100644
index 0000000000..fed2bba45f
--- /dev/null
+++ b/model/jpa/src/main/java/org/keycloak/connections/jpa/updater/liquibase/custom/JpaUpdate7_0_0_FederatedUserCredentials.java
@@ -0,0 +1,87 @@
+package org.keycloak.connections.jpa.updater.liquibase.custom;
+
+import liquibase.exception.CustomChangeException;
+import liquibase.statement.core.UpdateStatement;
+import liquibase.structure.core.Table;
+import org.keycloak.connections.jpa.updater.liquibase.custom.CustomKeycloakTask;
+import org.keycloak.models.credential.OTPCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
+
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+
+public class JpaUpdate7_0_0_FederatedUserCredentials extends CustomKeycloakTask {
+
+    @Override
+    protected void generateStatementsImpl() throws CustomChangeException {
+        String credentialTableName = database.correctObjectName("FED_USER_CREDENTIAL", Table.class);
+        try (PreparedStatement statement = jdbcConnection.prepareStatement("SELECT HASH_ITERATIONS, SALT, TYPE, VALUE, COUNTER, DIGITS, PERIOD, ALGORITHM FROM " + credentialTableName);
+             ResultSet rs = statement.executeQuery()) {
+            while (rs.next()) {
+                String hashIterations = rs.getString("HASH_ITERATIONS").trim();
+                if (rs.wasNull()) {
+                    hashIterations = "";
+                }
+                String salt = rs.getString("SALT").trim();
+                if (rs.wasNull()) {
+                    salt = "";
+                }
+                String type = rs.getString("TYPE").trim();
+                if (rs.wasNull()) {
+                    type = "";
+                }
+                String value = rs.getString("VALUE").trim();
+                if (rs.wasNull()) {
+                    value = "";
+                }
+                String counter = rs.getString("COUNTER").trim();
+                if (rs.wasNull()) {
+                    counter = "";
+                }
+                String digits = rs.getString("DIGITS").trim();
+                if (rs.wasNull()) {
+                    digits = "";
+                }
+                String period = rs.getString("PERIOD").trim();
+                if (rs.wasNull()) {
+                    period = "";
+                }
+                String algorithm = rs.getString("ALGORITHM").trim();
+                if (rs.wasNull()) {
+                    algorithm = "";
+                }
+
+                statements.add(
+                        new UpdateStatement(null, null, credentialTableName)
+                                .addNewColumnValue("SECRET_DATA", "{\"hash\":\"" + value + "\",\"salt\":\"" + salt + "\"}")
+                                .addNewColumnValue("CREDENTIAL_DATA", "{\"hashIterations\":\"" + hashIterations + "\",\"algorithm\":\"" + algorithm + "\"}")
+                                .addNewColumnValue("TYPE", PasswordCredentialModel.TYPE)
+                                .setWhereClause("TYPE='password'")
+                );
+                statements.add(
+                        new UpdateStatement(null, null, credentialTableName)
+                                .addNewColumnValue("SECRET_DATA", "{\"value\":\"" + value + "\"}")
+                                .addNewColumnValue("CREDENTIAL_DATA", "{\"subType\":\"" + type + "\",\"digits\":\"" + digits + "\"},\"counter\":\"" + counter + "\",\"algorithm\":\"" + algorithm + "\"}")
+                                .addNewColumnValue("TYPE", OTPCredentialModel.TYPE)
+                                .setWhereClause("TYPE='hotp'")
+                );
+                statements.add(
+                        new UpdateStatement(null, null, credentialTableName)
+                                .addNewColumnValue("SECRET_DATA", "{\"value\":\"" + value + "\"}")
+                                .addNewColumnValue("CREDENTIAL_DATA", "{\"subType\":\"" + type + "\",\"digits\":\"" + digits + "\"},\"period\":\"" + period + "\",\"algorithm\":\"" + algorithm + "\"}")
+                                .addNewColumnValue("TYPE", OTPCredentialModel.TYPE)
+                                .setWhereClause("TYPE='totp'")
+                );
+
+                confirmationMessage.append("Updated " + statements.size() + " records in FED_USER_CREDENTIAL table");
+            }
+        } catch (Exception e) {
+            throw new CustomChangeException(getTaskId() + ": Exception when updating data from previous version", e);
+        }
+    }
+
+    @Override
+    protected String getTaskId() {
+        return "Update 7.0.0";
+    }
+}
diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java
index a1a0cdb6a0..f2dc6853da 100644
--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java
+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserCredentialStore.java
@@ -16,22 +16,22 @@
  */
 package org.keycloak.models.jpa;
 
-import org.keycloak.common.util.MultivaluedHashMap;
 import org.keycloak.credential.CredentialModel;
 import org.keycloak.credential.UserCredentialStore;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserModel;
-import org.keycloak.models.jpa.entities.CredentialAttributeEntity;
 import org.keycloak.models.jpa.entities.CredentialEntity;
 import org.keycloak.models.jpa.entities.UserEntity;
 import org.keycloak.models.utils.KeycloakModelUtils;
 
 import javax.persistence.EntityManager;
 import javax.persistence.TypedQuery;
-import java.util.Iterator;
+import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
@@ -51,99 +51,23 @@ public class JpaUserCredentialStore implements UserCredentialStore {
     public void updateCredential(RealmModel realm, UserModel user, CredentialModel cred) {
         CredentialEntity entity = em.find(CredentialEntity.class, cred.getId());
         if (entity == null) return;
-        entity.setAlgorithm(cred.getAlgorithm());
-        entity.setCounter(cred.getCounter());
         entity.setCreatedDate(cred.getCreatedDate());
-        entity.setDevice(cred.getDevice());
-        entity.setDigits(cred.getDigits());
-        entity.setHashIterations(cred.getHashIterations());
-        entity.setPeriod(cred.getPeriod());
-        entity.setSalt(cred.getSalt());
+        entity.setUserLabel(cred.getUserLabel());
         entity.setType(cred.getType());
-        entity.setValue(cred.getValue());
-        if (entity.getCredentialAttributes().isEmpty() && (cred.getConfig() == null || cred.getConfig().isEmpty())) {
-
-        } else {
-            MultivaluedHashMap<String, String> attrs = cred.getConfig();
-            MultivaluedHashMap<String, String> config = cred.getConfig();
-            if (config == null) config = new MultivaluedHashMap<>();
-
-            Iterator<CredentialAttributeEntity> it = entity.getCredentialAttributes().iterator();
-            while (it.hasNext()) {
-                CredentialAttributeEntity attr = it.next();
-                List<String> values = config.getList(attr.getName());
-                if (values == null || !values.contains(attr.getValue())) {
-                    em.remove(attr);
-                    it.remove();
-                } else {
-                    attrs.add(attr.getName(), attr.getValue());
-                }
-
-            }
-            for (String key : config.keySet()) {
-                List<String> values = config.getList(key);
-                List<String> attrValues = attrs.getList(key);
-                for (String val : values) {
-                    if (attrValues == null || !attrValues.contains(val)) {
-                        CredentialAttributeEntity attr = new CredentialAttributeEntity();
-                        attr.setId(KeycloakModelUtils.generateId());
-                        attr.setValue(val);
-                        attr.setName(key);
-                        attr.setCredential(entity);
-                        em.persist(attr);
-                        entity.getCredentialAttributes().add(attr);
-                    }
-                }
-            }
-
-        }
-
+        entity.setSecretData(cred.getSecretData());
+        entity.setCredentialData(cred.getCredentialData());
     }
 
     @Override
     public CredentialModel createCredential(RealmModel realm, UserModel user, CredentialModel cred) {
-        CredentialEntity entity = new CredentialEntity();
-        String id = cred.getId() == null ? KeycloakModelUtils.generateId() : cred.getId();
-        entity.setId(id);
-        entity.setAlgorithm(cred.getAlgorithm());
-        entity.setCounter(cred.getCounter());
-        entity.setCreatedDate(cred.getCreatedDate());
-        entity.setDevice(cred.getDevice());
-        entity.setDigits(cred.getDigits());
-        entity.setHashIterations(cred.getHashIterations());
-        entity.setPeriod(cred.getPeriod());
-        entity.setSalt(cred.getSalt());
-        entity.setType(cred.getType());
-        entity.setValue(cred.getValue());
-        UserEntity userRef = em.getReference(UserEntity.class, user.getId());
-        entity.setUser(userRef);
-        em.persist(entity);
-        MultivaluedHashMap<String, String> config = cred.getConfig();
-        if (config != null && !config.isEmpty()) {
-
-            for (String key : config.keySet()) {
-                List<String> values = config.getList(key);
-                for (String val : values) {
-                    CredentialAttributeEntity attr = new CredentialAttributeEntity();
-                    attr.setId(KeycloakModelUtils.generateId());
-                    attr.setValue(val);
-                    attr.setName(key);
-                    attr.setCredential(entity);
-                    em.persist(attr);
-                    entity.getCredentialAttributes().add(attr);
-                }
-            }
-
-        }
+        CredentialEntity entity = createCredentialEntity(realm, user, cred);
         return toModel(entity);
     }
 
     @Override
     public boolean removeStoredCredential(RealmModel realm, UserModel user, String id) {
-        CredentialEntity entity = em.find(CredentialEntity.class, id);
-        if (entity == null) return false;
-        em.remove(entity);
-        return true;
+        CredentialEntity entity = removeCredentialEntity(id);
+        return entity != null;
     }
 
     @Override
@@ -154,23 +78,14 @@ public class JpaUserCredentialStore implements UserCredentialStore {
         return model;
     }
 
-    protected CredentialModel toModel(CredentialEntity entity) {
+    CredentialModel toModel(CredentialEntity entity) {
         CredentialModel model = new CredentialModel();
         model.setId(entity.getId());
         model.setType(entity.getType());
-        model.setValue(entity.getValue());
-        model.setAlgorithm(entity.getAlgorithm());
-        model.setSalt(entity.getSalt());
-        model.setPeriod(entity.getPeriod());
-        model.setCounter(entity.getCounter());
         model.setCreatedDate(entity.getCreatedDate());
-        model.setDevice(entity.getDevice());
-        model.setDigits(entity.getDigits());
-        MultivaluedHashMap<String, String> config = new MultivaluedHashMap<>();
-        model.setConfig(config);
-        for (CredentialAttributeEntity attr : entity.getCredentialAttributes()) {
-            config.add(attr.getName(), attr.getValue());
-        }
+        model.setUserLabel(entity.getUserLabel());
+        model.setSecretData(entity.getSecretData());
+        model.setCredentialData(entity.getCredentialData());
         return model;
     }
 
@@ -180,41 +95,144 @@ public class JpaUserCredentialStore implements UserCredentialStore {
         TypedQuery<CredentialEntity> query = em.createNamedQuery("credentialByUser", CredentialEntity.class)
                 .setParameter("user", userEntity);
         List<CredentialEntity> results = query.getResultList();
+        //order the list correctly
+        Map<String, CredentialEntity> credentialMap = new HashMap<>();
+        CredentialEntity current = null;
+        for (CredentialEntity ce : results) {
+            credentialMap.put(ce.getId(), ce);
+            if (ce.getPreviousCredentialLink() == null) {
+                current = ce;
+            }
+        }
         List<CredentialModel> rtn = new LinkedList<>();
-        for (CredentialEntity entity : results) {
-            rtn.add(toModel(entity));
+        if (current != null) {
+            while (current.getNextCredentialLink() != null) {
+                rtn.add(toModel(current));
+                current = credentialMap.get(current.getNextCredentialLink());
+            }
+            rtn.add(toModel(current));
         }
         return rtn;
     }
 
     @Override
     public List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type) {
-        UserEntity userEntity = em.getReference(UserEntity.class, user.getId());
-        TypedQuery<CredentialEntity> query = em.createNamedQuery("credentialByUserAndType", CredentialEntity.class)
-                .setParameter("type", type)
-                .setParameter("user", userEntity);
-        List<CredentialEntity> results = query.getResultList();
-        List<CredentialModel> rtn = new LinkedList<>();
-        for (CredentialEntity entity : results) {
-            rtn.add(toModel(entity));
-        }
-        return rtn;
+        return getStoredCredentials(realm, user).stream().filter(credential -> type.equals(credential.getType())).collect(Collectors.toList());
     }
 
     @Override
     public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type) {
-        UserEntity userEntity = em.getReference(UserEntity.class, user.getId());
-        TypedQuery<CredentialEntity> query = em.createNamedQuery("credentialByNameAndType", CredentialEntity.class)
-                .setParameter("type", type)
-                .setParameter("device", name)
-                .setParameter("user", userEntity);
-        List<CredentialEntity> results = query.getResultList();
+        List<CredentialModel> results = getStoredCredentials(realm, user).stream().filter(credential ->
+                type.equals(credential.getType()) && name.equals(credential.getUserLabel())).collect(Collectors.toList());
         if (results.isEmpty()) return null;
-        return toModel(results.get(0));
+        return results.get(0);
     }
 
     @Override
     public void close() {
 
     }
+
+    CredentialEntity createCredentialEntity(RealmModel realm, UserModel user, CredentialModel cred) {
+        CredentialEntity entity = new CredentialEntity();
+        String id = cred.getId() == null ? KeycloakModelUtils.generateId() : cred.getId();
+        entity.setId(id);
+        entity.setCreatedDate(cred.getCreatedDate());
+        entity.setUserLabel(cred.getUserLabel());
+        entity.setType(cred.getType());
+        entity.setSecretData(cred.getSecretData());
+        entity.setCredentialData(cred.getCredentialData());
+        UserEntity userRef = em.getReference(UserEntity.class, user.getId());
+        entity.setUser(userRef);
+
+        //add in linkedlist
+        CredentialEntity lastCredential = findLastCredentialInList(user);
+        if (lastCredential != null) {
+            putCredentialInLinkedListAfterCredential(entity, lastCredential.getId());
+        }
+
+        em.persist(entity);
+        return entity;
+    }
+
+    CredentialEntity removeCredentialEntity(String id) {
+        CredentialEntity entity = em.find(CredentialEntity.class, id);
+        if (entity == null) return null;
+        takeOutCredentialAndRepairList(entity);
+        em.remove(entity);
+        return entity;
+    }
+
+    ////Operations to handle the linked list of credentials
+    @Override
+    public void moveCredentialTo(RealmModel realm, UserModel user, String id, String newPreviousCredentialId) {
+        if (newPreviousCredentialId == null) {
+            setCredentialAsFirst(realm, user, id);
+        }
+        CredentialEntity credentialToMove = em.find(CredentialEntity.class, id);
+        //moved to the same place, do nothing
+        if (newPreviousCredentialId == credentialToMove.getPreviousCredentialLink() || id == newPreviousCredentialId){
+            return;
+        }
+        takeOutCredentialAndRepairList(credentialToMove);
+        putCredentialInLinkedListAfterCredential(credentialToMove, newPreviousCredentialId);
+    }
+
+    public void setCredentialAsFirst(RealmModel realm, UserModel user, String id)  {
+        CredentialEntity credentialToMove = em.find(CredentialEntity.class, id);
+        //moved to the same place, do nothing
+        if (credentialToMove.getPreviousCredentialLink() == null) {
+            return;
+        }
+        takeOutCredentialAndRepairList(credentialToMove);
+        CredentialEntity currentFirst = findFirstCredentialInList(user);
+        credentialToMove.setPreviousCredentialLink(null);
+        credentialToMove.setNextCredentialLink(currentFirst.getId());
+        currentFirst.setPreviousCredentialLink(credentialToMove.getId());
+    }
+
+    /**
+     * Takes out a credentialEntity from the linkedList and repairs the list by attaching the previous and next together
+     * @param ce The CredentialEntity to remove
+     */
+    private void takeOutCredentialAndRepairList(CredentialEntity ce) {
+        //
+        if (ce.getPreviousCredentialLink() != null) {
+            CredentialEntity currentPreviousCredential = em.find(CredentialEntity.class,ce.getPreviousCredentialLink());
+            currentPreviousCredential.setNextCredentialLink(ce.getNextCredentialLink());
+        }
+        if (ce.getNextCredentialLink() != null) {
+            CredentialEntity currentNextCredential = em.find(CredentialEntity.class,ce.getNextCredentialLink());
+            currentNextCredential.setPreviousCredentialLink(ce.getPreviousCredentialLink());
+        }
+    }
+
+    private void putCredentialInLinkedListAfterCredential(CredentialEntity ce, String newPreviousCredentialId) {
+        CredentialEntity newPreviousCredential = em.find(CredentialEntity.class, newPreviousCredentialId);
+        ce.setPreviousCredentialLink(newPreviousCredentialId);
+        ce.setNextCredentialLink(newPreviousCredential.getNextCredentialLink());
+        if (newPreviousCredential.getNextCredentialLink() != null) {
+            CredentialEntity currentNextCredential = em.find(CredentialEntity.class,newPreviousCredential.getNextCredentialLink());
+            currentNextCredential.setPreviousCredentialLink(ce.getId());
+        }
+        newPreviousCredential.setNextCredentialLink(ce.getId());
+    }
+
+    private CredentialEntity findFirstCredentialInList(UserModel user){
+        UserEntity userEntity = em.getReference(UserEntity.class, user.getId());
+        TypedQuery<CredentialEntity> query = em.createNamedQuery("firstCredentialInList", CredentialEntity.class)
+                .setParameter("user", userEntity);
+        List<CredentialEntity> results = query.getResultList();
+        return (results.isEmpty())?null:results.get(0);
+    }
+
+    private CredentialEntity findLastCredentialInList(UserModel user) {
+        UserEntity userEntity = em.getReference(UserEntity.class, user.getId());
+        TypedQuery<CredentialEntity> query = em.createNamedQuery("lastCredentialInList", CredentialEntity.class)
+                .setParameter("user", userEntity);
+        List<CredentialEntity> results = query.getResultList();
+        return (results.isEmpty())?null:results.get(0);
+    }
+
+
 }
diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java
index d0b5f5964f..17cd7f69b1 100755
--- a/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java
+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java
@@ -37,7 +37,6 @@ import org.keycloak.models.RoleModel;
 import org.keycloak.models.UserConsentModel;
 import org.keycloak.models.UserModel;
 import org.keycloak.models.UserProvider;
-import org.keycloak.models.jpa.entities.CredentialAttributeEntity;
 import org.keycloak.models.jpa.entities.CredentialEntity;
 import org.keycloak.models.jpa.entities.FederatedIdentityEntity;
 import org.keycloak.models.jpa.entities.UserConsentClientScopeEntity;
@@ -46,6 +45,7 @@ import org.keycloak.models.jpa.entities.UserEntity;
 import org.keycloak.models.jpa.entities.UserGroupMembershipEntity;
 import org.keycloak.models.utils.DefaultRoles;
 import org.keycloak.models.utils.KeycloakModelUtils;
+import org.keycloak.models.utils.ModelToRepresentation;
 import org.keycloak.storage.StorageId;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.client.ClientStorageProvider;
@@ -67,12 +67,12 @@ import java.util.Map;
 import java.util.Set;
 import java.util.stream.Collectors;
 import javax.persistence.criteria.Expression;
-import javax.persistence.criteria.Path;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
+@SuppressWarnings("JpaQueryApiInspection")
 public class JpaUserProvider implements UserProvider, UserCredentialStore {
 
     private static final String EMAIL = "email";
@@ -82,10 +82,12 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
 
     private final KeycloakSession session;
     protected EntityManager em;
+    private final JpaUserCredentialStore credentialStore;
 
     public JpaUserProvider(KeycloakSession session, EntityManager em) {
         this.session = session;
         this.em = em;
+        credentialStore = new JpaUserCredentialStore(session, em);
     }
 
     @Override
@@ -380,8 +382,6 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
                 .setParameter("realmId", realm.getId()).executeUpdate();
         num = em.createNamedQuery("deleteFederatedIdentityByRealm")
                 .setParameter("realmId", realm.getId()).executeUpdate();
-        num = em.createNamedQuery("deleteCredentialAttributeByRealm")
-                .setParameter("realmId", realm.getId()).executeUpdate();
         num = em.createNamedQuery("deleteCredentialsByRealm")
                 .setParameter("realmId", realm.getId()).executeUpdate();
         num = em.createNamedQuery("deleteUserAttributesByRealm")
@@ -406,10 +406,6 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
                 .setParameter("realmId", realm.getId())
                 .setParameter("link", storageProviderId)
                 .executeUpdate();
-        num = em.createNamedQuery("deleteCredentialAttributeByRealmAndLink")
-                .setParameter("realmId", realm.getId())
-                .setParameter("link", storageProviderId)
-                .executeUpdate();
         num = em.createNamedQuery("deleteCredentialsByRealmAndLink")
                 .setParameter("realmId", realm.getId())
                 .setParameter("link", storageProviderId)
@@ -496,7 +492,7 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
         }
         return users;
     }
-    
+
     @Override
     public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role) {
         TypedQuery<UserEntity> query = em.createNamedQuery("usersInRole", UserEntity.class);
@@ -540,11 +536,11 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
         query.setParameter("email", email.toLowerCase());
         query.setParameter("realmId", realm.getId());
         List<UserEntity> results = query.getResultList();
-        
+
         if (results.isEmpty()) return null;
-        
+
         ensureEmailConstraint(results, realm);
-        
+
         return new UserAdapter(session, realm, em, results.get(0));
     }
 
@@ -657,7 +653,7 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
         }
         return users;
     }
-    
+
     @Override
     public List<UserModel> getRoleMembers(RealmModel realm, RoleModel role, int firstResult, int maxResults) {
         TypedQuery<UserEntity> query = em.createNamedQuery("usersInRole", UserEntity.class);
@@ -754,7 +750,7 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
             Root from1 = subquery1.from(ResourceEntity.class);
 
             List<Predicate> subs = new ArrayList<>();
-            
+
             Expression<String> groupId = from.get("groupId");
             subs.add(builder.like(from1.get("name"), builder.concat("group.resource.", groupId)));
 
@@ -855,93 +851,12 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
 
     @Override
     public void updateCredential(RealmModel realm, UserModel user, CredentialModel cred) {
-        CredentialEntity entity = em.find(CredentialEntity.class, cred.getId());
-        if (entity == null) return;
-        entity.setAlgorithm(cred.getAlgorithm());
-        entity.setCounter(cred.getCounter());
-        entity.setCreatedDate(cred.getCreatedDate());
-        entity.setDevice(cred.getDevice());
-        entity.setDigits(cred.getDigits());
-        entity.setHashIterations(cred.getHashIterations());
-        entity.setPeriod(cred.getPeriod());
-        entity.setSalt(cred.getSalt());
-        entity.setType(cred.getType());
-        entity.setValue(cred.getValue());
-        if (entity.getCredentialAttributes().isEmpty() && (cred.getConfig() == null || cred.getConfig().isEmpty())) {
-
-        } else {
-            MultivaluedHashMap<String, String> attrs = cred.getConfig();
-            MultivaluedHashMap<String, String> config = cred.getConfig();
-            if (config == null) config = new MultivaluedHashMap<>();
-
-            Iterator<CredentialAttributeEntity> it = entity.getCredentialAttributes().iterator();
-            while (it.hasNext()) {
-                CredentialAttributeEntity attr = it.next();
-                List<String> values = config.getList(attr.getName());
-                if (values == null || !values.contains(attr.getValue())) {
-                    em.remove(attr);
-                    it.remove();
-                } else {
-                    attrs.add(attr.getName(), attr.getValue());
-                }
-
-            }
-            for (String key : config.keySet()) {
-                List<String> values = config.getList(key);
-                List<String> attrValues = attrs.getList(key);
-                for (String val : values) {
-                    if (attrValues == null || !attrValues.contains(val)) {
-                        CredentialAttributeEntity attr = new CredentialAttributeEntity();
-                        attr.setId(KeycloakModelUtils.generateId());
-                        attr.setValue(val);
-                        attr.setName(key);
-                        attr.setCredential(entity);
-                        em.persist(attr);
-                        entity.getCredentialAttributes().add(attr);
-                    }
-                }
-            }
-
-        }
-
+        credentialStore.updateCredential(realm, user, cred);
     }
 
     @Override
     public CredentialModel createCredential(RealmModel realm, UserModel user, CredentialModel cred) {
-        CredentialEntity entity = new CredentialEntity();
-        String id = cred.getId() == null ? KeycloakModelUtils.generateId() : cred.getId();
-        entity.setId(id);
-        entity.setAlgorithm(cred.getAlgorithm());
-        entity.setCounter(cred.getCounter());
-        entity.setCreatedDate(cred.getCreatedDate());
-        entity.setDevice(cred.getDevice());
-        entity.setDigits(cred.getDigits());
-        entity.setHashIterations(cred.getHashIterations());
-        entity.setPeriod(cred.getPeriod());
-        entity.setSalt(cred.getSalt());
-        entity.setType(cred.getType());
-        entity.setValue(cred.getValue());
-        UserEntity userRef = em.getReference(UserEntity.class, user.getId());
-        entity.setUser(userRef);
-        em.persist(entity);
-
-        MultivaluedHashMap<String, String> config = cred.getConfig();
-        if (config != null && !config.isEmpty()) {
-
-            for (String key : config.keySet()) {
-                List<String> values = config.getList(key);
-                for (String val : values) {
-                    CredentialAttributeEntity attr = new CredentialAttributeEntity();
-                    attr.setId(KeycloakModelUtils.generateId());
-                    attr.setValue(val);
-                    attr.setName(key);
-                    attr.setCredential(entity);
-                    em.persist(attr);
-                    entity.getCredentialAttributes().add(attr);
-                }
-            }
-
-        }
+        CredentialEntity entity = credentialStore.createCredentialEntity(realm, user, cred);
 
         UserEntity userEntity = userInEntityManagerContext(user.getId());
         if (userEntity != null) {
@@ -952,56 +867,26 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
 
     @Override
     public boolean removeStoredCredential(RealmModel realm, UserModel user, String id) {
-        CredentialEntity entity = em.find(CredentialEntity.class, id);
-        if (entity == null) return false;
-        em.remove(entity);
+        CredentialEntity entity = credentialStore.removeCredentialEntity(id);
         UserEntity userEntity = userInEntityManagerContext(user.getId());
-        if (userEntity != null) {
+        if (entity != null && userEntity != null) {
             userEntity.getCredentials().remove(entity);
         }
-        return true;
+        return entity != null;
     }
 
     @Override
     public CredentialModel getStoredCredentialById(RealmModel realm, UserModel user, String id) {
-        CredentialEntity entity = em.find(CredentialEntity.class, id);
-        if (entity == null) return null;
-        CredentialModel model = toModel(entity);
-        return model;
+        return credentialStore.getStoredCredentialById(realm, user, id);
     }
 
     protected CredentialModel toModel(CredentialEntity entity) {
-        CredentialModel model = new CredentialModel();
-        model.setId(entity.getId());
-        model.setType(entity.getType());
-        model.setValue(entity.getValue());
-        model.setAlgorithm(entity.getAlgorithm());
-        model.setSalt(entity.getSalt());
-        model.setPeriod(entity.getPeriod());
-        model.setCounter(entity.getCounter());
-        model.setCreatedDate(entity.getCreatedDate());
-        model.setDevice(entity.getDevice());
-        model.setDigits(entity.getDigits());
-        model.setHashIterations(entity.getHashIterations());
-        MultivaluedHashMap<String, String> config = new MultivaluedHashMap<>();
-        model.setConfig(config);
-        for (CredentialAttributeEntity attr : entity.getCredentialAttributes()) {
-            config.add(attr.getName(), attr.getValue());
-        }
-        return model;
+        return credentialStore.toModel(entity);
     }
 
     @Override
     public List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user) {
-        UserEntity userEntity = em.getReference(UserEntity.class, user.getId());
-        TypedQuery<CredentialEntity> query = em.createNamedQuery("credentialByUser", CredentialEntity.class)
-                .setParameter("user", userEntity);
-        List<CredentialEntity> results = query.getResultList();
-        List<CredentialModel> rtn = new LinkedList<>();
-        for (CredentialEntity entity : results) {
-            rtn.add(toModel(entity));
-        }
-        return rtn;
+        return credentialStore.getStoredCredentials(realm, user);
     }
 
     @Override
@@ -1011,53 +896,46 @@ public class JpaUserProvider implements UserProvider, UserCredentialStore {
         if (userEntity != null) {
 
             // user already in persistence context, no need to execute a query
-            results = userEntity.getCredentials().stream().filter(it -> it.getType().equals(type)).collect(Collectors.toList());
+            results = userEntity.getCredentials().stream().filter(it -> type.equals(it.getType())).collect(Collectors.toList());
+            List<CredentialModel> rtn = new LinkedList<>();
+            for (CredentialEntity entity : results) {
+                rtn.add(toModel(entity));
+            }
+            return rtn;
         } else {
-            userEntity = em.getReference(UserEntity.class, user.getId());
-            TypedQuery<CredentialEntity> query = em.createNamedQuery("credentialByUserAndType", CredentialEntity.class)
-                    .setParameter("type", type)
-                    .setParameter("user", userEntity);
-            results = query.getResultList();
-        }
-        List<CredentialModel> rtn = new LinkedList<>();
-        for (CredentialEntity entity : results) {
-            rtn.add(toModel(entity));
+           return credentialStore.getStoredCredentialsByType(realm, user, type);
         }
-        return rtn;
     }
 
     @Override
     public CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type) {
-        UserEntity userEntity = em.getReference(UserEntity.class, user.getId());
-        TypedQuery<CredentialEntity> query = em.createNamedQuery("credentialByNameAndType", CredentialEntity.class)
-                .setParameter("type", type)
-                .setParameter("device", name)
-                .setParameter("user", userEntity);
-        List<CredentialEntity> results = query.getResultList();
-        if (results.isEmpty()) return null;
-        return toModel(results.get(0));
+        return credentialStore.getStoredCredentialByNameAndType(realm, user, name, type);
+    }
+
+    public void moveCredentialTo(RealmModel realm, UserModel user, String id, String newPreviousCredentialId) {
+        credentialStore.moveCredentialTo(realm, user, id, newPreviousCredentialId);
     }
 
     // Could override this to provide a custom behavior.
     protected void ensureEmailConstraint(List<UserEntity> users, RealmModel realm) {
         UserEntity user = users.get(0);
-        
+
         if (users.size() > 1) {
             // Realm settings have been changed from allowing duplicate emails to not allowing them
             // but duplicates haven't been removed.
             throw new ModelDuplicateException("Multiple users with email '" + user.getEmail() + "' exist in Keycloak.");
         }
-        
+
         if (realm.isDuplicateEmailsAllowed()) {
             return;
         }
-     
+
         if (user.getEmail() != null && !user.getEmail().equals(user.getEmailConstraint())) {
             // Realm settings have been changed from allowing duplicate emails to not allowing them.
             // We need to update the email constraint to reflect this change in the user entities.
             user.setEmailConstraint(user.getEmail());
             em.persist(user);
-        }  
+        }
     }
 
     private UserEntity userInEntityManagerContext(String id) {
diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java b/model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java
index 4acf135b5f..42f7af3aea 100755
--- a/model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java
+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java
@@ -586,6 +586,9 @@ public class RealmAdapter implements RealmModel, JpaModel<RealmEntity> {
 
     @Override
     public int getActionTokenGeneratedByUserLifespan(String actionTokenId) {
+        if (actionTokenId == null || getAttribute(RealmAttributes.ACTION_TOKEN_GENERATED_BY_USER_LIFESPAN + "." + actionTokenId) == null) {
+            return getActionTokenGeneratedByUserLifespan();
+        }
         return getAttribute(RealmAttributes.ACTION_TOKEN_GENERATED_BY_USER_LIFESPAN + "." + actionTokenId, getAccessCodeLifespanUserAction());
     }
 
@@ -1572,6 +1575,16 @@ public class RealmAdapter implements RealmModel, JpaModel<RealmEntity> {
         return entityToModel(entity);
     }
 
+    public AuthenticationExecutionModel getAuthenticationExecutionByFlowId(String flowId) {
+        TypedQuery<AuthenticationExecutionEntity> query = em.createNamedQuery("authenticationFlowExecution", AuthenticationExecutionEntity.class)
+                .setParameter("flowId", flowId);
+        if (query.getResultList().isEmpty()) {
+            return null;
+        }
+        AuthenticationExecutionEntity authenticationFlowExecution = query.getResultList().get(0);
+        return entityToModel(authenticationFlowExecution);
+    }
+
     @Override
     public AuthenticationExecutionModel addAuthenticatorExecution(AuthenticationExecutionModel model) {
         AuthenticationExecutionEntity entity = new AuthenticationExecutionEntity();
diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/entities/AuthenticationExecutionEntity.java b/model/jpa/src/main/java/org/keycloak/models/jpa/entities/AuthenticationExecutionEntity.java
index 9ec6691b51..70c438cf57 100755
--- a/model/jpa/src/main/java/org/keycloak/models/jpa/entities/AuthenticationExecutionEntity.java
+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/entities/AuthenticationExecutionEntity.java
@@ -27,12 +27,17 @@ import javax.persistence.FetchType;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.ManyToOne;
+import javax.persistence.NamedQueries;
+import javax.persistence.NamedQuery;
 import javax.persistence.Table;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
+@NamedQueries({
+        @NamedQuery(name = "authenticationFlowExecution", query = "select authExec from AuthenticationExecutionEntity authExec where authExec.flowId = :flowId")
+})
 @Table(name="AUTHENTICATION_EXECUTION")
 @Entity
 public class AuthenticationExecutionEntity {
diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/entities/AuthenticationFlowEntity.java b/model/jpa/src/main/java/org/keycloak/models/jpa/entities/AuthenticationFlowEntity.java
index a56c2eeb67..7a9afc2baa 100755
--- a/model/jpa/src/main/java/org/keycloak/models/jpa/entities/AuthenticationFlowEntity.java
+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/entities/AuthenticationFlowEntity.java
@@ -28,6 +28,8 @@ import javax.persistence.FetchType;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.ManyToOne;
+import javax.persistence.NamedQueries;
+import javax.persistence.NamedQuery;
 import javax.persistence.OneToMany;
 import javax.persistence.Table;
 import java.util.ArrayList;
diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/entities/CredentialAttributeEntity.java b/model/jpa/src/main/java/org/keycloak/models/jpa/entities/CredentialAttributeEntity.java
deleted file mode 100755
index f4ceb947ee..0000000000
--- a/model/jpa/src/main/java/org/keycloak/models/jpa/entities/CredentialAttributeEntity.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright 2016 Red Hat, Inc. and/or its affiliates
- * and other contributors as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.keycloak.models.jpa.entities;
-
-import javax.persistence.Access;
-import javax.persistence.AccessType;
-import javax.persistence.Column;
-import javax.persistence.Entity;
-import javax.persistence.FetchType;
-import javax.persistence.Id;
-import javax.persistence.JoinColumn;
-import javax.persistence.ManyToOne;
-import javax.persistence.NamedQueries;
-import javax.persistence.NamedQuery;
-import javax.persistence.Table;
-
-/**
- * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
- * @version $Revision: 1 $
- */
-@NamedQueries({
-        @NamedQuery(name="getCredentialAttribute", query="select attr from CredentialAttributeEntity attr where attr.credential = :credential"),
-        @NamedQuery(name="deleteCredentialAttributeByCredential", query="delete from  CredentialAttributeEntity attr where attr.credential = :credential"),
-        @NamedQuery(name="deleteCredentialAttributeByRealm", query="delete from  CredentialAttributeEntity attr where attr.credential IN (select cred from CredentialEntity cred where cred.user IN (select u from UserEntity u where u.realmId=:realmId))"),
-        @NamedQuery(name="deleteCredentialAttributeByRealmAndLink", query="delete from  CredentialAttributeEntity attr where attr.credential IN (select cred from CredentialEntity cred where cred.user IN (select u from UserEntity u where u.realmId=:realmId and u.federationLink=:link))"),
-        @NamedQuery(name="deleteCredentialAttributeByUser", query="delete from  CredentialAttributeEntity attr where attr.credential IN (select cred from CredentialEntity cred where cred.user = :user)"),
-})
-@Table(name="CREDENTIAL_ATTRIBUTE")
-@Entity
-public class CredentialAttributeEntity {
-
-    @Id
-    @Column(name="ID", length = 36)
-    @Access(AccessType.PROPERTY) // we do this because relationships often fetch id, but not entity.  This avoids an extra SQL
-    protected String id;
-
-    @ManyToOne(fetch= FetchType.LAZY)
-    @JoinColumn(name = "CREDENTIAL_ID")
-    protected CredentialEntity credential;
-
-    @Column(name = "NAME")
-    protected String name;
-    @Column(name = "VALUE")
-    protected String value;
-
-    public String getId() {
-        return id;
-    }
-
-    public void setId(String id) {
-        this.id = id;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getValue() {
-        return value;
-    }
-
-    public void setValue(String value) {
-        this.value = value;
-    }
-
-    public CredentialEntity getCredential() {
-        return credential;
-    }
-
-    public void setCredential(CredentialEntity credential) {
-        this.credential = credential;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null) return false;
-        if (!(o instanceof CredentialAttributeEntity)) return false;
-
-        CredentialAttributeEntity that = (CredentialAttributeEntity) o;
-
-        if (!id.equals(that.getId())) return false;
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        return id.hashCode();
-    }
-
-}
diff --git a/model/jpa/src/main/java/org/keycloak/models/jpa/entities/CredentialEntity.java b/model/jpa/src/main/java/org/keycloak/models/jpa/entities/CredentialEntity.java
index 4c8f0b3e83..83f01f88d8 100755
--- a/model/jpa/src/main/java/org/keycloak/models/jpa/entities/CredentialEntity.java
+++ b/model/jpa/src/main/java/org/keycloak/models/jpa/entities/CredentialEntity.java
@@ -25,6 +25,7 @@ import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
+import javax.persistence.Lob;
 import javax.persistence.ManyToOne;
 import javax.persistence.NamedQueries;
 import javax.persistence.NamedQuery;
@@ -39,8 +40,8 @@ import java.util.Collection;
  */
 @NamedQueries({
         @NamedQuery(name="credentialByUser", query="select cred from CredentialEntity cred where cred.user = :user"),
-        @NamedQuery(name="credentialByUserAndType", query="select cred from CredentialEntity cred where cred.user = :user and cred.type = :type"),
-        @NamedQuery(name="credentialByNameAndType", query="select cred from CredentialEntity cred where cred.user = :user and cred.type = :type and cred.device = :device"),
+        @NamedQuery(name="firstCredentialInList", query="select cred from CredentialEntity cred where cred.user = :user and previousCredentialLink is null"),
+        @NamedQuery(name="lastCredentialInList", query="select cred from CredentialEntity cred where cred.user = :user and nextCredentialLink is null"),
         @NamedQuery(name="deleteCredentialsByRealm", query="delete from CredentialEntity cred where cred.user IN (select u from UserEntity u where u.realmId=:realmId)"),
         @NamedQuery(name="deleteCredentialsByRealmAndLink", query="delete from CredentialEntity cred where cred.user IN (select u from UserEntity u where u.realmId=:realmId and u.federationLink=:link)")
 
@@ -55,14 +56,10 @@ public class CredentialEntity {
 
     @Column(name="TYPE")
     protected String type;
-    @Column(name="VALUE")
-    protected String value;
-    @Column(name="DEVICE")
-    protected String device;
-    @Column(name="SALT")
-    protected byte[] salt;
-    @Column(name="HASH_ITERATIONS")
-    protected int hashIterations;
+
+    @Column(name="USER_LABEL")
+    protected String userLabel;
+
     @Column(name="CREATED_DATE")
     protected Long createdDate;
     
@@ -70,121 +67,79 @@ public class CredentialEntity {
     @JoinColumn(name="USER_ID")
     protected UserEntity user;
 
-    @Column(name="COUNTER")
-    protected int counter;
+    @Column(name="SECRET_DATA")
+    protected String secretData;
 
-    @Column(name="ALGORITHM")
-    protected String algorithm;
-    @Column(name="DIGITS")
-    protected int digits;
-    @Column(name="PERIOD")
-    protected int period;
+    @Column(name="CREDENTIAL_DATA")
+    protected String credentialData;
 
-    @OneToMany(cascade = CascadeType.REMOVE, fetch = FetchType.EAGER, orphanRemoval = true, mappedBy="credential")
-    protected Collection<CredentialAttributeEntity> credentialAttributes = new ArrayList<>();
+    @Column(name="PREVIOUS_CREDENTIAL_LINK")
+    protected String previousCredentialLink;
+
+    @Column(name="NEXT_CREDENTIAL_LINK")
+    protected String nextCredentialLink;
 
     public String getId() {
         return id;
     }
-
     public void setId(String id) {
         this.id = id;
     }
 
-    public String getValue() {
-        return value;
-    }
-
-    public void setValue(String value) {
-        this.value = value;
-    }
-
     public String getType() {
         return type;
     }
-
     public void setType(String type) {
         this.type = type;
     }
 
-    public String getDevice() {
-        return device;
+    public String getUserLabel() {
+        return userLabel;
     }
-
-    public void setDevice(String device) {
-        this.device = device;
+    public void setUserLabel(String userLabel) {
+        this.userLabel = userLabel;
     }
 
     public UserEntity getUser() {
         return user;
     }
-
     public void setUser(UserEntity user) {
         this.user = user;
     }
 
-    public byte[] getSalt() {
-        return salt;
-    }
-
-    public void setSalt(byte[] salt) {
-        this.salt = salt;
-    }
-
-    public int getHashIterations() {
-        return hashIterations;
-    }
-
-    public void setHashIterations(int hashIterations) {
-        this.hashIterations = hashIterations;
-    }
-
     public Long getCreatedDate() {
         return createdDate;
     }
-
     public void setCreatedDate(Long createdDate) {
         this.createdDate = createdDate;
     }
 
-    public int getCounter() {
-        return counter;
-    }
-
-    public void setCounter(int counter) {
-        this.counter = counter;
+    public String getSecretData() {
+        return secretData;
     }
-
-    public String getAlgorithm() {
-        return algorithm;
+    public void setSecretData(String secretData) {
+        this.secretData = secretData;
     }
 
-    public void setAlgorithm(String algorithm) {
-        this.algorithm = algorithm;
+    public String getCredentialData() {
+        return credentialData;
     }
-
-    public int getDigits() {
-        return digits;
+    public void setCredentialData(String credentialData) {
+        this.credentialData = credentialData;
     }
 
-    public void setDigits(int digits) {
-        this.digits = digits;
+    public String getPreviousCredentialLink() {
+        return previousCredentialLink;
     }
-
-    public int getPeriod() {
-        return period;
+    public void setPreviousCredentialLink(String previousCredentialLink) {
+        this.previousCredentialLink = previousCredentialLink;
     }
 
-    public void setPeriod(int period) {
-        this.period = period;
+    public String getNextCredentialLink() {
+        return nextCredentialLink;
     }
-
-    public Collection<CredentialAttributeEntity> getCredentialAttributes() {
-        return credentialAttributes;
-    }
-
-    public void setCredentialAttributes(Collection<CredentialAttributeEntity> credentialAttributes) {
-        this.credentialAttributes = credentialAttributes;
+    public void setNextCredentialLink(String nextCredentialLink) {
+        this.nextCredentialLink = nextCredentialLink;
     }
 
     @Override
diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java
index e4402f34fc..8d24f64d4e 100644
--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java
+++ b/model/jpa/src/main/java/org/keycloak/storage/jpa/JpaUserFederatedStorageProvider.java
@@ -43,7 +43,6 @@ import org.keycloak.storage.jpa.entity.FederatedUser;
 import org.keycloak.storage.jpa.entity.FederatedUserAttributeEntity;
 import org.keycloak.storage.jpa.entity.FederatedUserConsentClientScopeEntity;
 import org.keycloak.storage.jpa.entity.FederatedUserConsentEntity;
-import org.keycloak.storage.jpa.entity.FederatedUserCredentialAttributeEntity;
 import org.keycloak.storage.jpa.entity.FederatedUserCredentialEntity;
 import org.keycloak.storage.jpa.entity.FederatedUserGroupMembershipEntity;
 import org.keycloak.storage.jpa.entity.FederatedUserRequiredActionEntity;
@@ -55,7 +54,6 @@ import javax.persistence.TypedQuery;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashSet;
-import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Set;
@@ -560,53 +558,11 @@ public class JpaUserFederatedStorageProvider implements
         FederatedUserCredentialEntity entity = em.find(FederatedUserCredentialEntity.class, cred.getId());
         if (entity == null) return;
         createIndex(realm, userId);
-        entity.setAlgorithm(cred.getAlgorithm());
-        entity.setCounter(cred.getCounter());
         entity.setCreatedDate(cred.getCreatedDate());
-        entity.setDevice(cred.getDevice());
-        entity.setDigits(cred.getDigits());
-        entity.setHashIterations(cred.getHashIterations());
-        entity.setPeriod(cred.getPeriod());
-        entity.setSalt(cred.getSalt());
         entity.setType(cred.getType());
-        entity.setValue(cred.getValue());
-        if (entity.getCredentialAttributes().isEmpty() && (cred.getConfig() == null || cred.getConfig().isEmpty())) {
-
-        } else {
-            MultivaluedHashMap<String, String> attrs = new MultivaluedHashMap<>();
-            MultivaluedHashMap<String, String> config = cred.getConfig();
-            if (config == null) config = new MultivaluedHashMap<>();
-
-            Iterator<FederatedUserCredentialAttributeEntity> it = entity.getCredentialAttributes().iterator();
-            while (it.hasNext()) {
-                FederatedUserCredentialAttributeEntity attr = it.next();
-                List<String> values = config.getList(attr.getName());
-                if (values == null || !values.contains(attr.getValue())) {
-                    em.remove(attr);
-                    it.remove();
-                } else {
-                    attrs.add(attr.getName(), attr.getValue());
-                }
-
-            }
-            for (String key : config.keySet()) {
-                List<String> values = config.getList(key);
-                List<String> attrValues = attrs.getList(key);
-                for (String val : values) {
-                    if (attrValues == null || !attrValues.contains(val)) {
-                        FederatedUserCredentialAttributeEntity attr = new FederatedUserCredentialAttributeEntity();
-                        attr.setId(KeycloakModelUtils.generateId());
-                        attr.setValue(val);
-                        attr.setName(key);
-                        attr.setCredential(entity);
-                        em.persist(attr);
-                        entity.getCredentialAttributes().add(attr);
-                    }
-                }
-            }
-
-        }
-
+        entity.setCredentialData(cred.getCredentialData());
+        entity.setSecretData(cred.getSecretData());
+        cred.setUserLabel(entity.getUserLabel());
     }
 
     @Override
@@ -615,37 +571,16 @@ public class JpaUserFederatedStorageProvider implements
         FederatedUserCredentialEntity entity = new FederatedUserCredentialEntity();
         String id = cred.getId() == null ? KeycloakModelUtils.generateId() : cred.getId();
         entity.setId(id);
-        entity.setAlgorithm(cred.getAlgorithm());
-        entity.setCounter(cred.getCounter());
         entity.setCreatedDate(cred.getCreatedDate());
-        entity.setDevice(cred.getDevice());
-        entity.setDigits(cred.getDigits());
-        entity.setHashIterations(cred.getHashIterations());
-        entity.setPeriod(cred.getPeriod());
-        entity.setSalt(cred.getSalt());
         entity.setType(cred.getType());
-        entity.setValue(cred.getValue());
+        entity.setCredentialData(cred.getCredentialData());
+        entity.setSecretData(cred.getSecretData());
+        cred.setUserLabel(entity.getUserLabel());
+
         entity.setUserId(userId);
         entity.setRealmId(realm.getId());
         entity.setStorageProviderId(new StorageId(userId).getProviderId());
         em.persist(entity);
-        MultivaluedHashMap<String, String> config = cred.getConfig();
-        if (config != null && !config.isEmpty()) {
-
-            for (String key : config.keySet()) {
-                List<String> values = config.getList(key);
-                for (String val : values) {
-                    FederatedUserCredentialAttributeEntity attr = new FederatedUserCredentialAttributeEntity();
-                    attr.setId(KeycloakModelUtils.generateId());
-                    attr.setValue(val);
-                    attr.setName(key);
-                    attr.setCredential(entity);
-                    em.persist(attr);
-                    entity.getCredentialAttributes().add(attr);
-                }
-            }
-
-        }
         return toModel(entity);
     }
 
@@ -669,20 +604,10 @@ public class JpaUserFederatedStorageProvider implements
         CredentialModel model = new CredentialModel();
         model.setId(entity.getId());
         model.setType(entity.getType());
-        model.setValue(entity.getValue());
-        model.setAlgorithm(entity.getAlgorithm());
-        model.setSalt(entity.getSalt());
-        model.setPeriod(entity.getPeriod());
-        model.setCounter(entity.getCounter());
         model.setCreatedDate(entity.getCreatedDate());
-        model.setDevice(entity.getDevice());
-        model.setDigits(entity.getDigits());
-        model.setHashIterations(entity.getHashIterations());
-        MultivaluedHashMap<String, String> config = new MultivaluedHashMap<>();
-        model.setConfig(config);
-        for (FederatedUserCredentialAttributeEntity attr : entity.getCredentialAttributes()) {
-            config.add(attr.getName(), attr.getValue());
-        }
+        model.setUserLabel(entity.getUserLabel());
+        model.setSecretData(entity.getSecretData());
+        model.setCredentialData(entity.getCredentialData());
         return model;
     }
 
@@ -766,6 +691,11 @@ public class JpaUserFederatedStorageProvider implements
         return getStoredCredentialByNameAndType(realm, user.getId(), name, type);
     }
 
+    @Override
+    public void moveCredentialTo(RealmModel realm, UserModel user, String id, String newPreviousCredentialId) {
+        //do nothing, these credentials are not ordered
+    }
+
     @Override
     public int getStoredUsersCount(RealmModel realm) {
         Object count = em.createNamedQuery("getFederatedUserCount")
@@ -786,8 +716,6 @@ public class JpaUserFederatedStorageProvider implements
                 .setParameter("realmId", realm.getId()).executeUpdate();
         num = em.createNamedQuery("deleteBrokerLinkByRealm")
                 .setParameter("realmId", realm.getId()).executeUpdate();
-        num = em.createNamedQuery("deleteFederatedCredentialAttributeByRealm")
-                .setParameter("realmId", realm.getId()).executeUpdate();
         num = em.createNamedQuery("deleteFederatedUserCredentialsByRealm")
                 .setParameter("realmId", realm.getId()).executeUpdate();
         num = em.createNamedQuery("deleteUserFederatedAttributesByRealm")
@@ -857,10 +785,6 @@ public class JpaUserFederatedStorageProvider implements
                 .setParameter("userId", user.getId())
                 .setParameter("realmId", realm.getId())
                 .executeUpdate();
-        em.createNamedQuery("deleteFederatedCredentialAttributeByUser")
-                .setParameter("userId", user.getId())
-                .setParameter("realmId", realm.getId())
-                .executeUpdate();
         em.createNamedQuery("deleteFederatedUserCredentialByUser")
                 .setParameter("userId", user.getId())
                 .setParameter("realmId", realm.getId())
@@ -900,9 +824,6 @@ public class JpaUserFederatedStorageProvider implements
             em.createNamedQuery("deleteFederatedUserConsentsByStorageProvider")
                     .setParameter("storageProviderId", model.getId())
                     .executeUpdate();
-            em.createNamedQuery("deleteFederatedCredentialAttributeByStorageProvider")
-                    .setParameter("storageProviderId", model.getId())
-                    .executeUpdate();
             em.createNamedQuery("deleteFederatedUserCredentialsByStorageProvider")
                     .setParameter("storageProviderId", model.getId())
                     .executeUpdate();
diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/entity/FederatedUserCredentialAttributeEntity.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/entity/FederatedUserCredentialAttributeEntity.java
deleted file mode 100755
index d89567e814..0000000000
--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/entity/FederatedUserCredentialAttributeEntity.java
+++ /dev/null
@@ -1,111 +0,0 @@
-/*
- * Copyright 2016 Red Hat, Inc. and/or its affiliates
- * and other contributors as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.keycloak.storage.jpa.entity;
-
-import javax.persistence.Access;
-import javax.persistence.AccessType;
-import javax.persistence.Column;
-import javax.persistence.Entity;
-import javax.persistence.FetchType;
-import javax.persistence.Id;
-import javax.persistence.JoinColumn;
-import javax.persistence.ManyToOne;
-import javax.persistence.NamedQueries;
-import javax.persistence.NamedQuery;
-import javax.persistence.Table;
-
-/**
- * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
- * @version $Revision: 1 $
- */
-@NamedQueries({
-        @NamedQuery(name="deleteFederatedCredentialAttributeByCredential", query="delete from  FederatedUserCredentialAttributeEntity attr where attr.credential = :credential"),
-        @NamedQuery(name="deleteFederatedCredentialAttributeByStorageProvider", query="delete from  FederatedUserCredentialAttributeEntity attr where attr.credential IN (select cred from FederatedUserCredentialEntity cred where cred.storageProviderId=:storageProviderId)"),
-        @NamedQuery(name="deleteFederatedCredentialAttributeByRealm", query="delete from  FederatedUserCredentialAttributeEntity attr where attr.credential IN (select cred from FederatedUserCredentialEntity cred where cred.realmId=:realmId)"),
-        @NamedQuery(name="deleteFederatedCredentialAttributeByRealmAndLink", query="delete from  FederatedUserCredentialAttributeEntity attr where attr.credential IN (select cred from FederatedUserCredentialEntity cred where cred.userId IN (select u.id from UserEntity u where u.realmId=:realmId and u.federationLink=:link))"),
-        @NamedQuery(name="deleteFederatedCredentialAttributeByUser", query="delete from  FederatedUserCredentialAttributeEntity attr where attr.credential IN (select cred from FederatedUserCredentialEntity cred where cred.userId = :userId and cred.realmId = :realmId)"),
-})
-@Table(name="FED_CREDENTIAL_ATTRIBUTE")
-@Entity
-public class FederatedUserCredentialAttributeEntity {
-
-    @Id
-    @Column(name="ID", length = 36)
-    @Access(AccessType.PROPERTY) // we do this because relationships often fetch id, but not entity.  This avoids an extra SQL
-    protected String id;
-
-    @ManyToOne(fetch= FetchType.LAZY)
-    @JoinColumn(name = "CREDENTIAL_ID")
-    protected FederatedUserCredentialEntity credential;
-
-    @Column(name = "NAME")
-    protected String name;
-    @Column(name = "VALUE")
-    protected String value;
-
-    public String getId() {
-        return id;
-    }
-
-    public void setId(String id) {
-        this.id = id;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public String getValue() {
-        return value;
-    }
-
-    public void setValue(String value) {
-        this.value = value;
-    }
-
-    public FederatedUserCredentialEntity getCredential() {
-        return credential;
-    }
-
-    public void setCredential(FederatedUserCredentialEntity credential) {
-        this.credential = credential;
-    }
-
-    @Override
-    public boolean equals(Object o) {
-        if (this == o) return true;
-        if (o == null) return false;
-        if (!(o instanceof FederatedUserCredentialAttributeEntity)) return false;
-
-        FederatedUserCredentialAttributeEntity that = (FederatedUserCredentialAttributeEntity) o;
-
-        if (!id.equals(that.getId())) return false;
-
-        return true;
-    }
-
-    @Override
-    public int hashCode() {
-        return id.hashCode();
-    }
-
-}
diff --git a/model/jpa/src/main/java/org/keycloak/storage/jpa/entity/FederatedUserCredentialEntity.java b/model/jpa/src/main/java/org/keycloak/storage/jpa/entity/FederatedUserCredentialEntity.java
index 2d4bbc7b56..6936b6b997 100755
--- a/model/jpa/src/main/java/org/keycloak/storage/jpa/entity/FederatedUserCredentialEntity.java
+++ b/model/jpa/src/main/java/org/keycloak/storage/jpa/entity/FederatedUserCredentialEntity.java
@@ -17,6 +17,8 @@
 
 package org.keycloak.storage.jpa.entity;
 
+import org.keycloak.models.jpa.entities.UserEntity;
+
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.CascadeType;
@@ -24,6 +26,7 @@ import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.Id;
+import javax.persistence.Lob;
 import javax.persistence.NamedQueries;
 import javax.persistence.NamedQuery;
 import javax.persistence.OneToMany;
@@ -38,10 +41,10 @@ import java.util.Collection;
 @NamedQueries({
         @NamedQuery(name="federatedUserCredentialByUser", query="select cred from FederatedUserCredentialEntity cred where cred.userId = :userId"),
         @NamedQuery(name="federatedUserCredentialByUserAndType", query="select cred from FederatedUserCredentialEntity cred where cred.userId = :userId and cred.type = :type"),
-        @NamedQuery(name="federatedUserCredentialByNameAndType", query="select cred from FederatedUserCredentialEntity cred where cred.userId = :userId and cred.type = :type and cred.device = :device"),
+        @NamedQuery(name="federatedUserCredentialByNameAndType", query="select cred from FederatedUserCredentialEntity cred where cred.userId = :userId and cred.type = :type and cred.userLabel = :userLabel"),
         @NamedQuery(name="deleteFederatedUserCredentialByUser", query="delete from FederatedUserCredentialEntity cred where cred.userId = :userId and cred.realmId = :realmId"),
         @NamedQuery(name="deleteFederatedUserCredentialByUserAndType", query="delete from FederatedUserCredentialEntity cred where cred.userId = :userId and cred.type = :type"),
-        @NamedQuery(name="deleteFederatedUserCredentialByUserAndTypeAndDevice", query="delete from FederatedUserCredentialEntity cred where cred.userId = :userId and cred.type = :type and cred.device = :device"),
+        @NamedQuery(name="deleteFederatedUserCredentialByUserAndTypeAndUserLabel", query="delete from FederatedUserCredentialEntity cred where cred.userId = :userId and cred.type = :type and cred.userLabel = :userLabel"),
         @NamedQuery(name="deleteFederatedUserCredentialsByRealm", query="delete from FederatedUserCredentialEntity cred where cred.realmId=:realmId"),
         @NamedQuery(name="deleteFederatedUserCredentialsByStorageProvider", query="delete from FederatedUserCredentialEntity cred where cred.storageProviderId=:storageProviderId"),
         @NamedQuery(name="deleteFederatedUserCredentialsByRealmAndLink", query="delete from FederatedUserCredentialEntity cred where cred.userId IN (select u.id from UserEntity u where u.realmId=:realmId and u.federationLink=:link)")
@@ -55,19 +58,21 @@ public class FederatedUserCredentialEntity {
     @Access(AccessType.PROPERTY) // we do this because relationships often fetch id, but not entity.  This avoids an extra SQL
     protected String id;
 
+    @Column(name="SECRET_DATA")
+    protected String secretData;
+
+    @Column(name="CREDENTIAL_DATA")
+    protected String credentialData;
+
     @Column(name="TYPE")
     protected String type;
-    @Column(name="VALUE")
-    protected String value;
-    @Column(name="DEVICE")
-    protected String device;
-    @Column(name="SALT")
-    protected byte[] salt;
-    @Column(name="HASH_ITERATIONS")
-    protected int hashIterations;
+
+    @Column(name="USER_LABEL")
+    protected String userLabel;
+
     @Column(name="CREATED_DATE")
     protected Long createdDate;
-    
+
     @Column(name="USER_ID")
     protected String userId;
 
@@ -78,56 +83,54 @@ public class FederatedUserCredentialEntity {
     protected String storageProviderId;
 
 
-
-    @Column(name="COUNTER")
-    protected int counter;
-
-    @Column(name="ALGORITHM")
-    protected String algorithm;
-    @Column(name="DIGITS")
-    protected int digits;
-    @Column(name="PERIOD")
-    protected int period;
-    @OneToMany(cascade = CascadeType.REMOVE, fetch = FetchType.EAGER, orphanRemoval = true, mappedBy="credential")
-    protected Collection<FederatedUserCredentialAttributeEntity> credentialAttributes = new ArrayList<>();
-
-
     public String getId() {
         return id;
     }
-
     public void setId(String id) {
         this.id = id;
     }
 
-    public String getValue() {
-        return value;
-    }
-
-    public void setValue(String value) {
-        this.value = value;
-    }
 
     public String getType() {
         return type;
     }
-
     public void setType(String type) {
         this.type = type;
     }
 
-    public String getDevice() {
-        return device;
+    public String getUserLabel() {
+        return userLabel;
+    }
+    public void setUserLabel(String userLabel) {
+        this.userLabel = userLabel;
+    }
+
+    public Long getCreatedDate() {
+        return createdDate;
+    }
+    public void setCreatedDate(Long createdDate) {
+        this.createdDate = createdDate;
     }
 
-    public void setDevice(String device) {
-        this.device = device;
+    public String getSecretData() {
+        return secretData;
+    }
+    public void setSecretData(String secretData) {
+        this.secretData = secretData;
     }
 
+    public String getCredentialData() {
+        return credentialData;
+    }
+    public void setCredentialData(String credentialData) {
+        this.credentialData = credentialData;
+    }
+
+
+
     public String getUserId() {
         return userId;
     }
-
     public void setUserId(String userId) {
         this.userId = userId;
     }
@@ -135,7 +138,6 @@ public class FederatedUserCredentialEntity {
     public String getRealmId() {
         return realmId;
     }
-
     public void setRealmId(String realmId) {
         this.realmId = realmId;
     }
@@ -143,74 +145,10 @@ public class FederatedUserCredentialEntity {
     public String getStorageProviderId() {
         return storageProviderId;
     }
-
     public void setStorageProviderId(String storageProviderId) {
         this.storageProviderId = storageProviderId;
     }
 
-    public byte[] getSalt() {
-        return salt;
-    }
-
-    public void setSalt(byte[] salt) {
-        this.salt = salt;
-    }
-
-    public int getHashIterations() {
-        return hashIterations;
-    }
-
-    public void setHashIterations(int hashIterations) {
-        this.hashIterations = hashIterations;
-    }
-
-    public Long getCreatedDate() {
-        return createdDate;
-    }
-
-    public void setCreatedDate(Long createdDate) {
-        this.createdDate = createdDate;
-    }
-
-    public int getCounter() {
-        return counter;
-    }
-
-    public void setCounter(int counter) {
-        this.counter = counter;
-    }
-
-    public String getAlgorithm() {
-        return algorithm;
-    }
-
-    public void setAlgorithm(String algorithm) {
-        this.algorithm = algorithm;
-    }
-
-    public int getDigits() {
-        return digits;
-    }
-
-    public void setDigits(int digits) {
-        this.digits = digits;
-    }
-
-    public int getPeriod() {
-        return period;
-    }
-
-    public void setPeriod(int period) {
-        this.period = period;
-    }
-
-    public Collection<FederatedUserCredentialAttributeEntity> getCredentialAttributes() {
-        return credentialAttributes;
-    }
-
-    public void setCredentialAttributes(Collection<FederatedUserCredentialAttributeEntity> credentialAttributes) {
-        this.credentialAttributes = credentialAttributes;
-    }
 
     @Override
     public boolean equals(Object o) {
diff --git a/model/jpa/src/main/resources/META-INF/jpa-changelog-7.0.0.xml b/model/jpa/src/main/resources/META-INF/jpa-changelog-7.0.0.xml
new file mode 100644
index 0000000000..e07708e6f6
--- /dev/null
+++ b/model/jpa/src/main/resources/META-INF/jpa-changelog-7.0.0.xml
@@ -0,0 +1,80 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!--
+  ~ * Copyright 2018 Red Hat, Inc. and/or its affiliates
+  ~ * and other contributors as indicated by the @author tags.
+  ~ *
+  ~ * Licensed under the Apache License, Version 2.0 (the "License");
+  ~ * you may not use this file except in compliance with the License.
+  ~ * You may obtain a copy of the License at
+  ~ *
+  ~ * http://www.apache.org/licenses/LICENSE-2.0
+  ~ *
+  ~ * Unless required by applicable law or agreed to in writing, software
+  ~ * distributed under the License is distributed on an "AS IS" BASIS,
+  ~ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  ~ * See the License for the specific language governing permissions and
+  ~ * limitations under the License.
+  -->
+<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd">
+
+    <!--modifies the credentials to the new format, while copying the data as json in the new fields-->
+    <changeSet author="alistair.doswald@elca.ch" id="7.0.0">
+        <addColumn tableName="CREDENTIAL">
+            <column name="SECRET_DATA" type="CLOB">
+                <constraints nullable="true"/>
+            </column>
+            <column name="CREDENTIAL_DATA" type="CLOB">
+                <constraints nullable="true"/>
+            </column>
+            <column name="PREVIOUS_CREDENTIAL_LINK" type="VARCHAR">
+                <constraints nullable="true"/>
+            </column>
+            <column name="NEXT_CREDENTIAL_LINK" type="VARCHAR">
+                <constraints nullable="true"/>
+            </column>
+        </addColumn>
+
+        <addColumn tableName="FED_USER_CREDENTIAL">
+            <column name="SECRET_DATA" type="CLOB">
+                <constraints nullable="true"/>
+            </column>
+            <column name="CREDENTIAL_DATA" type="CLOB">
+                <constraints nullable="true"/>
+            </column>
+        </addColumn>
+
+        <!--Update format of credential to fill secret_data and credential_data-->
+        <customChange class="org.keycloak.connections.jpa.updater.liquibase.custom.JpaUpdate7_0_0_Credentials"/>
+
+        <!--Update format of fed_user_credential to fill secret_data and credential_data-->
+        <customChange class="org.keycloak.connections.jpa.updater.liquibase.custom.JpaUpdate7_0_0_FederatedUserCredentials"/>
+
+        <renameColumn tableName="CREDENTIAL" oldColumnName="DEVICE" newColumnName="USER_LABEL"/>
+
+        <dropColumn tableName="CREDENTIAL" columnName="HASH_ITERATIONS"/>
+        <dropColumn tableName="CREDENTIAL" columnName="SALT"/>
+        <dropColumn tableName="CREDENTIAL" columnName="VALUE"/>
+        <dropColumn tableName="CREDENTIAL" columnName="COUNTER"/>
+        <dropColumn tableName="CREDENTIAL" columnName="DIGITS"/>
+        <dropColumn tableName="CREDENTIAL" columnName="PERIOD"/>
+        <dropColumn tableName="CREDENTIAL" columnName="ALGORITHM"/>
+
+        <!--credential attributes are now held within the json of secret_data and credential_data (not this it was used in any case)-->
+        <dropTable tableName="CREDENTIAL_ATTRIBUTE"/>
+
+        <renameColumn tableName="FED_USER_CREDENTIAL" oldColumnName="DEVICE" newColumnName="USER_LABEL"/>
+
+        <dropColumn tableName="FED_USER_CREDENTIAL" columnName="HASH_ITERATIONS"/>
+        <dropColumn tableName="FED_USER_CREDENTIAL" columnName="SALT"/>
+        <dropColumn tableName="FED_USER_CREDENTIAL" columnName="VALUE"/>
+        <dropColumn tableName="FED_USER_CREDENTIAL" columnName="COUNTER"/>
+        <dropColumn tableName="FED_USER_CREDENTIAL" columnName="DIGITS"/>
+        <dropColumn tableName="FED_USER_CREDENTIAL" columnName="PERIOD"/>
+        <dropColumn tableName="FED_USER_CREDENTIAL" columnName="ALGORITHM"/>
+
+        <!--credential attributes are now held within the json of secret_data and credential_data (not this it was used in any case)-->
+        <dropTable tableName="FED_CREDENTIAL_ATTRIBUTE "/>
+
+    </changeSet>
+
+</databaseChangeLog>
\ No newline at end of file
diff --git a/model/jpa/src/main/resources/META-INF/jpa-changelog-master.xml b/model/jpa/src/main/resources/META-INF/jpa-changelog-master.xml
index ee83eef3dc..92e1ccac0c 100755
--- a/model/jpa/src/main/resources/META-INF/jpa-changelog-master.xml
+++ b/model/jpa/src/main/resources/META-INF/jpa-changelog-master.xml
@@ -62,4 +62,5 @@
     <include file="META-INF/jpa-changelog-4.6.0.xml"/>
     <include file="META-INF/jpa-changelog-4.7.0.xml"/>
     <include file="META-INF/jpa-changelog-4.8.0.xml"/>
+    <include file="META-INF/jpa-changelog-7.0.0.xml"/>
 </databaseChangeLog>
diff --git a/model/jpa/src/main/resources/META-INF/persistence.xml b/model/jpa/src/main/resources/META-INF/persistence.xml
index 1649fa1363..e671cdab73 100755
--- a/model/jpa/src/main/resources/META-INF/persistence.xml
+++ b/model/jpa/src/main/resources/META-INF/persistence.xml
@@ -23,7 +23,6 @@
         <class>org.keycloak.models.jpa.entities.ClientEntity</class>
         <class>org.keycloak.models.jpa.entities.ClientAttributeEntity</class>
         <class>org.keycloak.models.jpa.entities.CredentialEntity</class>
-        <class>org.keycloak.models.jpa.entities.CredentialAttributeEntity</class>
         <class>org.keycloak.models.jpa.entities.RealmEntity</class>
         <class>org.keycloak.models.jpa.entities.RealmAttributeEntity</class>
         <class>org.keycloak.models.jpa.entities.RequiredCredentialEntity</class>
@@ -80,7 +79,6 @@
         <class>org.keycloak.storage.jpa.entity.FederatedUserConsentEntity</class>
         <class>org.keycloak.storage.jpa.entity.FederatedUserConsentClientScopeEntity</class>
         <class>org.keycloak.storage.jpa.entity.FederatedUserCredentialEntity</class>
-        <class>org.keycloak.storage.jpa.entity.FederatedUserCredentialAttributeEntity</class>
         <class>org.keycloak.storage.jpa.entity.FederatedUserGroupMembershipEntity</class>
         <class>org.keycloak.storage.jpa.entity.FederatedUserRequiredActionEntity</class>
         <class>org.keycloak.storage.jpa.entity.FederatedUserRoleMappingEntity</class>
diff --git a/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationFlow.java b/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationFlow.java
index 576f5ff31d..5d1cc70a7f 100755
--- a/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationFlow.java
+++ b/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationFlow.java
@@ -30,4 +30,5 @@ public interface AuthenticationFlow {
 
     Response processAction(String actionExecution);
     Response processFlow();
+    boolean isSuccessful();
 }
diff --git a/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationFlowContext.java b/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationFlowContext.java
index f9b49c3ac3..9e184d31c3 100755
--- a/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationFlowContext.java
+++ b/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationFlowContext.java
@@ -17,13 +17,17 @@
 
 package org.keycloak.authentication;
 
+import org.keycloak.credential.CredentialModel;
 import org.keycloak.forms.login.LoginFormsProvider;
+import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.UserModel;
 import org.keycloak.models.UserSessionModel;
 import org.keycloak.models.utils.FormMessage;
 import org.keycloak.sessions.AuthenticationSessionModel;
 
 import java.net.URI;
+import java.util.List;
+import java.util.Map;
 
 /**
  * This interface encapsulates information about an execution in an AuthenticationFlow.  It is also used to set
@@ -49,6 +53,23 @@ public interface AuthenticationFlowContext extends AbstractAuthenticationFlowCon
      */
     void setUser(UserModel user);
 
+    /**
+     * Gets the credential currently selected in this flow
+     *
+     * @return
+     */
+    String getSelectedCredentialId();
+
+    /**
+     * Sets a selected credential for this flow
+     * @param credentialModel
+     */
+    void setSelectedCredentialId(String credentialModel);
+
+    List<AuthenticationSelectionOption> getAuthenticationSelections();
+
+    void setAuthenticationSelections(List<AuthenticationSelectionOption>  credentialAuthExecMap);
+
     /**
      * Clear the user from the flow.
      */
diff --git a/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationSelectionOption.java b/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationSelectionOption.java
new file mode 100644
index 0000000000..a9eb069241
--- /dev/null
+++ b/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticationSelectionOption.java
@@ -0,0 +1,94 @@
+package org.keycloak.authentication;
+
+import org.keycloak.credential.CredentialModel;
+import org.keycloak.models.AuthenticationExecutionModel;
+import org.keycloak.models.AuthenticationFlowModel;
+
+public class AuthenticationSelectionOption {
+    private final AuthenticationExecutionModel authExec;
+    private final CredentialModel credential;
+    private final AuthenticationFlowModel authFlow;
+    private boolean showCredentialName = true;
+    private boolean showCredentialType = true;
+
+    public AuthenticationSelectionOption(AuthenticationExecutionModel authExec) {
+        this.authExec = authExec;
+        this.credential = new CredentialModel();
+        this.authFlow = null;
+    }
+
+    public AuthenticationSelectionOption(AuthenticationExecutionModel authExec, CredentialModel credential) {
+        this.authExec = authExec;
+        this.credential = credential;
+        this.authFlow = null;
+    }
+
+    public AuthenticationSelectionOption(AuthenticationExecutionModel authExec, AuthenticationFlowModel authFlow) {
+        this.authExec = authExec;
+        this.credential = new CredentialModel();
+        this.authFlow = authFlow;
+    }
+
+    public void setShowCredentialName(boolean showCredentialName) {
+        this.showCredentialName = showCredentialName;
+    }
+    public void setShowCredentialType(boolean showCredentialType) {
+        this.showCredentialType = showCredentialType;
+    }
+
+    public boolean showCredentialName(){
+        if (credential.getId() == null) {
+            return false;
+        }
+        return showCredentialName;
+    }
+
+    public boolean showCredentialType(){
+        return showCredentialType;
+    }
+
+    public AuthenticationExecutionModel getAuthenticationExecution() {
+        return authExec;
+    }
+
+    public String getCredentialId(){
+        return credential.getId();
+    }
+
+    public String getAuthExecId(){
+        return authExec.getId();
+    }
+
+    public String getCredentialName() {
+        StringBuilder sb = new StringBuilder();
+        if (showCredentialName()) {
+            if (showCredentialType()) {
+                sb.append(" - ");
+            }
+            if (credential.getUserLabel() == null || credential.getUserLabel().isEmpty()) {
+                sb.append(credential.getId());
+            } else {
+                sb.append(credential.getUserLabel());
+            }
+        }
+        return sb.toString();
+    }
+
+    public String getAuthExecName() {
+        if (authFlow != null) {
+            String authFlowLabel = authFlow.getAlias();
+            if (authFlowLabel == null || authFlowLabel.isEmpty()) {
+                authFlowLabel = authFlow.getId();
+            }
+            return authFlowLabel;
+        }
+        return authExec.getAuthenticator();
+    }
+
+    public String getId() {
+        if (getCredentialId() == null) {
+            return getAuthExecId() + "|";
+        }
+        return getAuthExecId() + "|" + getCredentialId();
+    }
+}
diff --git a/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticatorFactory.java b/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticatorFactory.java
index c3d9ba9c1c..4044390582 100755
--- a/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticatorFactory.java
+++ b/server-spi-private/src/main/java/org/keycloak/authentication/AuthenticatorFactory.java
@@ -30,4 +30,5 @@ import org.keycloak.provider.ProviderFactory;
 * @version $Revision: 1 $
 */
 public interface AuthenticatorFactory extends ProviderFactory<Authenticator>, ConfigurableAuthenticatorFactory {
+
 }
diff --git a/server-spi-private/src/main/java/org/keycloak/authentication/ConfigurableAuthenticatorFactory.java b/server-spi-private/src/main/java/org/keycloak/authentication/ConfigurableAuthenticatorFactory.java
index 5c70a91abe..6a7306ad7a 100755
--- a/server-spi-private/src/main/java/org/keycloak/authentication/ConfigurableAuthenticatorFactory.java
+++ b/server-spi-private/src/main/java/org/keycloak/authentication/ConfigurableAuthenticatorFactory.java
@@ -25,6 +25,12 @@ import org.keycloak.provider.ConfiguredProvider;
  * @version $Revision: 1 $
  */
 public interface ConfigurableAuthenticatorFactory extends ConfiguredProvider {
+
+    AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
+            AuthenticationExecutionModel.Requirement.REQUIRED,
+            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
+            AuthenticationExecutionModel.Requirement.DISABLED};
+
     /**
      * Friendly name for the authenticator
      *
diff --git a/server-spi-private/src/main/java/org/keycloak/authentication/CredentialRegistrator.java b/server-spi-private/src/main/java/org/keycloak/authentication/CredentialRegistrator.java
new file mode 100644
index 0000000000..2ee627aa8d
--- /dev/null
+++ b/server-spi-private/src/main/java/org/keycloak/authentication/CredentialRegistrator.java
@@ -0,0 +1,4 @@
+package org.keycloak.authentication;
+
+public interface CredentialRegistrator {
+}
diff --git a/server-spi-private/src/main/java/org/keycloak/authentication/CredentialValidator.java b/server-spi-private/src/main/java/org/keycloak/authentication/CredentialValidator.java
new file mode 100644
index 0000000000..82cd7dc528
--- /dev/null
+++ b/server-spi-private/src/main/java/org/keycloak/authentication/CredentialValidator.java
@@ -0,0 +1,19 @@
+package org.keycloak.authentication;
+
+import org.keycloak.credential.CredentialModel;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.RealmModel;
+import org.keycloak.models.UserModel;
+
+import java.util.List;
+
+public interface CredentialValidator<T extends CredentialProvider> {
+    T getCredentialProvider(KeycloakSession session);
+    default List<CredentialModel> getCredentials(KeycloakSession session, RealmModel realm, UserModel user) {
+        return session.userCredentialManager().getStoredCredentialsByType(realm, user, getCredentialProvider(session).getType());
+    }
+    default String getType(KeycloakSession session) {
+        return getCredentialProvider(session).getType();
+    }
+}
diff --git a/server-spi-private/src/main/java/org/keycloak/credential/hash/Pbkdf2PasswordHashProvider.java b/server-spi-private/src/main/java/org/keycloak/credential/hash/Pbkdf2PasswordHashProvider.java
index 9c146f0908..522e671215 100644
--- a/server-spi-private/src/main/java/org/keycloak/credential/hash/Pbkdf2PasswordHashProvider.java
+++ b/server-spi-private/src/main/java/org/keycloak/credential/hash/Pbkdf2PasswordHashProvider.java
@@ -18,9 +18,8 @@
 package org.keycloak.credential.hash;
 
 import org.keycloak.common.util.Base64;
-import org.keycloak.credential.CredentialModel;
 import org.keycloak.models.PasswordPolicy;
-import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 
 import javax.crypto.SecretKeyFactory;
 import javax.crypto.spec.PBEKeySpec;
@@ -53,31 +52,27 @@ public class Pbkdf2PasswordHashProvider implements PasswordHashProvider {
     }
 
     @Override
-    public boolean policyCheck(PasswordPolicy policy, CredentialModel credential) {
+    public boolean policyCheck(PasswordPolicy policy, PasswordCredentialModel credential) {
         int policyHashIterations = policy.getHashIterations();
         if (policyHashIterations == -1) {
             policyHashIterations = defaultIterations;
         }
 
-        return credential.getHashIterations() == policyHashIterations
-                && providerId.equals(credential.getAlgorithm())
+        return credential.getPasswordCredentialData().getHashIterations() == policyHashIterations
+                && providerId.equals(credential.getPasswordCredentialData().getAlgorithm())
                 && derivedKeySize == keySize(credential);
     }
 
     @Override
-    public void encode(String rawPassword, int iterations, CredentialModel credential) {
+    public PasswordCredentialModel encodedCredential(String rawPassword, int iterations) {
         if (iterations == -1) {
             iterations = defaultIterations;
         }
 
         byte[] salt = getSalt();
-        String encodedPassword = encode(rawPassword, iterations, salt, derivedKeySize);
+        String encodedPassword = encodedCredential(rawPassword, iterations, salt, derivedKeySize);
 
-        credential.setAlgorithm(providerId);
-        credential.setType(UserCredentialModel.PASSWORD);
-        credential.setSalt(salt);
-        credential.setHashIterations(iterations);
-        credential.setValue(encodedPassword);
+        return PasswordCredentialModel.createFromValues(providerId, salt, iterations, encodedPassword);
     }
 
     @Override
@@ -87,17 +82,17 @@ public class Pbkdf2PasswordHashProvider implements PasswordHashProvider {
         }
 
         byte[] salt = getSalt();
-        return encode(rawPassword, iterations, salt, derivedKeySize);
+        return encodedCredential(rawPassword, iterations, salt, derivedKeySize);
     }
 
     @Override
-    public boolean verify(String rawPassword, CredentialModel credential) {
-        return encode(rawPassword, credential.getHashIterations(), credential.getSalt(), keySize(credential)).equals(credential.getValue());
+    public boolean verify(String rawPassword, PasswordCredentialModel credential) {
+        return encodedCredential(rawPassword, credential.getPasswordCredentialData().getHashIterations(), credential.getPasswordSecretData().getSalt(), keySize(credential)).equals(credential.getPasswordSecretData().getValue());
     }
 
-    private int keySize(CredentialModel credential) {
+    private int keySize(PasswordCredentialModel credential) {
         try {
-            byte[] bytes = Base64.decode(credential.getValue());
+            byte[] bytes = Base64.decode(credential.getPasswordSecretData().getValue());
             return bytes.length * 8;
         } catch (IOException e) {
             throw new RuntimeException("Credential could not be decoded", e);
@@ -107,7 +102,7 @@ public class Pbkdf2PasswordHashProvider implements PasswordHashProvider {
     public void close() {
     }
 
-    private String encode(String rawPassword, int iterations, byte[] salt, int derivedKeySize) {
+    private String encodedCredential(String rawPassword, int iterations, byte[] salt, int derivedKeySize) {
         KeySpec spec = new PBEKeySpec(rawPassword.toCharArray(), salt, iterations, derivedKeySize);
 
         try {
diff --git a/server-spi-private/src/main/java/org/keycloak/forms/login/LoginFormsPages.java b/server-spi-private/src/main/java/org/keycloak/forms/login/LoginFormsPages.java
index b09340a4b1..fabf06c74d 100755
--- a/server-spi-private/src/main/java/org/keycloak/forms/login/LoginFormsPages.java
+++ b/server-spi-private/src/main/java/org/keycloak/forms/login/LoginFormsPages.java
@@ -22,7 +22,7 @@ package org.keycloak.forms.login;
  */
 public enum LoginFormsPages {
 
-    LOGIN, LOGIN_TOTP, LOGIN_CONFIG_TOTP, LOGIN_VERIFY_EMAIL,
+    LOGIN, LOGIN_USERNAME, LOGIN_PASSWORD, LOGIN_TOTP, LOGIN_CONFIG_TOTP, LOGIN_VERIFY_EMAIL,
     LOGIN_IDP_LINK_CONFIRM, LOGIN_IDP_LINK_EMAIL,
     OAUTH_GRANT, LOGIN_RESET_PASSWORD, LOGIN_UPDATE_PASSWORD, REGISTER, INFO, ERROR, LOGIN_UPDATE_PROFILE, 
     LOGIN_PAGE_EXPIRED, CODE, X509_CONFIRM;
diff --git a/server-spi-private/src/main/java/org/keycloak/forms/login/LoginFormsProvider.java b/server-spi-private/src/main/java/org/keycloak/forms/login/LoginFormsProvider.java
index 011946fbfe..08ed60733a 100755
--- a/server-spi-private/src/main/java/org/keycloak/forms/login/LoginFormsProvider.java
+++ b/server-spi-private/src/main/java/org/keycloak/forms/login/LoginFormsProvider.java
@@ -17,6 +17,7 @@
 
 package org.keycloak.forms.login;
 
+import org.keycloak.authentication.AuthenticationFlowContext;
 import org.keycloak.models.ClientScopeModel;
 import org.keycloak.models.ProtocolMapperModel;
 import org.keycloak.models.RoleModel;
@@ -57,7 +58,11 @@ public interface LoginFormsProvider extends Provider {
 
     String getMessage(String message, String... parameters);
 
-    Response createLogin();
+    Response createLoginUsernamePassword();
+
+    Response createLoginUsername();
+
+    Response createLoginPassword();
 
     Response createPasswordReset();
 
@@ -133,4 +138,6 @@ public interface LoginFormsProvider extends Provider {
     LoginFormsProvider setActionUri(URI requestUri);
 
     LoginFormsProvider setExecution(String execution);
+
+    LoginFormsProvider setAuthContext(AuthenticationFlowContext context);
 }
diff --git a/server-spi-private/src/main/java/org/keycloak/models/utils/CredentialValidation.java b/server-spi-private/src/main/java/org/keycloak/models/utils/CredentialValidation.java
index 598e3e9eda..58a48d8ded 100755
--- a/server-spi-private/src/main/java/org/keycloak/models/utils/CredentialValidation.java
+++ b/server-spi-private/src/main/java/org/keycloak/models/utils/CredentialValidation.java
@@ -17,9 +17,7 @@
 
 package org.keycloak.models.utils;
 
-import org.keycloak.models.OTPPolicy;
-import org.keycloak.models.RealmModel;
-import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
@@ -27,14 +25,17 @@ import org.keycloak.models.UserCredentialModel;
  */
 public class CredentialValidation {
 
-    public static boolean validOTP(RealmModel realm, String token, String secret) {
-        OTPPolicy policy = realm.getOTPPolicy();
-        if (policy.getType().equals(UserCredentialModel.TOTP)) {
-            TimeBasedOTP validator = new TimeBasedOTP(policy.getAlgorithm(), policy.getDigits(), policy.getPeriod(), policy.getLookAheadWindow());
-            return validator.validateTOTP(token, secret.getBytes());
+    public static boolean validOTP(String token, OTPCredentialModel credentialModel, int lookAheadWindow) {
+        if (credentialModel.getOTPCredentialData().getSubType().equals(OTPCredentialModel.TOTP)) {
+            TimeBasedOTP validator = new TimeBasedOTP(credentialModel.getOTPCredentialData().getAlgorithm(),
+                    credentialModel.getOTPCredentialData().getDigits(), credentialModel.getOTPCredentialData().getPeriod(),
+                    lookAheadWindow);
+            return validator.validateTOTP(token, credentialModel.getOTPSecretData().getValue().getBytes());
         } else {
-            HmacOTP validator = new HmacOTP(policy.getDigits(), policy.getAlgorithm(), policy.getLookAheadWindow());
-            int c = validator.validateHOTP(token, secret, policy.getInitialCounter());
+            HmacOTP validator = new HmacOTP(credentialModel.getOTPCredentialData().getDigits(),
+                    credentialModel.getOTPCredentialData().getAlgorithm(), lookAheadWindow);
+            int c = validator.validateHOTP(token, credentialModel.getOTPSecretData().getValue(),
+                    credentialModel.getOTPCredentialData().getCounter());
             return c > -1;
         }
 
diff --git a/server-spi-private/src/main/java/org/keycloak/models/utils/DefaultAuthenticationFlows.java b/server-spi-private/src/main/java/org/keycloak/models/utils/DefaultAuthenticationFlows.java
index fca1a71979..c67d7d088b 100755
--- a/server-spi-private/src/main/java/org/keycloak/models/utils/DefaultAuthenticationFlows.java
+++ b/server-spi-private/src/main/java/org/keycloak/models/utils/DefaultAuthenticationFlows.java
@@ -143,9 +143,6 @@ public class DefaultAuthenticationFlows {
         execution.setAuthenticatorFlow(false);
         //execution.setAuthenticatorConfig(captchaConfig.getId());
         realm.addAuthenticatorExecution(execution);
-
-
-
     }
 
     public static void browserFlow(RealmModel realm) {
@@ -163,18 +160,18 @@ public class DefaultAuthenticationFlows {
     }
 
     public static void resetCredentialsFlow(RealmModel realm) {
-        AuthenticationFlowModel grant = new AuthenticationFlowModel();
-        grant.setAlias(RESET_CREDENTIALS_FLOW);
-        grant.setDescription("Reset credentials for a user if they forgot their password or something");
-        grant.setProviderId("basic-flow");
-        grant.setTopLevel(true);
-        grant.setBuiltIn(true);
-        grant = realm.addAuthenticationFlow(grant);
-        realm.setResetCredentialsFlow(grant);
+        AuthenticationFlowModel reset = new AuthenticationFlowModel();
+        reset.setAlias(RESET_CREDENTIALS_FLOW);
+        reset.setDescription("Reset credentials for a user if they forgot their password or something");
+        reset.setProviderId("basic-flow");
+        reset.setTopLevel(true);
+        reset.setBuiltIn(true);
+        reset = realm.addAuthenticationFlow(reset);
+        realm.setResetCredentialsFlow(reset);
 
         // username
         AuthenticationExecutionModel execution = new AuthenticationExecutionModel();
-        execution.setParentFlow(grant.getId());
+        execution.setParentFlow(reset.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
         execution.setAuthenticator("reset-credentials-choose-user");
         execution.setPriority(10);
@@ -183,7 +180,7 @@ public class DefaultAuthenticationFlows {
 
         // send email
         execution = new AuthenticationExecutionModel();
-        execution.setParentFlow(grant.getId());
+        execution.setParentFlow(reset.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
         execution.setAuthenticator("reset-credential-email");
         execution.setPriority(20);
@@ -192,19 +189,41 @@ public class DefaultAuthenticationFlows {
 
         // password
         execution = new AuthenticationExecutionModel();
-        execution.setParentFlow(grant.getId());
+        execution.setParentFlow(reset.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
         execution.setAuthenticator("reset-password");
         execution.setPriority(30);
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
 
-        // otp
+        AuthenticationFlowModel conditionalOTP = new AuthenticationFlowModel();
+        conditionalOTP.setTopLevel(false);
+        conditionalOTP.setBuiltIn(true);
+        conditionalOTP.setAlias("Reset - Conditional OTP");
+        conditionalOTP.setDescription("Flow to determine if the OTP should be reset or not. Set to REQUIRED to force.");
+        conditionalOTP.setProviderId("basic-flow");
+        conditionalOTP = realm.addAuthenticationFlow(conditionalOTP);
         execution = new AuthenticationExecutionModel();
-        execution.setParentFlow(grant.getId());
+        execution.setParentFlow(reset.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.OPTIONAL);
-        execution.setAuthenticator("reset-otp");
+        execution.setFlowId(conditionalOTP.getId());
         execution.setPriority(40);
+        execution.setAuthenticatorFlow(true);
+        realm.addAuthenticatorExecution(execution);
+
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(conditionalOTP.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
+        execution.setAuthenticator("conditional-user-configured");
+        execution.setPriority(10);
+        execution.setAuthenticatorFlow(false);
+        realm.addAuthenticatorExecution(execution);
+
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(conditionalOTP.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
+        execution.setAuthenticator("reset-otp");
+        execution.setPriority(20);
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
     }
@@ -241,14 +260,37 @@ public class DefaultAuthenticationFlows {
         realm.addAuthenticatorExecution(execution);
 
         // otp
+        AuthenticationFlowModel conditionalOTP = new AuthenticationFlowModel();
+        conditionalOTP.setTopLevel(false);
+        conditionalOTP.setBuiltIn(true);
+        conditionalOTP.setAlias("Direct Grant - Conditional OTP");
+        conditionalOTP.setDescription("Flow to determine if the OTP is required for the authentication");
+        conditionalOTP.setProviderId("basic-flow");
+        conditionalOTP = realm.addAuthenticationFlow(conditionalOTP);
         execution = new AuthenticationExecutionModel();
         execution.setParentFlow(grant.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.OPTIONAL);
         if (migrate && hasCredentialType(realm, RequiredCredentialModel.TOTP.getType())) {
             execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
         }
-        execution.setAuthenticator("direct-grant-validate-otp");
+        execution.setFlowId(conditionalOTP.getId());
         execution.setPriority(30);
+        execution.setAuthenticatorFlow(true);
+        realm.addAuthenticatorExecution(execution);
+
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(conditionalOTP.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
+        execution.setAuthenticator("conditional-user-configured");
+        execution.setPriority(10);
+        execution.setAuthenticatorFlow(false);
+        realm.addAuthenticatorExecution(execution);
+
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(conditionalOTP.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
+        execution.setAuthenticator("direct-grant-validate-otp");
+        execution.setPriority(20);
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
     }
@@ -309,15 +351,36 @@ public class DefaultAuthenticationFlows {
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
 
-        // otp processing
+        AuthenticationFlowModel conditionalOTP = new AuthenticationFlowModel();
+        conditionalOTP.setTopLevel(false);
+        conditionalOTP.setBuiltIn(true);
+        conditionalOTP.setAlias("Browser - Conditional OTP");
+        conditionalOTP.setDescription("Flow to determine if the OTP is required for the authentication");
+        conditionalOTP.setProviderId("basic-flow");
+        conditionalOTP = realm.addAuthenticationFlow(conditionalOTP);
         execution = new AuthenticationExecutionModel();
         execution.setParentFlow(forms.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.OPTIONAL);
         if (migrate && hasCredentialType(realm, RequiredCredentialModel.TOTP.getType())) {
             execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
-
         }
+        execution.setFlowId(conditionalOTP.getId());
+        execution.setPriority(20);
+        execution.setAuthenticatorFlow(true);
+        realm.addAuthenticatorExecution(execution);
 
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(conditionalOTP.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
+        execution.setAuthenticator("conditional-user-configured");
+        execution.setPriority(10);
+        execution.setAuthenticatorFlow(false);
+        realm.addAuthenticatorExecution(execution);
+
+        // otp processing
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(conditionalOTP.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
         execution.setAuthenticator("auth-otp-form");
         execution.setPriority(20);
         execution.setAuthenticatorFlow(false);
@@ -432,6 +495,20 @@ public class DefaultAuthenticationFlows {
         execution.setAuthenticatorConfig(reviewProfileConfig.getId());
         realm.addAuthenticatorExecution(execution);
 
+        AuthenticationFlowModel uniqueOrExistingFlow = new AuthenticationFlowModel();
+        uniqueOrExistingFlow.setTopLevel(false);
+        uniqueOrExistingFlow.setBuiltIn(true);
+        uniqueOrExistingFlow.setAlias("User creation or linking");
+        uniqueOrExistingFlow.setDescription("Flow for the existing/non-existing user alternatives");
+        uniqueOrExistingFlow.setProviderId("basic-flow");
+        uniqueOrExistingFlow = realm.addAuthenticationFlow(uniqueOrExistingFlow);
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(firstBrokerLogin.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
+        execution.setFlowId(uniqueOrExistingFlow.getId());
+        execution.setPriority(20);
+        execution.setAuthenticatorFlow(true);
+        realm.addAuthenticatorExecution(execution);
 
         AuthenticatorConfigModel createUserIfUniqueConfig = new AuthenticatorConfigModel();
         createUserIfUniqueConfig.setAlias(IDP_CREATE_UNIQUE_USER_CONFIG_ALIAS);
@@ -441,10 +518,10 @@ public class DefaultAuthenticationFlows {
         createUserIfUniqueConfig = realm.addAuthenticatorConfig(createUserIfUniqueConfig);
 
         execution = new AuthenticationExecutionModel();
-        execution.setParentFlow(firstBrokerLogin.getId());
+        execution.setParentFlow(uniqueOrExistingFlow.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.ALTERNATIVE);
         execution.setAuthenticator("idp-create-user-if-unique");
-        execution.setPriority(20);
+        execution.setPriority(10);
         execution.setAuthenticatorFlow(false);
         execution.setAuthenticatorConfig(createUserIfUniqueConfig.getId());
         realm.addAuthenticatorExecution(execution);
@@ -458,10 +535,10 @@ public class DefaultAuthenticationFlows {
         linkExistingAccountFlow.setProviderId("basic-flow");
         linkExistingAccountFlow = realm.addAuthenticationFlow(linkExistingAccountFlow);
         execution = new AuthenticationExecutionModel();
-        execution.setParentFlow(firstBrokerLogin.getId());
+        execution.setParentFlow(uniqueOrExistingFlow.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.ALTERNATIVE);
         execution.setFlowId(linkExistingAccountFlow.getId());
-        execution.setPriority(30);
+        execution.setPriority(20);
         execution.setAuthenticatorFlow(true);
         realm.addAuthenticatorExecution(execution);
 
@@ -473,11 +550,26 @@ public class DefaultAuthenticationFlows {
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
 
+        AuthenticationFlowModel accountVerificationOptions = new AuthenticationFlowModel();
+        accountVerificationOptions.setTopLevel(false);
+        accountVerificationOptions.setBuiltIn(true);
+        accountVerificationOptions.setAlias("Account verification options");
+        accountVerificationOptions.setDescription("Method with which to verity the existing account");
+        accountVerificationOptions.setProviderId("basic-flow");
+        accountVerificationOptions = realm.addAuthenticationFlow(accountVerificationOptions);
         execution = new AuthenticationExecutionModel();
         execution.setParentFlow(linkExistingAccountFlow.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
+        execution.setFlowId(accountVerificationOptions.getId());
+        execution.setPriority(20);
+        execution.setAuthenticatorFlow(true);
+        realm.addAuthenticatorExecution(execution);
+
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(accountVerificationOptions.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.ALTERNATIVE);
         execution.setAuthenticator("idp-email-verification");
-        execution.setPriority(20);
+        execution.setPriority(10);
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
 
@@ -489,10 +581,10 @@ public class DefaultAuthenticationFlows {
         verifyByReauthenticationAccountFlow.setProviderId("basic-flow");
         verifyByReauthenticationAccountFlow = realm.addAuthenticationFlow(verifyByReauthenticationAccountFlow);
         execution = new AuthenticationExecutionModel();
-        execution.setParentFlow(linkExistingAccountFlow.getId());
+        execution.setParentFlow(accountVerificationOptions.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.ALTERNATIVE);
         execution.setFlowId(verifyByReauthenticationAccountFlow.getId());
-        execution.setPriority(30);
+        execution.setPriority(20);
         execution.setAuthenticatorFlow(true);
         realm.addAuthenticatorExecution(execution);
 
@@ -505,26 +597,48 @@ public class DefaultAuthenticationFlows {
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
 
+        AuthenticationFlowModel conditionalOTP = new AuthenticationFlowModel();
+        conditionalOTP.setTopLevel(false);
+        conditionalOTP.setBuiltIn(true);
+        conditionalOTP.setAlias("First broker login - Conditional OTP");
+        conditionalOTP.setDescription("Flow to determine if the OTP is required for the authentication");
+        conditionalOTP.setProviderId("basic-flow");
+        conditionalOTP = realm.addAuthenticationFlow(conditionalOTP);
         execution = new AuthenticationExecutionModel();
         execution.setParentFlow(verifyByReauthenticationAccountFlow.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.OPTIONAL);
-
         if (migrate) {
             // Try to read OTP requirement from browser flow
             AuthenticationFlowModel browserFlow = realm.getBrowserFlow();
             if (browserFlow == null) {
                 browserFlow = realm.getFlowByAlias(DefaultAuthenticationFlows.BROWSER_FLOW);
             }
-
             List<AuthenticationExecutionModel> browserExecutions = new LinkedList<>();
             KeycloakModelUtils.deepFindAuthenticationExecutions(realm, browserFlow, browserExecutions);
             for (AuthenticationExecutionModel browserExecution : browserExecutions) {
-                if (browserExecution.getAuthenticator().equals("auth-otp-form")) {
-                    execution.setRequirement(browserExecution.getRequirement());
+                if (browserExecution.isAuthenticatorFlow()){
+                    if (realm.getAuthenticationExecutions(browserExecution.getFlowId()).stream().anyMatch(e -> e.getAuthenticator().equals("auth-otp-form"))){
+                        execution.setRequirement(browserExecution.getRequirement());
+                    }
                 }
             }
         }
+        execution.setFlowId(conditionalOTP.getId());
+        execution.setPriority(20);
+        execution.setAuthenticatorFlow(true);
+        realm.addAuthenticatorExecution(execution);
 
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(conditionalOTP.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
+        execution.setAuthenticator("conditional-user-configured");
+        execution.setPriority(10);
+        execution.setAuthenticatorFlow(false);
+        realm.addAuthenticatorExecution(execution);
+
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(conditionalOTP.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
         execution.setAuthenticator("auth-otp-form");
         execution.setPriority(20);
         execution.setAuthenticatorFlow(false);
@@ -591,27 +705,42 @@ public class DefaultAuthenticationFlows {
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
 
+        AuthenticationFlowModel authType = new AuthenticationFlowModel();
+        authType.setTopLevel(false);
+        authType.setBuiltIn(true);
+        authType.setAlias("Authentication Options");
+        authType.setDescription("Authentication options.");
+        authType.setProviderId("basic-flow");
+        authType = realm.addAuthenticationFlow(authType);
         execution = new AuthenticationExecutionModel();
         execution.setParentFlow(challengeFlow.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
-        execution.setAuthenticator("basic-auth");
+        execution.setFlowId(authType.getId());
         execution.setPriority(20);
+        execution.setAuthenticatorFlow(true);
+        realm.addAuthenticatorExecution(execution);
+
+        execution = new AuthenticationExecutionModel();
+        execution.setParentFlow(authType.getId());
+        execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
+        execution.setAuthenticator("basic-auth");
+        execution.setPriority(10);
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
 
         execution = new AuthenticationExecutionModel();
-        execution.setParentFlow(challengeFlow.getId());
+        execution.setParentFlow(authType.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.DISABLED);
         execution.setAuthenticator("basic-auth-otp");
-        execution.setPriority(30);
+        execution.setPriority(20);
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
 
         execution = new AuthenticationExecutionModel();
-        execution.setParentFlow(challengeFlow.getId());
+        execution.setParentFlow(authType.getId());
         execution.setRequirement(AuthenticationExecutionModel.Requirement.DISABLED);
         execution.setAuthenticator("auth-spnego");
-        execution.setPriority(40);
+        execution.setPriority(30);
         execution.setAuthenticatorFlow(false);
         realm.addAuthenticatorExecution(execution);
     }
diff --git a/server-spi-private/src/main/java/org/keycloak/models/utils/KeycloakModelUtils.java b/server-spi-private/src/main/java/org/keycloak/models/utils/KeycloakModelUtils.java
index d62e262554..2f994df651 100755
--- a/server-spi-private/src/main/java/org/keycloak/models/utils/KeycloakModelUtils.java
+++ b/server-spi-private/src/main/java/org/keycloak/models/utils/KeycloakModelUtils.java
@@ -147,7 +147,7 @@ public final class KeycloakModelUtils {
 
     public static UserCredentialModel generateSecret(ClientModel client) {
         UserCredentialModel secret = UserCredentialModel.generateSecret();
-        client.setSecret(secret.getValue());
+        client.setSecret(secret.getChallengeResponse());
         return secret;
     }
 
diff --git a/server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java b/server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java
index 8294f3775d..0e2a7f54ed 100755
--- a/server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java
+++ b/server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java
@@ -32,6 +32,7 @@ import org.keycloak.events.Event;
 import org.keycloak.events.admin.AdminEvent;
 import org.keycloak.events.admin.AuthDetails;
 import org.keycloak.models.*;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
 import org.keycloak.representations.idm.*;
 import org.keycloak.representations.idm.authorization.*;
@@ -168,7 +169,7 @@ public class ModelToRepresentation {
         rep.setEmail(user.getEmail());
         rep.setEnabled(user.isEnabled());
         rep.setEmailVerified(user.isEmailVerified());
-        rep.setTotp(session.userCredentialManager().isConfiguredFor(realm, user, CredentialModel.OTP));
+        rep.setTotp(session.userCredentialManager().isConfiguredFor(realm, user, OTPCredentialModel.TYPE));
         rep.setDisableableCredentialTypes(session.userCredentialManager().getDisableableCredentialTypes(realm, user));
         rep.setFederationLink(user.getFederationLink());
 
@@ -185,6 +186,7 @@ public class ModelToRepresentation {
             attrs.putAll(user.getAttributes());
             rep.setAttributes(attrs);
         }
+
         return rep;
     }
 
@@ -478,7 +480,18 @@ public class ModelToRepresentation {
     public static CredentialRepresentation toRepresentation(UserCredentialModel cred) {
         CredentialRepresentation rep = new CredentialRepresentation();
         rep.setType(CredentialRepresentation.SECRET);
-        rep.setValue(cred.getValue());
+        rep.setValue(cred.getChallengeResponse());
+        return rep;
+    }
+
+    public static CredentialRepresentation toRepresentation(CredentialModel cred) {
+        CredentialRepresentation rep = new CredentialRepresentation();
+        rep.setId(cred.getId());
+        rep.setType(cred.getType());
+        rep.setUserLabel(cred.getUserLabel());
+        rep.setCreatedDate(cred.getCreatedDate());
+        rep.setSecretData(cred.getSecretData());
+        rep.setCredentialData(cred.getCredentialData());
         return rep;
     }
 
diff --git a/server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java b/server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java
index 0d44b94edb..db531d448c 100755
--- a/server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java
+++ b/server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java
@@ -47,13 +47,13 @@ import org.keycloak.authorization.store.ResourceServerStore;
 import org.keycloak.authorization.store.ResourceStore;
 import org.keycloak.authorization.store.ScopeStore;
 import org.keycloak.authorization.store.StoreFactory;
-import org.keycloak.common.Profile;
 import org.keycloak.common.enums.SslRequired;
-import org.keycloak.common.util.Base64;
 import org.keycloak.common.util.MultivaluedHashMap;
+import org.keycloak.common.util.Time;
 import org.keycloak.common.util.UriUtils;
 import org.keycloak.component.ComponentModel;
 import org.keycloak.credential.CredentialModel;
+import org.keycloak.credential.hash.PasswordHashProvider;
 import org.keycloak.keys.KeyProvider;
 import org.keycloak.migration.MigrationProvider;
 import org.keycloak.migration.migrators.MigrationUtils;
@@ -80,11 +80,12 @@ import org.keycloak.models.RequiredActionProviderModel;
 import org.keycloak.models.RoleModel;
 import org.keycloak.models.ScopeContainerModel;
 import org.keycloak.models.UserConsentModel;
-import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
 import org.keycloak.models.UserProvider;
-import org.keycloak.models.credential.PasswordUserCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
+import org.keycloak.policy.PasswordPolicyManagerProvider;
 import org.keycloak.policy.PasswordPolicyNotMetException;
+import org.keycloak.policy.PolicyError;
 import org.keycloak.provider.ProviderConfigProperty;
 import org.keycloak.representations.idm.ApplicationRepresentation;
 import org.keycloak.representations.idm.AuthenticationExecutionExportRepresentation;
@@ -1619,102 +1620,47 @@ public class RepresentationToModel {
     public static void createCredentials(UserRepresentation userRep, KeycloakSession session, RealmModel realm, UserModel user, boolean adminRequest) {
         if (userRep.getCredentials() != null) {
             for (CredentialRepresentation cred : userRep.getCredentials()) {
-                updateCredential(session, realm, user, cred, adminRequest);
-            }
-        }
-    }
-
-    // Detect if it is "plain-text" or "hashed" representation and update model according to it
-    private static void updateCredential(KeycloakSession session, RealmModel realm, UserModel user, CredentialRepresentation cred, boolean adminRequest) {
-        if (cred.getValue() != null) {
-            PasswordUserCredentialModel plainTextCred = convertCredential(cred);
-            plainTextCred.setAdminRequest(adminRequest);
-            
-            //if called from import we need to change realm in context to load password policies from the newly created realm
-            RealmModel origRealm = session.getContext().getRealm();
-            try {
-                session.getContext().setRealm(realm);
-                session.userCredentialManager().updateCredential(realm, user, plainTextCred);
-            } catch (ModelException ex) {
-                throw new PasswordPolicyNotMetException(ex.getMessage(), user.getUsername(), ex);
-            } finally {
-                session.getContext().setRealm(origRealm);
-            }
-        } else {
-            CredentialModel hashedCred = new CredentialModel();
-            hashedCred.setType(cred.getType());
-            hashedCred.setDevice(cred.getDevice());
-            if (cred.getHashIterations() != null) hashedCred.setHashIterations(cred.getHashIterations());
-            try {
-                if (cred.getSalt() != null) hashedCred.setSalt(Base64.decode(cred.getSalt()));
-            } catch (IOException ioe) {
-                throw new RuntimeException(ioe);
-            }
-            hashedCred.setValue(cred.getHashedSaltedValue());
-            if (cred.getCounter() != null) hashedCred.setCounter(cred.getCounter());
-            if (cred.getDigits() != null) hashedCred.setDigits(cred.getDigits());
-
-            if (cred.getAlgorithm() != null) {
-
-                // Could happen when migrating from some early version
-                if ((UserCredentialModel.PASSWORD.equals(cred.getType()) || UserCredentialModel.PASSWORD_HISTORY.equals(cred.getType())) &&
-                        (cred.getAlgorithm().equals(HmacOTP.HMAC_SHA1))) {
-                    hashedCred.setAlgorithm("pbkdf2");
-                } else {
-                    hashedCred.setAlgorithm(cred.getAlgorithm());
+                if (cred.getId() != null && session.userCredentialManager().getStoredCredentialById(realm, user, cred.getId()) != null) {
+                    continue;
                 }
-
-            } else {
-                if (UserCredentialModel.PASSWORD.equals(cred.getType()) || UserCredentialModel.PASSWORD_HISTORY.equals(cred.getType())) {
-                    hashedCred.setAlgorithm("pbkdf2");
-                } else if (UserCredentialModel.isOtp(cred.getType())) {
-                    hashedCred.setAlgorithm(HmacOTP.HMAC_SHA1);
+                if (cred.getValue() != null && !cred.getValue().isEmpty()) {
+                    PasswordPolicy policy = realm.getPasswordPolicy();
+                    RealmModel origRealm = session.getContext().getRealm();
+                    try {
+                        session.getContext().setRealm(realm);
+                        PolicyError error = session.getProvider(PasswordPolicyManagerProvider.class).validate(realm, user, cred.getValue());
+                        if (error != null) throw new ModelException(error.getMessage(), error.getParameters());
+
+                        PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, policy.getHashAlgorithm());
+                        if (hash == null) {
+                            logger.warnv("Realm PasswordPolicy PasswordHashProvider {0} not found", policy.getHashAlgorithm());
+                            throw new ModelException(String.format("Realm PasswordPolicy PasswordHashProvider %1$s not found",
+                                    policy.getHashAlgorithm()));
+                        }
+                        PasswordCredentialModel credentialModel = hash.encodedCredential(cred.getValue(), policy.getHashIterations());
+                        credentialModel.setCreatedDate(Time.currentTimeMillis());
+                        session.userCredentialManager().createCredential(realm, user, credentialModel);
+                    } catch (ModelException ex) {
+                        throw new PasswordPolicyNotMetException(ex.getMessage(), user.getUsername(), ex);
+                    } finally {
+                        session.getContext().setRealm(origRealm);
+                    }
+                } else {
+                    session.userCredentialManager().createCredential(realm, user, toModel(cred));
                 }
             }
-
-            if (cred.getPeriod() != null) hashedCred.setPeriod(cred.getPeriod());
-            if (cred.getDigits() == null && UserCredentialModel.isOtp(cred.getType())) {
-                hashedCred.setDigits(6);
-            }
-            if (cred.getPeriod() == null && UserCredentialModel.TOTP.equals(cred.getType())) {
-                hashedCred.setPeriod(30);
-            }
-            hashedCred.setCreatedDate(cred.getCreatedDate());
-            session.userCredentialManager().createCredential(realm, user, hashedCred);
         }
     }
 
-    public static PasswordUserCredentialModel convertCredential(CredentialRepresentation cred) {
-        PasswordUserCredentialModel credential = new PasswordUserCredentialModel();
-        credential.setType(cred.getType());
-        credential.setValue(cred.getValue());
-        return credential;
-    }
-
     public static CredentialModel toModel(CredentialRepresentation cred) {
         CredentialModel model = new CredentialModel();
-        model.setHashIterations(cred.getHashIterations());
         model.setCreatedDate(cred.getCreatedDate());
         model.setType(cred.getType());
-        model.setDigits(cred.getDigits());
-        model.setConfig(cred.getConfig());
-        model.setDevice(cred.getDevice());
-        model.setAlgorithm(cred.getAlgorithm());
-        model.setCounter(cred.getCounter());
-        model.setPeriod(cred.getPeriod());
-        if (cred.getSalt() != null) {
-            try {
-                model.setSalt(Base64.decode(cred.getSalt()));
-            } catch (IOException e) {
-                throw new RuntimeException(e);
-            }
-        }
-        model.setValue(cred.getValue());
-        if (cred.getHashedSaltedValue() != null) {
-            model.setValue(cred.getHashedSaltedValue());
-        }
+        model.setUserLabel(cred.getUserLabel());
+        model.setSecretData(cred.getSecretData());
+        model.setCredentialData(cred.getCredentialData());
+        model.setId(cred.getId());
         return model;
-
     }
 
     // Role mappings
diff --git a/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java b/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java
index fe7c9df9c3..9080ab326f 100644
--- a/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java
+++ b/server-spi-private/src/main/java/org/keycloak/policy/HistoryPasswordPolicyProvider.java
@@ -24,7 +24,9 @@ import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.PasswordPolicy;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 
+import java.io.IOException;
 import java.util.List;
 
 /**
@@ -51,18 +53,20 @@ public class HistoryPasswordPolicyProvider implements PasswordPolicyProvider {
         PasswordPolicy policy = session.getContext().getRealm().getPasswordPolicy();
         int passwordHistoryPolicyValue = policy.getPolicyConfig(PasswordPolicy.PASSWORD_HISTORY_ID);
         if (passwordHistoryPolicyValue != -1) {
-            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, CredentialModel.PASSWORD);
+            List<CredentialModel> storedPasswords = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.TYPE);
             for (CredentialModel cred : storedPasswords) {
-                PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, cred.getAlgorithm());
+                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);
+                PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());
                 if (hash == null) continue;
-                if (hash.verify(password, cred)) {
+                if (hash.verify(password, passwordCredential)) {
                     return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);
                 }
             }
-            List<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByType(realm, user, CredentialModel.PASSWORD_HISTORY);
+            List<CredentialModel> passwordHistory = session.userCredentialManager().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);
             for (CredentialModel cred : passwordHistory) {
-                PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, cred.getAlgorithm());
-                if (hash.verify(password, cred)) {
+                PasswordCredentialModel passwordCredential = PasswordCredentialModel.createFromCredentialModel(cred);
+                PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, passwordCredential.getPasswordCredentialData().getAlgorithm());
+                if (hash.verify(password, passwordCredential)) {
                     return new PolicyError(ERROR_MESSAGE, passwordHistoryPolicyValue);
                 }
 
diff --git a/server-spi/src/main/java/org/keycloak/credential/CredentialInput.java b/server-spi/src/main/java/org/keycloak/credential/CredentialInput.java
index f9838b4e9b..a579ba54aa 100644
--- a/server-spi/src/main/java/org/keycloak/credential/CredentialInput.java
+++ b/server-spi/src/main/java/org/keycloak/credential/CredentialInput.java
@@ -23,5 +23,7 @@ package org.keycloak.credential;
  * @version $Revision: 1 $
  */
 public interface CredentialInput {
+    String getCredentialId();
     String getType();
+    String getChallengeResponse();
 }
diff --git a/server-spi/src/main/java/org/keycloak/credential/CredentialInputValidator.java b/server-spi/src/main/java/org/keycloak/credential/CredentialInputValidator.java
index 33c823053e..c59ed79344 100644
--- a/server-spi/src/main/java/org/keycloak/credential/CredentialInputValidator.java
+++ b/server-spi/src/main/java/org/keycloak/credential/CredentialInputValidator.java
@@ -32,6 +32,13 @@ import java.util.List;
 public interface CredentialInputValidator {
     boolean supportsCredentialType(String credentialType);
     boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType);
-    boolean isValid(RealmModel realm, UserModel user, CredentialInput input);
 
+    /**
+     * Tests whether a credential is valid
+     * @param realm The realm in which to which the credential belongs to
+     * @param user The user for which to test the credential
+     * @param credentialInput the credential details to verify
+     * @return true if the passed secret is correct
+     */
+    boolean isValid(RealmModel realm, UserModel user, CredentialInput credentialInput);
 }
diff --git a/server-spi/src/main/java/org/keycloak/credential/CredentialModel.java b/server-spi/src/main/java/org/keycloak/credential/CredentialModel.java
index f466183508..8798a017b6 100755
--- a/server-spi/src/main/java/org/keycloak/credential/CredentialModel.java
+++ b/server-spi/src/main/java/org/keycloak/credential/CredentialModel.java
@@ -17,8 +17,6 @@
 
 package org.keycloak.credential;
 
-import org.keycloak.common.util.MultivaluedHashMap;
-
 import java.io.Serializable;
 
 /**
@@ -27,56 +25,29 @@ import java.io.Serializable;
  * @author <a href="mailto:mposolda@redhat.com">Marek Posolda</a>
  */
 public class CredentialModel implements Serializable {
-    public static final String PASSWORD = "password";
-    public static final String PASSWORD_HISTORY = "password-history";
-    public static final String PASSWORD_TOKEN = "password-token";
-
-    // Secret is same as password but it is not hashed
-    public static final String SECRET = "secret";
-    public static final String TOTP = "totp";
-    public static final String HOTP = "hotp";
-    public static final String CLIENT_CERT = "cert";
-    public static final String KERBEROS = "kerberos";
-    public static final String OTP = "otp";
-
-
 
     private String id;
     private String type;
-    private String value;
-    private String device;
-    private byte[] salt;
-    private int hashIterations;
+    private String userLabel;
     private Long createdDate;
 
-    // otp stuff
-    private int counter;
-    private String algorithm;
-    private int digits;
-    private int period;
-    private MultivaluedHashMap<String, String> config;
+    private String secretData;
+    private String credentialData;
 
     public CredentialModel shallowClone() {
         CredentialModel res = new CredentialModel();
         res.id = id;
         res.type = type;
-        res.value = value;
-        res.device = device;
-        res.salt = salt;
-        res.hashIterations = hashIterations;
+        res.userLabel = userLabel;
         res.createdDate = createdDate;
-        res.counter = counter;
-        res.algorithm = algorithm;
-        res.digits = digits;
-        res.period = period;
-        res.config = config;
+        res.secretData = secretData;
+        res.credentialData = credentialData;
         return res;
     }
 
     public String getId() {
         return id;
     }
-
     public void setId(String id) {
         this.id = id;
     }
@@ -84,88 +55,35 @@ public class CredentialModel implements Serializable {
     public String getType() {
         return type;
     }
-
     public void setType(String type) {
         this.type = type;
     }
 
-    public String getValue() {
-        return value;
-    }
-
-    public void setValue(String value) {
-        this.value = value;
-    }
-
-    public String getDevice() {
-        return device;
-    }
-
-    public void setDevice(String device) {
-        this.device = device;
-    }
-
-    public byte[] getSalt() {
-        return salt;
-    }
-
-    public void setSalt(byte[] salt) {
-        this.salt = salt;
-    }
-
-    public int getHashIterations() {
-        return hashIterations;
+    public String getUserLabel() {
+        return userLabel;
     }
-
-    public void setHashIterations(int iterations) {
-        this.hashIterations = iterations;
+    public void setUserLabel(String userLabel) {
+        this.userLabel = userLabel;
     }
 
     public Long getCreatedDate() {
         return createdDate;
     }
-
     public void setCreatedDate(Long createdDate) {
         this.createdDate = createdDate;
     }
 
-    public int getCounter() {
-        return counter;
+    public String getSecretData() {
+        return secretData;
     }
-
-    public void setCounter(int counter) {
-        this.counter = counter;
+    public void setSecretData(String secretData) {
+        this.secretData = secretData;
     }
 
-    public String getAlgorithm() {
-        return algorithm;
+    public String getCredentialData() {
+        return credentialData;
     }
-
-    public void setAlgorithm(String algorithm) {
-        this.algorithm = algorithm;
-    }
-
-    public int getDigits() {
-        return digits;
-    }
-
-    public void setDigits(int digits) {
-        this.digits = digits;
-    }
-
-    public int getPeriod() {
-        return period;
-    }
-
-    public void setPeriod(int period) {
-        this.period = period;
-    }
-
-    public MultivaluedHashMap<String, String> getConfig() {
-        return config;
-    }
-
-    public void setConfig(MultivaluedHashMap<String, String> config) {
-        this.config = config;
+    public void setCredentialData(String credentialData) {
+        this.credentialData = credentialData;
     }
 }
diff --git a/server-spi/src/main/java/org/keycloak/credential/CredentialProvider.java b/server-spi/src/main/java/org/keycloak/credential/CredentialProvider.java
index a8304339c5..e3461cff68 100644
--- a/server-spi/src/main/java/org/keycloak/credential/CredentialProvider.java
+++ b/server-spi/src/main/java/org/keycloak/credential/CredentialProvider.java
@@ -16,16 +16,24 @@
  */
 package org.keycloak.credential;
 
+import org.keycloak.models.RealmModel;
+import org.keycloak.models.UserModel;
 import org.keycloak.provider.Provider;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public interface CredentialProvider extends Provider {
+public interface CredentialProvider<T extends CredentialModel> extends Provider {
+
     @Override
     default
     void close() {
 
     }
+
+    String getType();
+
+    CredentialModel createCredential(RealmModel realm, UserModel user, T credentialModel);
+    void deleteCredential(RealmModel realm, UserModel user, String credentialId);
 }
diff --git a/server-spi/src/main/java/org/keycloak/credential/UserCredentialStore.java b/server-spi/src/main/java/org/keycloak/credential/UserCredentialStore.java
index c99873911c..e5d82e2fa6 100644
--- a/server-spi/src/main/java/org/keycloak/credential/UserCredentialStore.java
+++ b/server-spi/src/main/java/org/keycloak/credential/UserCredentialStore.java
@@ -34,4 +34,8 @@ public interface UserCredentialStore extends Provider {
     List<CredentialModel> getStoredCredentials(RealmModel realm, UserModel user);
     List<CredentialModel> getStoredCredentialsByType(RealmModel realm, UserModel user, String type);
     CredentialModel getStoredCredentialByNameAndType(RealmModel realm, UserModel user, String name, String type);
+
+    //list operations
+    void moveCredentialTo(RealmModel realm, UserModel user, String id, String newPreviousCredentialId);
+
 }
diff --git a/server-spi/src/main/java/org/keycloak/credential/hash/PasswordHashProvider.java b/server-spi/src/main/java/org/keycloak/credential/hash/PasswordHashProvider.java
index 35a54b2f97..22cbf1a168 100644
--- a/server-spi/src/main/java/org/keycloak/credential/hash/PasswordHashProvider.java
+++ b/server-spi/src/main/java/org/keycloak/credential/hash/PasswordHashProvider.java
@@ -19,20 +19,21 @@ package org.keycloak.credential.hash;
 
 import org.keycloak.credential.CredentialModel;
 import org.keycloak.models.PasswordPolicy;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.provider.Provider;
 
 /**
  * @author <a href="mailto:me@tsudot.com">Kunal Kerkar</a>
  */
 public interface PasswordHashProvider extends Provider {
-    boolean policyCheck(PasswordPolicy policy, CredentialModel credential);
+    boolean policyCheck(PasswordPolicy policy, PasswordCredentialModel credential);
 
-    void encode(String rawPassword, int iterations, CredentialModel credential);
+    PasswordCredentialModel encodedCredential(String rawPassword, int iterations);
 
     default
     String encode(String rawPassword, int iterations) {
         return rawPassword;
     }
 
-    boolean verify(String rawPassword, CredentialModel credential);
+    boolean verify(String rawPassword, PasswordCredentialModel credential);
 }
diff --git a/server-spi/src/main/java/org/keycloak/models/OTPPolicy.java b/server-spi/src/main/java/org/keycloak/models/OTPPolicy.java
index ca5f986062..ac11fd6cee 100755
--- a/server-spi/src/main/java/org/keycloak/models/OTPPolicy.java
+++ b/server-spi/src/main/java/org/keycloak/models/OTPPolicy.java
@@ -18,6 +18,7 @@
 package org.keycloak.models;
 
 import org.jboss.logging.Logger;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.Base32;
 import org.keycloak.models.utils.HmacOTP;
 
@@ -66,7 +67,7 @@ public class OTPPolicy implements Serializable {
         this.period = period;
     }
 
-    public static OTPPolicy DEFAULT_POLICY = new OTPPolicy(UserCredentialModel.TOTP, HmacOTP.HMAC_SHA1, 0, 6, 1, 30);
+    public static OTPPolicy DEFAULT_POLICY = new OTPPolicy(OTPCredentialModel.TOTP, HmacOTP.HMAC_SHA1, 0, 6, 1, 30);
 
     public String getAlgorithmKey() {
         return algToKeyUriAlg.containsKey(algorithm) ? algToKeyUriAlg.get(algorithm) : algorithm;
@@ -148,9 +149,9 @@ public class OTPPolicy implements Serializable {
                                 + "&algorithm=" + algToKeyUriAlg.get(algorithm) //
                                 + "&issuer=" + issuerName;
 
-            if (type.equals(UserCredentialModel.HOTP)) {
+            if (type.equals(OTPCredentialModel.HOTP)) {
                 parameters += "&counter=" + initialCounter;
-            } else if (type.equals(UserCredentialModel.TOTP)) {
+            } else if (type.equals(OTPCredentialModel.TOTP)) {
                 parameters += "&period=" + period;
             }
 
diff --git a/server-spi/src/main/java/org/keycloak/models/RealmModel.java b/server-spi/src/main/java/org/keycloak/models/RealmModel.java
index 4a1261f819..2012b96eb7 100755
--- a/server-spi/src/main/java/org/keycloak/models/RealmModel.java
+++ b/server-spi/src/main/java/org/keycloak/models/RealmModel.java
@@ -295,6 +295,7 @@ public interface RealmModel extends RoleContainerModel {
 
     List<AuthenticationExecutionModel> getAuthenticationExecutions(String flowId);
     AuthenticationExecutionModel getAuthenticationExecutionById(String id);
+    AuthenticationExecutionModel getAuthenticationExecutionByFlowId(String flowId);
     AuthenticationExecutionModel addAuthenticatorExecution(AuthenticationExecutionModel model);
     void updateAuthenticatorExecution(AuthenticationExecutionModel model);
     void removeAuthenticatorExecution(AuthenticationExecutionModel model);
diff --git a/server-spi/src/main/java/org/keycloak/models/RequiredCredentialModel.java b/server-spi/src/main/java/org/keycloak/models/RequiredCredentialModel.java
index e0f4e6bdf9..d942412a92 100755
--- a/server-spi/src/main/java/org/keycloak/models/RequiredCredentialModel.java
+++ b/server-spi/src/main/java/org/keycloak/models/RequiredCredentialModel.java
@@ -17,6 +17,9 @@
 
 package org.keycloak.models;
 
+import org.keycloak.models.credential.OTPCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
+
 import java.io.Serializable;
 import java.util.Collections;
 import java.util.HashMap;
@@ -78,7 +81,7 @@ public class RequiredCredentialModel implements Serializable {
     static {
         Map<String, RequiredCredentialModel> map = new HashMap<String, RequiredCredentialModel>();
         PASSWORD = new RequiredCredentialModel();
-        PASSWORD.setType(UserCredentialModel.PASSWORD);
+        PASSWORD.setType(PasswordCredentialModel.TYPE);
         PASSWORD.setInput(true);
         PASSWORD.setSecret(true);
         PASSWORD.setFormLabel("password");
@@ -90,7 +93,7 @@ public class RequiredCredentialModel implements Serializable {
         SECRET.setFormLabel("secret");
         map.put(SECRET.getType(), SECRET);
         TOTP = new RequiredCredentialModel();
-        TOTP.setType(UserCredentialModel.TOTP);
+        TOTP.setType(OTPCredentialModel.TYPE);
         TOTP.setInput(true);
         TOTP.setSecret(false);
         TOTP.setFormLabel("authenticatorCode");
diff --git a/server-spi/src/main/java/org/keycloak/models/UserCredentialModel.java b/server-spi/src/main/java/org/keycloak/models/UserCredentialModel.java
index 9b1784ca34..07624b806a 100755
--- a/server-spi/src/main/java/org/keycloak/models/UserCredentialModel.java
+++ b/server-spi/src/main/java/org/keycloak/models/UserCredentialModel.java
@@ -18,11 +18,8 @@
 package org.keycloak.models;
 
 import org.keycloak.credential.CredentialInput;
-import org.keycloak.credential.CredentialModel;
-import org.keycloak.models.credential.PasswordUserCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 
-import java.util.HashMap;
-import java.util.Map;
 import java.util.UUID;
 
 /**
@@ -30,134 +27,68 @@ import java.util.UUID;
  * @version $Revision: 1 $
  */
 public class UserCredentialModel implements CredentialInput {
-    public static final String PASSWORD = CredentialModel.PASSWORD;
-    public static final String PASSWORD_HISTORY = CredentialModel.PASSWORD_HISTORY;
-    public static final String PASSWORD_TOKEN = CredentialModel.PASSWORD_TOKEN;
-
-    // Secret is same as password but it is not hashed
-    public static final String SECRET = CredentialModel.SECRET;
-    public static final String TOTP = CredentialModel.TOTP;
-    public static final String HOTP = CredentialModel.HOTP;
-    public static final String CLIENT_CERT = CredentialModel.CLIENT_CERT;
-    public static final String KERBEROS = CredentialModel.KERBEROS;
-
-    protected String type;
-    protected String value;
-    protected String device;
-    protected String algorithm;
-
-    // Additional context informations
-    protected Map<String, Object> notes = new HashMap<>();
-
-    public UserCredentialModel() {
-    }
 
-    public static PasswordUserCredentialModel password(String password) {
-        return password(password, false);
-    }
+    public static final String SECRET = "secret";
+    public static final String KERBEROS = "kerberos";
+    public static final String CLIENT_CERT = "cert";
 
-    public static PasswordUserCredentialModel password(String password, boolean adminRequest) {
-        PasswordUserCredentialModel model = new PasswordUserCredentialModel();
-        model.setType(PASSWORD);
-        model.setValue(password);
-        model.setAdminRequest(adminRequest);
-        return model;
-    }
+    private final String credentialId;
+    private final String type;
+    private final String challengeResponse;
+    private final boolean adminRequest;
 
-    public static UserCredentialModel passwordToken(String passwordToken) {
-        UserCredentialModel model = new UserCredentialModel();
-        model.setType(PASSWORD_TOKEN);
-        model.setValue(passwordToken);
-        return model;
+    public UserCredentialModel(String credentialId, String type, String challengeResponse) {
+        this.credentialId = credentialId;
+        this.type = type;
+        this.challengeResponse = challengeResponse;
+        this.adminRequest = false;
     }
 
-    public static UserCredentialModel secret(String password) {
-        UserCredentialModel model = new UserCredentialModel();
-        model.setType(SECRET);
-        model.setValue(password);
-        return model;
+    public UserCredentialModel(String credentialId, String type, String challengeResponse, boolean adminRequest) {
+        this.credentialId = credentialId;
+        this.type = type;
+        this.challengeResponse = challengeResponse;
+        this.adminRequest = adminRequest;
     }
 
-    public static UserCredentialModel otp(String type, String key) {
-        if (type.equals(HOTP)) return hotp(key);
-        if (type.equals(TOTP)) return totp(key);
-        throw new RuntimeException("Unknown OTP type");
+    public static UserCredentialModel password(String password) {
+        return password(password, false);
     }
 
-    public static UserCredentialModel totp(String key) {
-        UserCredentialModel model = new UserCredentialModel();
-        model.setType(TOTP);
-        model.setValue(key);
-        return model;
+    public static UserCredentialModel password(String password, boolean adminRequest) {
+        return new UserCredentialModel("", PasswordCredentialModel.TYPE, password, adminRequest);
     }
 
-    public static UserCredentialModel hotp(String key) {
-        UserCredentialModel model = new UserCredentialModel();
-        model.setType(HOTP);
-        model.setValue(key);
-        return model;
+    public static UserCredentialModel secret(String password) {
+        return new UserCredentialModel("", SECRET, password);
     }
 
     public static UserCredentialModel kerberos(String token) {
-        UserCredentialModel model = new UserCredentialModel();
-        model.setType(KERBEROS);
-        model.setValue(token);
-        return model;
+        return new UserCredentialModel("", KERBEROS, token);
     }
 
     public static UserCredentialModel generateSecret() {
-        UserCredentialModel model = new UserCredentialModel();
-        model.setType(SECRET);
-        model.setValue(UUID.randomUUID().toString());
-        return model;
+        return new UserCredentialModel("", SECRET, UUID.randomUUID().toString());
     }
 
-    public static boolean isOtp(String type) {
-        return TOTP.equals(type) || HOTP.equals(type);
+    @Override
+    public String getCredentialId() {
+        return credentialId;
     }
 
-
+    @Override
     public String getType() {
         return type;
     }
 
-    public void setType(String type) {
-        this.type = type;
+    @Override
+    public String getChallengeResponse() {
+        return challengeResponse;
     }
 
-    public String getValue() {
-        return value;
-    }
-
-    public void setValue(String value) {
-        this.value = value;
-    }
-
-    public String getDevice() {
-        return device;
-    }
-
-    public void setDevice(String device) {
-        this.device = device;
-    }
-
-    public String getAlgorithm() {
-        return algorithm;
-    }
-
-    public void setAlgorithm(String algorithm) {
-        this.algorithm = algorithm;
-    }
-
-    public void setNote(String key, String value) {
-        this.notes.put(key, value);
+    public boolean isAdminRequest() {
+        return adminRequest;
     }
+}
 
-    public void removeNote(String key) {
-        this.notes.remove(key);
-    }
 
-    public Object getNote(String key) {
-        return this.notes.get(key);
-    }
-}
diff --git a/server-spi/src/main/java/org/keycloak/models/credential/OTPCredentialModel.java b/server-spi/src/main/java/org/keycloak/models/credential/OTPCredentialModel.java
new file mode 100644
index 0000000000..7df7638249
--- /dev/null
+++ b/server-spi/src/main/java/org/keycloak/models/credential/OTPCredentialModel.java
@@ -0,0 +1,109 @@
+package org.keycloak.models.credential;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.keycloak.common.util.Time;
+import org.keycloak.credential.CredentialModel;
+import org.keycloak.models.credential.dto.OTPCredentialData;
+import org.keycloak.models.credential.dto.OTPSecretData;
+import org.keycloak.models.OTPPolicy;
+import org.keycloak.models.RealmModel;
+
+import java.io.IOException;
+
+public class OTPCredentialModel extends CredentialModel {
+
+    public final static String TYPE = "otp";
+
+    public final static String TOTP = "totp";
+    public final static String HOTP = "hotp";
+
+    private final OTPCredentialData credentialData;
+    private final OTPSecretData secretData;
+
+    private OTPCredentialModel(String secretValue, String subType, int digits, int counter, int period, String algorithm) {
+        credentialData = new OTPCredentialData(subType, digits, counter, period, algorithm);
+        secretData = new OTPSecretData(secretValue);
+    }
+
+    private OTPCredentialModel(OTPCredentialData credentialData, OTPSecretData secretData) {
+        this.credentialData = credentialData;
+        this.secretData = secretData;
+    }
+
+    public static OTPCredentialModel createTOTP(String secretValue, int digits, int period, String algorithm){
+        OTPCredentialModel credentialModel = new OTPCredentialModel(secretValue, TOTP, digits, 0, period, algorithm);
+        credentialModel.fillCredentialModelFields();
+        return credentialModel;
+    }
+
+    public static OTPCredentialModel createHOTP(String secretValue, int digits, int counter, String algorithm) {
+        OTPCredentialModel credentialModel = new OTPCredentialModel(secretValue, HOTP, digits, counter, 0, algorithm);
+        credentialModel.fillCredentialModelFields();
+        return credentialModel;
+    }
+
+    public static OTPCredentialModel createFromPolicy(RealmModel realm, String secretValue) {
+        return createFromPolicy(realm, secretValue, "");
+    }
+
+    public static OTPCredentialModel createFromPolicy(RealmModel realm, String secretValue, String userLabel) {
+        OTPPolicy policy = realm.getOTPPolicy();
+
+        OTPCredentialModel credentialModel = new OTPCredentialModel(secretValue, policy.getType(), policy.getDigits(),
+                policy.getInitialCounter(), policy.getPeriod(), policy.getAlgorithm());
+        credentialModel.fillCredentialModelFields();
+        credentialModel.setUserLabel(userLabel);
+        return credentialModel;
+    }
+
+    public static OTPCredentialModel createFromCredentialModel(CredentialModel credentialModel) {
+        ObjectMapper objectMapper = new ObjectMapper();
+        try {
+            OTPCredentialData credentialData = objectMapper.readValue(credentialModel.getCredentialData(), OTPCredentialData.class);
+            OTPSecretData secretData = objectMapper.readValue(credentialModel.getSecretData(), OTPSecretData.class);
+
+            OTPCredentialModel otpCredentialModel = new OTPCredentialModel(credentialData, secretData);
+            otpCredentialModel.setUserLabel(credentialModel.getUserLabel());
+            otpCredentialModel.setCreatedDate(credentialModel.getCreatedDate());
+            otpCredentialModel.setType(TYPE);
+            otpCredentialModel.setId(credentialModel.getId());
+            otpCredentialModel.setSecretData(credentialModel.getSecretData());
+            otpCredentialModel.setCredentialData(credentialModel.getCredentialData());
+            return otpCredentialModel;
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
+    public void updateCounter(int counter) {
+        ObjectMapper objectMapper = new ObjectMapper();
+        credentialData.setCounter(counter);
+        try {
+            setCredentialData(objectMapper.writeValueAsString(credentialData));
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public OTPCredentialData getOTPCredentialData() {
+        return credentialData;
+    }
+
+    public OTPSecretData getOTPSecretData() {
+        return secretData;
+    }
+
+    private void fillCredentialModelFields(){
+        ObjectMapper objectMapper = new ObjectMapper();
+        try {
+            setCredentialData(objectMapper.writeValueAsString(credentialData));
+            setSecretData(objectMapper.writeValueAsString(secretData));
+            setType(TYPE);
+            setCreatedDate(Time.currentTimeMillis());
+        } catch (JsonProcessingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/server-spi/src/main/java/org/keycloak/models/credential/PasswordCredentialModel.java b/server-spi/src/main/java/org/keycloak/models/credential/PasswordCredentialModel.java
new file mode 100644
index 0000000000..b0f5c973a0
--- /dev/null
+++ b/server-spi/src/main/java/org/keycloak/models/credential/PasswordCredentialModel.java
@@ -0,0 +1,73 @@
+package org.keycloak.models.credential;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.keycloak.credential.CredentialModel;
+import org.keycloak.models.credential.dto.PasswordCredentialData;
+import org.keycloak.models.credential.dto.PasswordSecretData;
+
+import java.io.IOException;
+
+public class PasswordCredentialModel extends CredentialModel {
+
+    public final static String TYPE = "password";
+    public final static String PASSWORD_HISTORY = "password_history";
+
+    private final PasswordCredentialData credentialData;
+    private final PasswordSecretData secretData;
+
+    private PasswordCredentialModel(PasswordCredentialData credentialData, PasswordSecretData secretData) {
+        this.credentialData = credentialData;
+        this.secretData = secretData;
+    }
+
+    public static PasswordCredentialModel createFromValues(String algorithm, byte[] salt, int hashIterations, String encodedPassword){
+        ObjectMapper objectMapper = new ObjectMapper();
+        PasswordCredentialData credentialData = new PasswordCredentialData(hashIterations, algorithm);
+        PasswordSecretData secretData = new PasswordSecretData(encodedPassword, salt);
+
+        PasswordCredentialModel passwordCredentialModel = new PasswordCredentialModel(credentialData, secretData);
+
+        try {
+            passwordCredentialModel.setCredentialData(objectMapper.writeValueAsString(credentialData));
+            passwordCredentialModel.setSecretData(objectMapper.writeValueAsString(secretData));
+            passwordCredentialModel.setType(TYPE);
+            return passwordCredentialModel;
+        } catch (JsonProcessingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static PasswordCredentialModel createFromCredentialModel(CredentialModel credentialModel) {
+        ObjectMapper objectMapper = new ObjectMapper();
+
+        try {
+            PasswordCredentialData credentialData = objectMapper.readValue(credentialModel.getCredentialData(),
+                    PasswordCredentialData.class);
+            PasswordSecretData secretData = objectMapper.readValue(credentialModel.getSecretData(), PasswordSecretData.class);
+
+            PasswordCredentialModel passwordCredentialModel = new PasswordCredentialModel(credentialData, secretData);
+            passwordCredentialModel.setCreatedDate(credentialModel.getCreatedDate());
+            passwordCredentialModel.setCredentialData(credentialModel.getCredentialData());
+            passwordCredentialModel.setId(credentialModel.getId());
+            passwordCredentialModel.setSecretData(credentialModel.getSecretData());
+            passwordCredentialModel.setType(TYPE);
+            passwordCredentialModel.setUserLabel(credentialModel.getUserLabel());
+
+            return passwordCredentialModel;
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+
+    public PasswordCredentialData getPasswordCredentialData() {
+        return credentialData;
+    }
+
+    public PasswordSecretData getPasswordSecretData() {
+        return secretData;
+    }
+
+
+}
diff --git a/server-spi/src/main/java/org/keycloak/models/credential/PasswordUserCredentialModel.java b/server-spi/src/main/java/org/keycloak/models/credential/PasswordUserCredentialModel.java
deleted file mode 100644
index a688ea32e3..0000000000
--- a/server-spi/src/main/java/org/keycloak/models/credential/PasswordUserCredentialModel.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright 2016 Red Hat, Inc. and/or its affiliates
- * and other contributors as indicated by the @author tags.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package org.keycloak.models.credential;
-
-import org.keycloak.models.UserCredentialModel;
-
-/**
- * @author <a href="mailto:mposolda@redhat.com">Marek Posolda</a>
- */
-public class PasswordUserCredentialModel extends UserCredentialModel {
-
-    // True if we have password-update request triggered by admin, not by user himself
-    private static final String ADMIN_REQUEST = "adminRequest";
-
-    public boolean isAdminRequest() {
-        Boolean b = (Boolean) this.notes.get(ADMIN_REQUEST);
-        return b!=null && b;
-    }
-
-    public void setAdminRequest(boolean adminRequest) {
-        this.notes.put(ADMIN_REQUEST, adminRequest);
-    }
-}
diff --git a/server-spi/src/main/java/org/keycloak/models/credential/dto/OTPCredentialData.java b/server-spi/src/main/java/org/keycloak/models/credential/dto/OTPCredentialData.java
new file mode 100644
index 0000000000..a9cfec3acf
--- /dev/null
+++ b/server-spi/src/main/java/org/keycloak/models/credential/dto/OTPCredentialData.java
@@ -0,0 +1,49 @@
+package org.keycloak.models.credential.dto;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+public class OTPCredentialData {
+    private final String subType;
+    private final int digits;
+    private int counter;
+    private final int period;
+    private final String algorithm;
+
+    @JsonCreator
+    public OTPCredentialData(@JsonProperty("subType") String subType,
+                             @JsonProperty("digits") int digits,
+                             @JsonProperty("counter") int counter,
+                             @JsonProperty("period") int period,
+                             @JsonProperty("algorithm") String algorithm) {
+        this.subType = subType;
+        this.digits = digits;
+        this.counter = counter;
+        this.period = period;
+        this.algorithm = algorithm;
+    }
+
+    public String getSubType() {
+        return subType;
+    }
+
+    public int getDigits() {
+        return digits;
+    }
+
+    public int getCounter() {
+        return counter;
+    }
+
+    public void setCounter(int counter) {
+        this.counter = counter;
+    }
+
+    public int getPeriod() {
+        return period;
+    }
+
+    public String getAlgorithm() {
+        return algorithm;
+    }
+}
diff --git a/server-spi/src/main/java/org/keycloak/models/credential/dto/OTPSecretData.java b/server-spi/src/main/java/org/keycloak/models/credential/dto/OTPSecretData.java
new file mode 100644
index 0000000000..3586c2267a
--- /dev/null
+++ b/server-spi/src/main/java/org/keycloak/models/credential/dto/OTPSecretData.java
@@ -0,0 +1,17 @@
+package org.keycloak.models.credential.dto;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+public class OTPSecretData {
+    private final String value;
+
+    @JsonCreator
+    public OTPSecretData(@JsonProperty("value") String value) {
+        this.value = value;
+    }
+
+    public String getValue() {
+        return value;
+    }
+}
diff --git a/server-spi/src/main/java/org/keycloak/models/credential/dto/PasswordCredentialData.java b/server-spi/src/main/java/org/keycloak/models/credential/dto/PasswordCredentialData.java
new file mode 100644
index 0000000000..e7753e9f38
--- /dev/null
+++ b/server-spi/src/main/java/org/keycloak/models/credential/dto/PasswordCredentialData.java
@@ -0,0 +1,23 @@
+package org.keycloak.models.credential.dto;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+public class PasswordCredentialData {
+    private final int hashIterations;
+    private final String algorithm;
+
+    @JsonCreator
+    public PasswordCredentialData(@JsonProperty("hashIterations") int hashIterations, @JsonProperty("algorithm") String algorithm) {
+        this.hashIterations = hashIterations;
+        this.algorithm = algorithm;
+    }
+
+    public int getHashIterations() {
+        return hashIterations;
+    }
+
+    public String getAlgorithm() {
+        return algorithm;
+    }
+}
diff --git a/server-spi/src/main/java/org/keycloak/models/credential/dto/PasswordSecretData.java b/server-spi/src/main/java/org/keycloak/models/credential/dto/PasswordSecretData.java
new file mode 100644
index 0000000000..34cdfe09e0
--- /dev/null
+++ b/server-spi/src/main/java/org/keycloak/models/credential/dto/PasswordSecretData.java
@@ -0,0 +1,23 @@
+package org.keycloak.models.credential.dto;
+
+import com.fasterxml.jackson.annotation.JsonCreator;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+public class PasswordSecretData {
+    private final String value;
+    private final byte[] salt;
+
+    @JsonCreator
+    public PasswordSecretData(@JsonProperty("value") String value, @JsonProperty("salt") byte[] salt) {
+        this.value = value;
+        this.salt = salt;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    public byte[] getSalt() {
+        return salt;
+    }
+}
diff --git a/services/src/main/java/org/keycloak/authentication/AuthenticationProcessor.java b/services/src/main/java/org/keycloak/authentication/AuthenticationProcessor.java
index a77572bd16..19552d6541 100755
--- a/services/src/main/java/org/keycloak/authentication/AuthenticationProcessor.java
+++ b/services/src/main/java/org/keycloak/authentication/AuthenticationProcessor.java
@@ -23,6 +23,7 @@ import org.keycloak.authentication.authenticators.browser.AbstractUsernameFormAu
 import org.keycloak.authentication.authenticators.client.ClientAuthUtil;
 import org.keycloak.common.ClientConnection;
 import org.keycloak.common.util.Time;
+import org.keycloak.credential.CredentialModel;
 import org.keycloak.events.Details;
 import org.keycloak.events.Errors;
 import org.keycloak.events.EventBuilder;
@@ -30,7 +31,6 @@ import org.keycloak.forms.login.LoginFormsProvider;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.AuthenticationFlowModel;
 import org.keycloak.models.AuthenticatorConfigModel;
-import org.keycloak.models.AuthenticatedClientSessionModel;
 import org.keycloak.models.ClientModel;
 import org.keycloak.models.ClientSessionContext;
 import org.keycloak.models.Constants;
@@ -276,6 +276,8 @@ public class AuthenticationProcessor {
         List<AuthenticationExecutionModel> currentExecutions;
         FormMessage errorMessage;
         FormMessage successMessage;
+        String selectedCredentialId;
+        List<AuthenticationSelectionOption> authenticationSelections;
 
         private Result(AuthenticationExecutionModel execution, Authenticator authenticator, List<AuthenticationExecutionModel> currentExecutions) {
             this.execution = execution;
@@ -393,6 +395,26 @@ public class AuthenticationProcessor {
             setAutheticatedUser(user);
         }
 
+        @Override
+        public String getSelectedCredentialId() {
+            return selectedCredentialId;
+        }
+
+        @Override
+        public void setSelectedCredentialId(String selectedCredentialId) {
+            this.selectedCredentialId = selectedCredentialId;
+        }
+
+        @Override
+        public List<AuthenticationSelectionOption> getAuthenticationSelections() {
+            return authenticationSelections;
+        }
+
+        @Override
+        public void setAuthenticationSelections(List<AuthenticationSelectionOption> authenticationSelections) {
+            this.authenticationSelections = authenticationSelections;
+        }
+
         @Override
         public void clearUser() {
             clearAuthenticatedUser();
@@ -786,6 +808,9 @@ public class AuthenticationProcessor {
         AuthenticationFlow authenticationFlow = createFlowExecution(this.flowId, null);
         try {
             Response challenge = authenticationFlow.processFlow();
+            if (!authenticationFlow.isSuccessful()) {
+                throw new AuthenticationFlowException(AuthenticationFlowError.INVALID_CREDENTIALS);
+            }
             return challenge;
         } catch (Exception e) {
             return handleClientAuthException(e);
@@ -912,6 +937,9 @@ public class AuthenticationProcessor {
         if (authenticationSession.getAuthenticatedUser() == null) {
             throw new AuthenticationFlowException(AuthenticationFlowError.UNKNOWN_USER);
         }
+        if (!authenticationFlow.isSuccessful()) {
+            throw new AuthenticationFlowException(AuthenticationFlowError.INVALID_CREDENTIALS);
+        }
         return challenge;
     }
 
diff --git a/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java b/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java
index 044f4a5406..bddb415b0f 100755
--- a/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java
+++ b/services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java
@@ -42,6 +42,8 @@ public class ClientAuthenticationFlow implements AuthenticationFlow {
     AuthenticationProcessor processor;
     AuthenticationFlowModel flow;
 
+    private boolean success;
+
     public ClientAuthenticationFlow(AuthenticationProcessor processor, AuthenticationFlowModel flow) {
         this.processor = processor;
         this.flow = flow;
@@ -84,6 +86,8 @@ public class ClientAuthenticationFlow implements AuthenticationFlow {
 
                     if (!context.getStatus().equals(FlowStatus.SUCCESS)) {
                         throw new AuthenticationFlowException("Expected success, but for an unknown reason the status was " + context.getStatus(), AuthenticationFlowError.INTERNAL_ERROR);
+                    } else {
+                        success = true;
                     }
 
                     logger.debugv("Client {0} authenticated by {1}", client.getClientId(), factory.getId());
@@ -176,4 +180,9 @@ public class ClientAuthenticationFlow implements AuthenticationFlow {
 
         return result.getChallenge();
     }
+
+    @Override
+    public boolean isSuccessful() {
+        return success;
+    }
 }
diff --git a/services/src/main/java/org/keycloak/authentication/DefaultAuthenticationFlow.java b/services/src/main/java/org/keycloak/authentication/DefaultAuthenticationFlow.java
index 3c4c2e639e..676480b55b 100755
--- a/services/src/main/java/org/keycloak/authentication/DefaultAuthenticationFlow.java
+++ b/services/src/main/java/org/keycloak/authentication/DefaultAuthenticationFlow.java
@@ -19,15 +19,23 @@ package org.keycloak.authentication;
 
 import org.jboss.logging.Logger;
 import org.keycloak.OAuth2Constants;
+import org.keycloak.authentication.authenticators.conditional.ConditionalBlockAuthenticator;
+import org.keycloak.credential.CredentialModel;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.AuthenticationFlowModel;
 import org.keycloak.models.UserModel;
 import org.keycloak.services.ServicesLogger;
 import org.keycloak.sessions.AuthenticationSessionModel;
 
+import javax.ws.rs.core.MultivaluedHashMap;
+import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.Response;
-import java.util.Iterator;
+import java.util.ArrayList;
+import java.util.HashMap;
 import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.stream.Collectors;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
@@ -35,19 +43,15 @@ import java.util.List;
  */
 public class DefaultAuthenticationFlow implements AuthenticationFlow {
     private static final Logger logger = Logger.getLogger(DefaultAuthenticationFlow.class);
-    Response alternativeChallenge = null;
-    AuthenticationExecutionModel challengedAlternativeExecution = null;
-    boolean alternativeSuccessful = false;
-    List<AuthenticationExecutionModel> executions;
-    Iterator<AuthenticationExecutionModel> executionIterator;
-    AuthenticationProcessor processor;
-    AuthenticationFlowModel flow;
+    private final List<AuthenticationExecutionModel> executions;
+    private final AuthenticationProcessor processor;
+    private final AuthenticationFlowModel flow;
+    private boolean successful;
 
     public DefaultAuthenticationFlow(AuthenticationProcessor processor, AuthenticationFlowModel flow) {
         this.processor = processor;
         this.flow = flow;
         this.executions = processor.getRealm().getAuthenticationExecutions(flow.getId());
-        this.executionIterator = executions.iterator();
     }
 
     protected boolean isProcessed(AuthenticationExecutionModel model) {
@@ -63,9 +67,8 @@ public class DefaultAuthenticationFlow implements AuthenticationFlow {
         String display = processor.getAuthenticationSession().getAuthNote(OAuth2Constants.DISPLAY);
         if (display == null) return factory.create(processor.getSession());
 
-
         if (factory instanceof DisplayTypeAuthenticatorFactory) {
-            Authenticator authenticator = ((DisplayTypeAuthenticatorFactory)factory).createDisplay(processor.getSession(), display);
+            Authenticator authenticator = ((DisplayTypeAuthenticatorFactory) factory).createDisplay(processor.getSession(), display);
             if (authenticator != null) return authenticator;
         }
         // todo create a provider for handling lack of display support
@@ -73,156 +76,365 @@ public class DefaultAuthenticationFlow implements AuthenticationFlow {
             processor.getAuthenticationSession().removeAuthNote(OAuth2Constants.DISPLAY);
             throw new AuthenticationFlowException(AuthenticationFlowError.DISPLAY_NOT_SUPPORTED,
                     ConsoleDisplayMode.browserContinue(processor.getSession(), processor.getRefreshUrl(true).toString()));
-
         } else {
             return factory.create(processor.getSession());
         }
     }
 
-
     @Override
     public Response processAction(String actionExecution) {
         logger.debugv("processAction: {0}", actionExecution);
-        while (executionIterator.hasNext()) {
-            AuthenticationExecutionModel model = executionIterator.next();
-            logger.debugv("check: {0} requirement: {1}", model.getAuthenticator(), model.getRequirement().toString());
-            if (isProcessed(model)) {
-                logger.debug("execution is processed");
-                if (!alternativeSuccessful && model.isAlternative() && processor.isSuccessful(model))
-                    alternativeSuccessful = true;
-                continue;
-            }
-            if (model.isAuthenticatorFlow()) {
-                AuthenticationFlow authenticationFlow = processor.createFlowExecution(model.getFlowId(), model);
-                Response flowChallenge = authenticationFlow.processAction(actionExecution);
-                if (flowChallenge == null) {
-                    processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.SUCCESS);
-                    if (model.isAlternative()) alternativeSuccessful = true;
-                    return processFlow();
-                } else {
-                   return flowChallenge;
+        if (actionExecution == null || actionExecution.isEmpty()) {
+            throw new AuthenticationFlowException("action is not in current execution", AuthenticationFlowError.INTERNAL_ERROR);
+        }
+        AuthenticationExecutionModel model = processor.getRealm().getAuthenticationExecutionById(actionExecution);
+        if (model == null) {
+            throw new AuthenticationFlowException("action is not in current execution", AuthenticationFlowError.INTERNAL_ERROR);
+        }
+
+        //TODO check that execution is in current flow tree for security reasons?
+
+        MultivaluedMap<String, String> inputData = processor.getRequest().getDecodedFormParameters();
+        String authExecId = inputData.getFirst("authenticationExecution");
+        String selectedCredentialId = inputData.getFirst("credentialId");
+
+        //check if the user has selected the "back" option
+        if (inputData.containsKey("back")) {
+            //If current execution is required, get other required executions in flow, and see if we can return to previous
+            if (model.isRequired()) {
+                List<AuthenticationExecutionModel> executionsInCurrentFlow = processor.getRealm().getAuthenticationExecutions(model.getParentFlow());
+
+                List<AuthenticationExecutionModel> requiredExecutions = executionsInCurrentFlow.stream().filter(AuthenticationExecutionModel::isRequired)
+                    .filter(m -> !isConditionalAuthenticator(m)).collect(Collectors.toList());
+                int index = requiredExecutions.indexOf(model);
+                //if in a list of required executions, move back to previous if not the first
+                if (index > 0) {
+                    processor.getAuthenticationSession().getExecutionStatus().remove(requiredExecutions.get(index - 1).getId());
+                    Response response = processSingleFlowExecutionModel(requiredExecutions.get(index - 1), null, false);
+                    if (response == null) {
+                        processor.getAuthenticationSession().removeAuthNote(AuthenticationProcessor.CURRENT_AUTHENTICATION_EXECUTION);
+                        return processFlow();
+                    } else return response;
                 }
-            } else if (model.getId().equals(actionExecution)) {
-                AuthenticatorFactory factory = (AuthenticatorFactory) processor.getSession().getKeycloakSessionFactory().getProviderFactory(Authenticator.class, model.getAuthenticator());
-                if (factory == null) {
-                    throw new RuntimeException("Unable to find factory for AuthenticatorFactory: " + model.getAuthenticator() + " did you forget to declare it in a META-INF/services file?");
+            }
+            //Otherwise, go up to the parent of the current flow, if one exists
+            if (!processor.getRealm().getAuthenticationFlowById(model.getParentFlow()).isTopLevel()) {
+                //Clear all execution statuses of executions in parent flow and for each sub-tree. This is necessary to remove any
+                //status that may have been set by an automatic authenticator, but which would not be cleared otherwise.
+                AuthenticationExecutionModel currentFlow = processor.getRealm().getAuthenticationExecutionByFlowId(model.getParentFlow());
+                List<AuthenticationExecutionModel> parentFlowExecutions = processor.getRealm().getAuthenticationExecutions(currentFlow.getParentFlow());
+                for (AuthenticationExecutionModel execution : parentFlowExecutions) {
+                    recursiveClearExecutionStatus(execution);
                 }
-                Authenticator authenticator = createAuthenticator(factory);
-                AuthenticationProcessor.Result result = processor.createAuthenticatorContext(model, authenticator, executions);
-                logger.debugv("action: {0}", model.getAuthenticator());
-                authenticator.action(result);
-                Response response = processResult(result, true);
-                if (response == null) {
-                    processor.getAuthenticationSession().removeAuthNote(AuthenticationProcessor.CURRENT_AUTHENTICATION_EXECUTION);
-                    return processFlow();
-                } else return response;
+                processor.getAuthenticationSession().removeAuthNote(AuthenticationProcessor.CURRENT_AUTHENTICATION_EXECUTION);
+                return processFlow();
             }
         }
-        throw new AuthenticationFlowException("action is not in current execution", AuthenticationFlowError.INTERNAL_ERROR);
+
+        // check if the user has switched to a new authentication execution, and if so switch to it.
+        if (authExecId != null && !authExecId.isEmpty()) {
+            model = processor.getRealm().getAuthenticationExecutionById(authExecId);
+            Response response = processSingleFlowExecutionModel(model, selectedCredentialId, false);
+            if (response == null) {
+                processor.getAuthenticationSession().removeAuthNote(AuthenticationProcessor.CURRENT_AUTHENTICATION_EXECUTION);
+                checkAndValidateParentFlow(model);
+                return processFlow();
+            } else return response;
+        }
+        //handle case where execution is a flow
+        if (model.isAuthenticatorFlow()) {
+            logger.debug("execution is flow");
+            AuthenticationFlow authenticationFlow = processor.createFlowExecution(model.getFlowId(), model);
+            Response flowChallenge = authenticationFlow.processAction(actionExecution);
+            if (flowChallenge == null) {
+                checkAndValidateParentFlow(model);
+                return processFlow();
+            } else {
+                processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.CHALLENGED);
+                return flowChallenge;
+            }
+        }
+        //handle normal execution case
+        AuthenticatorFactory factory = getAuthenticatorFactory(model);
+        Authenticator authenticator = createAuthenticator(factory);
+        AuthenticationProcessor.Result result = processor.createAuthenticatorContext(model, authenticator, executions);
+        result.setAuthenticationSelections(createAuthenticationSelectionList(model));
+
+        result.setSelectedCredentialId(selectedCredentialId);
+
+        logger.debugv("action: {0}", model.getAuthenticator());
+        authenticator.action(result);
+        Response response = processResult(result, true);
+        if (response == null) {
+            processor.getAuthenticationSession().removeAuthNote(AuthenticationProcessor.CURRENT_AUTHENTICATION_EXECUTION);
+            checkAndValidateParentFlow(model);
+            return processFlow();
+        } else return response;
+    }
+
+    /**
+     * Removes the execution status for an execution. If it is a flow, do the same for all sub-executions.
+     * @param execution the execution for which the status must be cleared
+     */
+    private void recursiveClearExecutionStatus(AuthenticationExecutionModel execution) {
+        processor.getAuthenticationSession().getExecutionStatus().remove(execution.getId());
+        if (execution.isAuthenticatorFlow()) {
+            processor.getRealm().getAuthenticationExecutions(execution.getFlowId()).forEach(this::recursiveClearExecutionStatus);
+        }
+    }
+
+    /**
+     * This method makes sure that the parent flow's corresponding execution is considered successful if its contained
+     * executions are successful.
+     * The purpose is for when an execution is validated through an action, to make sure its parent flow can be successful
+     * when re-evaluation the flow tree.
+     *
+     * @param model An execution model.
+     */
+    private void checkAndValidateParentFlow(AuthenticationExecutionModel model) {
+        List<AuthenticationExecutionModel> localExecutions = processor.getRealm().getAuthenticationExecutions(model.getParentFlow());
+        AuthenticationExecutionModel parentFlowModel = processor.getRealm().getAuthenticationExecutionByFlowId(model.getParentFlow());
+        if (parentFlowModel != null &&
+                ((model.isRequired() && localExecutions.stream().allMatch(processor::isSuccessful)) ||
+                        (model.isAlternative() && localExecutions.stream().anyMatch(processor::isSuccessful)))) {
+            processor.getAuthenticationSession().setExecutionStatus(parentFlowModel.getId(), AuthenticationSessionModel.ExecutionStatus.SUCCESS);
+        }
     }
 
     @Override
     public Response processFlow() {
         logger.debug("processFlow");
-        while (executionIterator.hasNext()) {
-            AuthenticationExecutionModel model = executionIterator.next();
-            logger.debugv("check execution: {0} requirement: {1}", model.getAuthenticator(), model.getRequirement().toString());
-
-            if (isProcessed(model)) {
-                logger.debug("execution is processed");
-                if (!alternativeSuccessful && model.isAlternative() && processor.isSuccessful(model))
-                    alternativeSuccessful = true;
-                continue;
+
+        //separate flow elements into required and alternative elements
+        List<AuthenticationExecutionModel> conditionalList = new ArrayList<>();
+        List<AuthenticationExecutionModel> requiredList = new ArrayList<>();
+        List<AuthenticationExecutionModel> alternativeList = new ArrayList<>();
+
+        for (AuthenticationExecutionModel execution : executions) {
+            if (isConditionalAuthenticator(execution)) {
+                conditionalList.add(execution);
+            } else if (execution.isRequired() || execution.isOptional()) {
+                requiredList.add(execution);
+            } else if (execution.isAlternative()) {
+                alternativeList.add(execution);
+            }
+        }
+
+        // Conditionals should be executed without considering SUCCESS/FAILED status
+        // If condition is matched, the execution of the flow goes on
+        // If condition is not matched, simply stop processing this flow and go on processing parent flow
+        if (flowIsOptional() && (conditionalList.isEmpty() || conditionalList.stream().anyMatch(this::conditionalNotMatched))) {
+            successful = true;
+            return null;
+        }
+
+        //handle required elements : all required elements need to be executed
+        boolean requiredElementsSuccessful = true;
+        for (AuthenticationExecutionModel required : requiredList) {
+            Response response = processSingleFlowExecutionModel(required, null, true);
+            requiredElementsSuccessful &= processor.isSuccessful(required);
+            if (response != null) {
+                return response;
             }
-            if (model.isAlternative() && alternativeSuccessful) {
-                logger.debug("Skip alternative execution");
-                processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.SKIPPED);
-                continue;
+        }
+
+        //Evaluate alternative elements only if there are no required elements
+        if (requiredList.isEmpty()) {
+            //check if an alternative is already successful, in case we are returning in the flow after an action
+            if (alternativeList.stream().anyMatch(processor::isSuccessful)) {
+                successful = true;
+                return null;
             }
-            if (model.isAuthenticatorFlow()) {
-                logger.debug("execution is flow");
-                AuthenticationFlow authenticationFlow = processor.createFlowExecution(model.getFlowId(), model);
 
-                Response flowChallenge = null;
+            //handle alternative elements: the first alternative element to be satisfied is enough
+            for (AuthenticationExecutionModel alternative : alternativeList) {
                 try {
-                    flowChallenge = authenticationFlow.processFlow();
-                } catch (AuthenticationFlowException afe) {
-                    if (model.isAlternative()) {
-                        logger.debug("Thrown exception in alternative Subflow. Ignoring Subflow");
-                        processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.ATTEMPTED);
-                        continue;
-                    } else {
-                        throw afe;
+                    Response response = processSingleFlowExecutionModel(alternative, null, true);
+                    if (response != null) {
+                        return response;
                     }
+                    if (processor.isSuccessful(alternative)) {
+                        successful = true;
+                        return null;
+                    }
+                } catch (AuthenticationFlowException afe) {
+                    processor.getAuthenticationSession().setExecutionStatus(alternative.getId(), AuthenticationSessionModel.ExecutionStatus.ATTEMPTED);
                 }
+            }
+        } else {
+            successful = requiredElementsSuccessful;
+        }
+        return null;
+    }
+
+    private boolean flowIsOptional() {
+        AuthenticationExecutionModel flowModel = processor.getRealm().getAuthenticationExecutionByFlowId(flow.getId());
+        return flowModel!=null && flowModel.isOptional();
+    }
 
-                if (flowChallenge == null) {
+    private boolean isConditionalAuthenticator(AuthenticationExecutionModel model) {
+        return !model.isAuthenticatorFlow() && model.getAuthenticator() != null && createAuthenticator(getAuthenticatorFactory(model)) instanceof ConditionalBlockAuthenticator;
+    }
+
+    private AuthenticatorFactory getAuthenticatorFactory(AuthenticationExecutionModel model) {
+        AuthenticatorFactory factory = (AuthenticatorFactory) processor.getSession().getKeycloakSessionFactory().getProviderFactory(Authenticator.class, model.getAuthenticator());
+        if (factory == null) {
+            throw new RuntimeException("Unable to find factory for AuthenticatorFactory: " + model.getAuthenticator() + " did you forget to declare it in a META-INF/services file?");
+        }
+        return factory;
+    }
+
+    private boolean conditionalNotMatched(AuthenticationExecutionModel model) {
+        AuthenticatorFactory factory = getAuthenticatorFactory(model);
+        ConditionalBlockAuthenticator authenticator = (ConditionalBlockAuthenticator) createAuthenticator(factory);
+        AuthenticationProcessor.Result context = processor.createAuthenticatorContext(model, authenticator, executions);
+
+        return !authenticator.matchCondition(context);
+    }
+
+    private Response processSingleFlowExecutionModel(AuthenticationExecutionModel model, String selectedCredentialId, boolean calledFromFlow) {
+        logger.debugv("check execution: {0} requirement: {1}", model.getAuthenticator(), model.getRequirement());
+
+        if (isProcessed(model)) {
+            logger.debug("execution is processed");
+            return null;
+        }
+        //handle case where execution is a flow
+        if (model.isAuthenticatorFlow()) {
+            logger.debug("execution is flow");
+            AuthenticationFlow authenticationFlow = processor.createFlowExecution(model.getFlowId(), model);
+            Response flowChallenge = authenticationFlow.processFlow();
+            if (flowChallenge == null) {
+                if (authenticationFlow.isSuccessful()) {
                     processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.SUCCESS);
-                    if (model.isAlternative()) alternativeSuccessful = true;
-                    continue;
                 } else {
-                    if (model.isAlternative()) {
-                        alternativeChallenge = flowChallenge;
-                        challengedAlternativeExecution = model;
-                    } else if (model.isRequired()) {
-                        processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.CHALLENGED);
-                        return flowChallenge;
-                    } else if (model.isOptional()) {
-                        processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.SKIPPED);
-                        continue;
-                    } else {
-                        processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.SKIPPED);
-                        continue;
-                    }
-                    return flowChallenge;
+                    processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.FAILED);
                 }
+                return null;
+            } else {
+                processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.CHALLENGED);
+                return flowChallenge;
             }
+        }
+
+        //handle normal execution case
+        AuthenticatorFactory factory = getAuthenticatorFactory(model);
+        Authenticator authenticator = createAuthenticator(factory);
+        logger.debugv("authenticator: {0}", factory.getId());
+        UserModel authUser = processor.getAuthenticationSession().getAuthenticatedUser();
 
-            AuthenticatorFactory factory = (AuthenticatorFactory) processor.getSession().getKeycloakSessionFactory().getProviderFactory(Authenticator.class, model.getAuthenticator());
+        //If executions are alternative, get the actual execution to show based on user preference
+        List<AuthenticationSelectionOption> selectionOptions = createAuthenticationSelectionList(model);
+        if (!selectionOptions.isEmpty() && calledFromFlow) {
+            model = selectionOptions.stream().filter(aso -> !aso.getAuthenticationExecution().isAuthenticatorFlow() && !isProcessed(aso.getAuthenticationExecution())).findFirst().get().getAuthenticationExecution();
+            factory = (AuthenticatorFactory) processor.getSession().getKeycloakSessionFactory().getProviderFactory(Authenticator.class, model.getAuthenticator());
             if (factory == null) {
                 throw new RuntimeException("Unable to find factory for AuthenticatorFactory: " + model.getAuthenticator() + " did you forget to declare it in a META-INF/services file?");
             }
-            Authenticator authenticator = createAuthenticator(factory);
-            logger.debugv("authenticator: {0}", factory.getId());
-            UserModel authUser = processor.getAuthenticationSession().getAuthenticatedUser();
-
-            if (authenticator.requiresUser() && authUser == null) {
-                if (alternativeChallenge != null) {
-                    processor.getAuthenticationSession().setExecutionStatus(challengedAlternativeExecution.getId(), AuthenticationSessionModel.ExecutionStatus.CHALLENGED);
-                    return alternativeChallenge;
-                }
+            authenticator = createAuthenticator(factory);
+        }
+        AuthenticationProcessor.Result context = processor.createAuthenticatorContext(model, authenticator, executions);
+        context.setAuthenticationSelections(selectionOptions);
+        if (selectedCredentialId != null) {
+            context.setSelectedCredentialId(selectedCredentialId);
+        }
+
+        if (authenticator.requiresUser()) {
+            if (authUser == null) {
                 throw new AuthenticationFlowException("authenticator: " + factory.getId(), AuthenticationFlowError.UNKNOWN_USER);
             }
-            boolean configuredFor = false;
-            if (authenticator.requiresUser() && authUser != null) {
-                configuredFor = authenticator.configuredFor(processor.getSession(), processor.getRealm(), authUser);
-                if (!configuredFor) {
-                    if (model.isRequired()) {
-                        if (factory.isUserSetupAllowed()) {
-                            logger.debugv("authenticator SETUP_REQUIRED: {0}", factory.getId());
-                            processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.SETUP_REQUIRED);
-                            authenticator.setRequiredActions(processor.getSession(), processor.getRealm(), processor.getAuthenticationSession().getAuthenticatedUser());
+            if (!authenticator.configuredFor(processor.getSession(), processor.getRealm(), authUser)) {
+                if (factory.isUserSetupAllowed()) {
+                    logger.debugv("authenticator SETUP_REQUIRED: {0}", factory.getId());
+                    processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.SETUP_REQUIRED);
+                    authenticator.setRequiredActions(processor.getSession(), processor.getRealm(), processor.getAuthenticationSession().getAuthenticatedUser());
+                    return null;
+                } else {
+                    throw new AuthenticationFlowException(AuthenticationFlowError.CREDENTIAL_SETUP_REQUIRED);
+                }
+            }
+        }
+        logger.debugv("invoke authenticator.authenticate: {0}", factory.getId());
+        authenticator.authenticate(context);
+        return processResult(context, false);
+    }
+
+    /**
+     * This method creates the list of authenticators that is presented to the user. For a required execution, this is
+     * only the credentials associated to the authenticator, and for an alternative execution, this is all other alternative
+     * executions in the flow, including the credentials.
+     *
+     * In both cases, the credentials take precedence, with the order selected by the user (or his administrator).
+     * @param model The current execution model
+     * @return an ordered list of the authentication selection options to present the user.
+     */
+    private List<AuthenticationSelectionOption> createAuthenticationSelectionList(AuthenticationExecutionModel model) {
+        List<AuthenticationSelectionOption> authenticationSelectionList = new ArrayList<>();
+        if (processor.getAuthenticationSession() != null) {
+            Map<String, AuthenticationExecutionModel> typeAuthExecMap = new HashMap<>();
+            List<AuthenticationExecutionModel> nonCredentialExecutions = new ArrayList<>();
+            if (model.isAlternative()) {
+                //get all alternative executions to be able to list their credentials
+                List<AuthenticationExecutionModel> alternativeExecutions = processor.getRealm().getAuthenticationExecutions(model.getParentFlow())
+                        .stream().filter(AuthenticationExecutionModel::isAlternative).collect(Collectors.toList());
+                for (AuthenticationExecutionModel execution : alternativeExecutions) {
+                    if (!execution.isAuthenticatorFlow()) {
+                        Authenticator localAuthenticator = processor.getSession().getProvider(Authenticator.class, execution.getAuthenticator());
+                        if (!(localAuthenticator instanceof CredentialValidator)) {
+                            nonCredentialExecutions.add(execution);
                             continue;
-                        } else {
-                            throw new AuthenticationFlowException(AuthenticationFlowError.CREDENTIAL_SETUP_REQUIRED);
                         }
-                    } else if (model.isOptional()) {
-                        processor.getAuthenticationSession().setExecutionStatus(model.getId(), AuthenticationSessionModel.ExecutionStatus.SKIPPED);
-                        continue;
+                        CredentialValidator<?> cv = (CredentialValidator<?>) localAuthenticator;
+                        typeAuthExecMap.put(cv.getType(processor.getSession()), execution);
+                    } else {
+                        nonCredentialExecutions.add(execution);
+                    }
+                }
+            } else if (model.isRequired() && ! model.isAuthenticatorFlow()) {
+                //only get current credentials
+                Authenticator authenticator = processor.getSession().getProvider(Authenticator.class, model.getAuthenticator());
+                if (authenticator instanceof CredentialValidator) {
+                    typeAuthExecMap.put(((CredentialValidator<?>) authenticator).getType(processor.getSession()), model);
+                }
+            }
+            //add credential authenticators in order
+            if (processor.getAuthenticationSession().getAuthenticatedUser() != null) {
+                List<CredentialModel> credentials = processor.getSession().userCredentialManager()
+                        .getStoredCredentials(processor.getRealm(), processor.getAuthenticationSession().getAuthenticatedUser())
+                        .stream()
+                        .filter(credential -> typeAuthExecMap.containsKey(credential.getType()))
+                        .collect(Collectors.toList());
+
+                MultivaluedMap<String, AuthenticationSelectionOption> countAuthSelections = new MultivaluedHashMap<>();
+
+                for (CredentialModel credential : credentials) {
+                    AuthenticationSelectionOption authSel = new AuthenticationSelectionOption(typeAuthExecMap.get(credential.getType()), credential);
+                    authenticationSelectionList.add(authSel);
+                    countAuthSelections.add(credential.getType(), authSel);
+                }
+                for(Entry<String, List<AuthenticationSelectionOption>> entry : countAuthSelections.entrySet()) {
+                    if (entry.getValue().size() == 1) {
+                        entry.getValue().get(0).setShowCredentialName(false);
                     }
                 }
+                //don't show credential type if there's only a single type in the list
+                if (countAuthSelections.keySet().size() == 1 && nonCredentialExecutions.isEmpty()) {
+                    for (AuthenticationSelectionOption so : authenticationSelectionList) {
+                        so.setShowCredentialType(false);
+                    }
+                }
+            }
+            //add all other authenticators (including flows)
+            for (AuthenticationExecutionModel exec : nonCredentialExecutions) {
+                if (exec.isAuthenticatorFlow()) {
+                    authenticationSelectionList.add(new AuthenticationSelectionOption(exec,
+                            processor.getRealm().getAuthenticationFlowById(exec.getFlowId())));
+                } else {
+                    authenticationSelectionList.add(new AuthenticationSelectionOption(exec));
+                }
             }
-            // skip if action as successful already
-//            Response redirect = processor.checkWasSuccessfulBrowserAction();
-//            if (redirect != null) return redirect;
-
-            AuthenticationProcessor.Result context = processor.createAuthenticatorContext(model, authenticator, executions);
-            logger.debugv("invoke authenticator.authenticate: {0}", factory.getId());
-            authenticator.authenticate(context);
-            Response response = processResult(context, false);
-            if (response != null) return response;
         }
-        return null;
+        return authenticationSelectionList;
     }
 
 
@@ -233,7 +445,6 @@ public class DefaultAuthenticationFlow implements AuthenticationFlow {
             case SUCCESS:
                 logger.debugv("authenticator SUCCESS: {0}", execution.getAuthenticator());
                 processor.getAuthenticationSession().setExecutionStatus(execution.getId(), AuthenticationSessionModel.ExecutionStatus.SUCCESS);
-                if (execution.isAlternative()) alternativeSuccessful = true;
                 return null;
             case FAILED:
                 logger.debugv("authenticator FAILED: {0}", execution.getAuthenticator());
@@ -248,26 +459,9 @@ public class DefaultAuthenticationFlow implements AuthenticationFlow {
                 processor.getAuthenticationSession().setAuthNote(AuthenticationProcessor.CURRENT_AUTHENTICATION_EXECUTION, execution.getId());
                 throw new ForkFlowException(result.getSuccessMessage(), result.getErrorMessage());
             case FORCE_CHALLENGE:
+            case CHALLENGE:
                 processor.getAuthenticationSession().setExecutionStatus(execution.getId(), AuthenticationSessionModel.ExecutionStatus.CHALLENGED);
                 return sendChallenge(result, execution);
-            case CHALLENGE:
-                logger.debugv("authenticator CHALLENGE: {0}", execution.getAuthenticator());
-                if (execution.isRequired()) {
-                    processor.getAuthenticationSession().setExecutionStatus(execution.getId(), AuthenticationSessionModel.ExecutionStatus.CHALLENGED);
-                    return sendChallenge(result, execution);
-                }
-                UserModel authenticatedUser = processor.getAuthenticationSession().getAuthenticatedUser();
-                if (execution.isOptional() && authenticatedUser != null && result.getAuthenticator().configuredFor(processor.getSession(), processor.getRealm(), authenticatedUser)) {
-                    processor.getAuthenticationSession().setExecutionStatus(execution.getId(), AuthenticationSessionModel.ExecutionStatus.CHALLENGED);
-                    return sendChallenge(result, execution);
-                }
-                if (execution.isAlternative()) {
-                    alternativeChallenge = result.getChallenge();
-                    challengedAlternativeExecution = execution;
-                } else {
-                    processor.getAuthenticationSession().setExecutionStatus(execution.getId(), AuthenticationSessionModel.ExecutionStatus.SKIPPED);
-                }
-                return null;
             case FAILURE_CHALLENGE:
                 logger.debugv("authenticator FAILURE_CHALLENGE: {0}", execution.getAuthenticator());
                 processor.logFailure();
@@ -295,5 +489,8 @@ public class DefaultAuthenticationFlow implements AuthenticationFlow {
         return result.getChallenge();
     }
 
-
+    @Override
+    public boolean isSuccessful() {
+        return successful;
+    }
 }
diff --git a/services/src/main/java/org/keycloak/authentication/FormAuthenticationFlow.java b/services/src/main/java/org/keycloak/authentication/FormAuthenticationFlow.java
index f1cdcda5f5..52f4b32390 100755
--- a/services/src/main/java/org/keycloak/authentication/FormAuthenticationFlow.java
+++ b/services/src/main/java/org/keycloak/authentication/FormAuthenticationFlow.java
@@ -18,7 +18,6 @@
 package org.keycloak.authentication;
 
 import org.jboss.resteasy.spi.HttpRequest;
-import org.keycloak.OAuth2Constants;
 import org.keycloak.common.ClientConnection;
 import org.keycloak.events.EventBuilder;
 import org.keycloak.forms.login.LoginFormsProvider;
@@ -300,4 +299,9 @@ public class FormAuthenticationFlow implements AuthenticationFlow {
         FormContext context = new FormContextImpl(formExecution);
         return formAuthenticator.render(context, form);
     }
+
+    @Override
+    public boolean isSuccessful() {
+        return false;
+    }
 }
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpAutoLinkAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpAutoLinkAuthenticatorFactory.java
index 1d12caf439..102938ab16 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpAutoLinkAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpAutoLinkAuthenticatorFactory.java
@@ -68,10 +68,6 @@ public class IdpAutoLinkAuthenticatorFactory implements AuthenticatorFactory {
         return false;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.DISABLED};
 
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpConfirmLinkAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpConfirmLinkAuthenticatorFactory.java
index ca94180e30..9925e8357a 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpConfirmLinkAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpConfirmLinkAuthenticatorFactory.java
@@ -70,9 +70,6 @@ public class IdpConfirmLinkAuthenticatorFactory implements AuthenticatorFactory
         return false;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.DISABLED};
 
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpCreateUserIfUniqueAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpCreateUserIfUniqueAuthenticator.java
index 302cccaf8e..e25c5908af 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpCreateUserIfUniqueAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpCreateUserIfUniqueAuthenticator.java
@@ -99,8 +99,11 @@ public class IdpCreateUserIfUniqueAuthenticator extends AbstractIdpAuthenticator
 
             // Set duplicated user, so next authenticators can deal with it
             context.getAuthenticationSession().setAuthNote(EXISTING_USER_INFO, duplication.serialize());
+            context.attempted();
 
-            Response challengeResponse = context.form()
+            //Returning a challenge doesn't make much sense with the new rules. There is no reason for this authenticator to be selectable,
+            //and the flow should proceed to an other authenticator if this one is not valid.
+            /*Response challengeResponse = context.form()
                     .setError(Messages.FEDERATED_IDENTITY_EXISTS, duplication.getDuplicateAttributeName(), duplication.getDuplicateAttributeValue())
                     .createErrorPage(Response.Status.CONFLICT);
             context.challenge(challengeResponse);
@@ -112,7 +115,7 @@ public class IdpCreateUserIfUniqueAuthenticator extends AbstractIdpAuthenticator
                         .removeDetail(Details.AUTH_METHOD)
                         .removeDetail(Details.AUTH_TYPE)
                         .error(Errors.FEDERATED_IDENTITY_EXISTS);
-            }
+            }*/
         }
     }
 
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpCreateUserIfUniqueAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpCreateUserIfUniqueAuthenticatorFactory.java
index c4e968dded..adf7060a29 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpCreateUserIfUniqueAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpCreateUserIfUniqueAuthenticatorFactory.java
@@ -73,11 +73,6 @@ public class IdpCreateUserIfUniqueAuthenticatorFactory implements AuthenticatorF
         return true;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.DISABLED};
-
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
         return REQUIREMENT_CHOICES;
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpEmailVerificationAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpEmailVerificationAuthenticatorFactory.java
index ef14089040..8fcbcf4249 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpEmailVerificationAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpEmailVerificationAuthenticatorFactory.java
@@ -70,10 +70,6 @@ public class IdpEmailVerificationAuthenticatorFactory implements AuthenticatorFa
         return false;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.DISABLED};
 
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpReviewProfileAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpReviewProfileAuthenticatorFactory.java
index b293b716a3..d5b48b2494 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpReviewProfileAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpReviewProfileAuthenticatorFactory.java
@@ -75,10 +75,6 @@ public class IdpReviewProfileAuthenticatorFactory implements AuthenticatorFactor
         return true;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.DISABLED};
-
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
         return REQUIREMENT_CHOICES;
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpUsernamePasswordForm.java b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpUsernamePasswordForm.java
index 0ea8157d6b..966246c7e8 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpUsernamePasswordForm.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/broker/IdpUsernamePasswordForm.java
@@ -43,7 +43,7 @@ public class IdpUsernamePasswordForm extends UsernamePasswordForm {
 
         return setupForm(context, formData, existingUser)
                 .setStatus(Response.Status.OK)
-                .createLogin();
+                .createLoginUsernamePassword();
     }
 
     @Override
@@ -65,6 +65,7 @@ public class IdpUsernamePasswordForm extends UsernamePasswordForm {
 
         formData.add(AuthenticationManager.FORM_USERNAME, existingUser.getUsername());
         return context.form()
+                .setAuthContext(context)
                 .setFormData(formData)
                 .setAttribute(LoginFormsProvider.USERNAME_EDIT_DISABLED, true)
                 .setInfo(Messages.FEDERATED_IDENTITY_CONFIRM_REAUTHENTICATE_MESSAGE, existingUser.getUsername(), serializedCtx.getIdentityProviderId());
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/AbstractUsernameFormAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/AbstractUsernameFormAuthenticator.java
index eac2558b0b..e9a39a39b2 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/AbstractUsernameFormAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/AbstractUsernameFormAuthenticator.java
@@ -21,7 +21,6 @@ import org.jboss.logging.Logger;
 import org.keycloak.authentication.AbstractFormAuthenticator;
 import org.keycloak.authentication.AuthenticationFlowContext;
 import org.keycloak.authentication.AuthenticationFlowError;
-import org.keycloak.credential.CredentialInput;
 import org.keycloak.credential.hash.PasswordHashProvider;
 import org.keycloak.events.Details;
 import org.keycloak.events.Errors;
@@ -38,8 +37,6 @@ import org.keycloak.services.messages.Messages;
 
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.Response;
-import java.util.LinkedList;
-import java.util.List;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
@@ -58,14 +55,15 @@ public abstract class AbstractUsernameFormAuthenticator extends AbstractFormAuth
     }
 
     protected Response challenge(AuthenticationFlowContext context, String error) {
-        LoginFormsProvider form = context.form();
+        LoginFormsProvider form = context.form()
+                .setAuthContext(context)
+                .setExecution(context.getExecution().getId());
         if (error != null) form.setError(error);
-
         return createLoginForm(form);
     }
 
     protected Response createLoginForm(LoginFormsProvider form) {
-        return form.createLogin();
+        return form.createLoginUsernamePassword();
     }
 
     protected String tempDisabledError() {
@@ -74,8 +72,8 @@ public abstract class AbstractUsernameFormAuthenticator extends AbstractFormAuth
 
     protected Response setDuplicateUserChallenge(AuthenticationFlowContext context, String eventError, String loginFormError, AuthenticationFlowError authenticatorError) {
         context.getEvent().error(eventError);
-        Response challengeResponse = context.form()
-                .setError(loginFormError).createLogin();
+        Response challengeResponse = context.form().setAuthContext(context)
+                .setError(loginFormError).createLoginUsernamePassword();
         context.failureChallenge(authenticatorError, challengeResponse);
         return challengeResponse;
     }
@@ -114,13 +112,12 @@ public abstract class AbstractUsernameFormAuthenticator extends AbstractFormAuth
         return false;
     }
 
+
     public boolean enabledUser(AuthenticationFlowContext context, UserModel user) {
         if (!user.isEnabled()) {
             context.getEvent().user(user);
             context.getEvent().error(Errors.USER_DISABLED);
             Response challengeResponse = challenge(context, Messages.ACCOUNT_DISABLED);
-            // this is not a failure so don't call failureChallenge.
-            //context.failureChallenge(AuthenticationFlowError.USER_DISABLED, challengeResponse);
             context.forceChallenge(challengeResponse);
             return false;
         }
@@ -128,13 +125,20 @@ public abstract class AbstractUsernameFormAuthenticator extends AbstractFormAuth
         return true;
     }
 
-    public boolean validateUserAndPassword(AuthenticationFlowContext context, MultivaluedMap<String, String> inputData) {
+    public boolean validateUserAndPassword(AuthenticationFlowContext context, MultivaluedMap<String, String> inputData)  {
+        UserModel user = validateUser(context, inputData);
+        return user != null && validatePassword(context, user, inputData) && context.getUser() != null;
+    }
+
+
+    public UserModel validateUser(AuthenticationFlowContext context, MultivaluedMap<String, String> inputData) {
+        context.clearUser();
         String username = inputData.getFirst(AuthenticationManager.FORM_USERNAME);
         if (username == null) {
             context.getEvent().error(Errors.USER_NOT_FOUND);
             Response challengeResponse = challenge(context, Messages.INVALID_USER);
             context.failureChallenge(AuthenticationFlowError.INVALID_USER, challengeResponse);
-            return false;
+            return null;
         }
 
         // remove leading and trailing whitespace
@@ -156,19 +160,11 @@ public abstract class AbstractUsernameFormAuthenticator extends AbstractFormAuth
                 setDuplicateUserChallenge(context, Errors.USERNAME_IN_USE, Messages.USERNAME_EXISTS, AuthenticationFlowError.INVALID_USER);
             }
 
-            return false;
-        }
-
-        if (invalidUser(context, user)) {
-            return false;
-        }
-
-        if (!validatePassword(context, user, inputData)) {
-            return false;
+            return user;
         }
 
-        if (!enabledUser(context, user)) {
-            return false;
+        if (invalidUser(context, user) || !enabledUser(context, user)) {
+            return user;
         }
 
         String rememberMe = inputData.getFirst("rememberMe");
@@ -180,36 +176,40 @@ public abstract class AbstractUsernameFormAuthenticator extends AbstractFormAuth
             context.getAuthenticationSession().removeAuthNote(Details.REMEMBER_ME);
         }
         context.setUser(user);
-        return true;
+        return user;
     }
 
+
     public boolean validatePassword(AuthenticationFlowContext context, UserModel user, MultivaluedMap<String, String> inputData) {
-        List<CredentialInput> credentials = new LinkedList<>();
+        return validatePassword(context, user, inputData, true);
+    }
+
+    public boolean validatePassword(AuthenticationFlowContext context, UserModel user, MultivaluedMap<String, String> inputData, boolean clearUser) {
         String password = inputData.getFirst(CredentialRepresentation.PASSWORD);
-        credentials.add(UserCredentialModel.password(password));
 
         if (isTemporarilyDisabledByBruteForce(context, user)) return false;
 
-        if (password != null && !password.isEmpty() && context.getSession().userCredentialManager().isValid(context.getRealm(), user, credentials)) {
+        if (password != null && !password.isEmpty() && context.getSession().userCredentialManager().isValid(context.getRealm(), user, UserCredentialModel.password(password))) {
             return true;
         } else {
             context.getEvent().user(user);
             context.getEvent().error(Errors.INVALID_USER_CREDENTIALS);
             Response challengeResponse = challenge(context, Messages.INVALID_USER);
             context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, challengeResponse);
-            context.clearUser();
+            if (clearUser) {
+                context.clearUser();
+            }
             return false;
         }
     }
 
+
     protected boolean isTemporarilyDisabledByBruteForce(AuthenticationFlowContext context, UserModel user) {
         if (context.getRealm().isBruteForceProtected()) {
             if (context.getProtector().isTemporarilyDisabled(context.getSession(), context.getRealm(), user)) {
                 context.getEvent().user(user);
                 context.getEvent().error(Errors.USER_TEMPORARILY_DISABLED);
                 Response challengeResponse = challenge(context, tempDisabledError());
-                // this is not a failure so don't call failureChallenge.
-                //context.failureChallenge(AuthenticationFlowError.USER_TEMPORARILY_DISABLED, challengeResponse);
                 context.forceChallenge(challengeResponse);
                 return true;
             }
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/ConditionalOtpFormAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/ConditionalOtpFormAuthenticatorFactory.java
index f04ed0770b..1cc8606049 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/ConditionalOtpFormAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/ConditionalOtpFormAuthenticatorFactory.java
@@ -23,7 +23,7 @@ import org.keycloak.authentication.AuthenticatorFactory;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
-import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
 
 import java.util.List;
@@ -52,11 +52,6 @@ public class ConditionalOtpFormAuthenticatorFactory implements AuthenticatorFact
 
     public static final ConditionalOtpFormAuthenticator SINGLETON = new ConditionalOtpFormAuthenticator();
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.OPTIONAL,
-            AuthenticationExecutionModel.Requirement.DISABLED};
-
     @Override
     public Authenticator create(KeycloakSession session) {
         return SINGLETON;
@@ -84,7 +79,7 @@ public class ConditionalOtpFormAuthenticatorFactory implements AuthenticatorFact
 
     @Override
     public String getReferenceCategory() {
-        return UserCredentialModel.TOTP;
+        return OTPCredentialModel.TYPE;
     }
 
     @Override
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/CookieAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/CookieAuthenticatorFactory.java
index b87dbe9206..c3d100eead 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/CookieAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/CookieAuthenticatorFactory.java
@@ -80,8 +80,6 @@ public class CookieAuthenticatorFactory implements AuthenticatorFactory, Display
         return false;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {AuthenticationExecutionModel.Requirement.ALTERNATIVE, AuthenticationExecutionModel.Requirement.DISABLED};
-
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
         return REQUIREMENT_CHOICES;
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/IdentityProviderAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/IdentityProviderAuthenticatorFactory.java
index b136d33177..28f4947f54 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/IdentityProviderAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/IdentityProviderAuthenticatorFactory.java
@@ -39,7 +39,7 @@ import static org.keycloak.provider.ProviderConfigProperty.STRING_TYPE;
 public class IdentityProviderAuthenticatorFactory implements AuthenticatorFactory, DisplayTypeAuthenticatorFactory {
 
     protected static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE, AuthenticationExecutionModel.Requirement.DISABLED
+            AuthenticationExecutionModel.Requirement.REQUIRED, AuthenticationExecutionModel.Requirement.ALTERNATIVE, AuthenticationExecutionModel.Requirement.DISABLED
     };
 
     protected static final String DEFAULT_PROVIDER = "defaultProvider";
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/OTPFormAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/OTPFormAuthenticator.java
index 14ecef5412..eb7ca0eca3 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/OTPFormAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/OTPFormAuthenticator.java
@@ -20,13 +20,15 @@ package org.keycloak.authentication.authenticators.browser;
 import org.keycloak.authentication.AuthenticationFlowContext;
 import org.keycloak.authentication.AuthenticationFlowError;
 import org.keycloak.authentication.Authenticator;
+import org.keycloak.authentication.CredentialValidator;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.OTPCredentialProvider;
 import org.keycloak.events.Errors;
 import org.keycloak.forms.login.LoginFormsProvider;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
-import org.keycloak.representations.idm.CredentialRepresentation;
 import org.keycloak.services.messages.Messages;
 
 import javax.ws.rs.core.MultivaluedMap;
@@ -36,18 +38,20 @@ import javax.ws.rs.core.Response;
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class OTPFormAuthenticator extends AbstractUsernameFormAuthenticator implements Authenticator {
+public class OTPFormAuthenticator extends AbstractUsernameFormAuthenticator implements Authenticator, CredentialValidator<OTPCredentialProvider> {
     @Override
     public void action(AuthenticationFlowContext context) {
         validateOTP(context);
     }
 
+
     @Override
     public void authenticate(AuthenticationFlowContext context) {
         Response challengeResponse = challenge(context, null);
         context.challenge(challengeResponse);
     }
 
+
     public void validateOTP(AuthenticationFlowContext context) {
         MultivaluedMap<String, String> inputData = context.getHttpRequest().getDecodedFormParameters();
         if (inputData.containsKey("cancel")) {
@@ -55,20 +59,28 @@ public class OTPFormAuthenticator extends AbstractUsernameFormAuthenticator impl
             return;
         }
 
+        String otp = inputData.getFirst("otp");
+        String credentialId = context.getSelectedCredentialId();
+
+        //TODO this is lazy for when there is no clearly defined credentialId available (for example direct grant or console OTP), replace with getting the credential from the name
+        if (credentialId == null || credentialId.isEmpty()) {
+            credentialId = getCredentialProvider(context.getSession()).getPreferredCredential(context.getRealm(), context.getUser()).getId();
+            context.setSelectedCredentialId(credentialId);
+        }
+
         UserModel userModel = context.getUser();
         if (!enabledUser(context, userModel)) {
             // error in context is set in enabledUser/isTemporarilyDisabledByBruteForce
             return;
         }
 
-        String password = inputData.getFirst(CredentialRepresentation.TOTP);
-        if (password == null) {
-            Response challengeResponse = challenge(context, null);
+        if (otp == null) {
+            Response challengeResponse = challenge(context,null);
             context.challenge(challengeResponse);
             return;
         }
-        boolean valid = context.getSession().userCredentialManager().isValid(context.getRealm(), userModel,
-                UserCredentialModel.otp(context.getRealm().getOTPPolicy().getType(), password));
+        boolean valid = getCredentialProvider(context.getSession()).isValid(context.getRealm(),context.getUser(),
+                new UserCredentialModel(credentialId, getCredentialProvider(context.getSession()).getType(), otp));
         if (!valid) {
             context.getEvent().user(userModel)
                     .error(Errors.INVALID_USER_CREDENTIALS);
@@ -96,7 +108,7 @@ public class OTPFormAuthenticator extends AbstractUsernameFormAuthenticator impl
 
     @Override
     public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
-        return session.userCredentialManager().isConfiguredFor(realm, user, realm.getOTPPolicy().getType());
+        return getCredentialProvider(session).isConfiguredFor(realm, user);
     }
 
     @Override
@@ -104,11 +116,16 @@ public class OTPFormAuthenticator extends AbstractUsernameFormAuthenticator impl
         if (!user.getRequiredActions().contains(UserModel.RequiredAction.CONFIGURE_TOTP.name())) {
             user.addRequiredAction(UserModel.RequiredAction.CONFIGURE_TOTP.name());
         }
-
     }
 
     @Override
     public void close() {
 
     }
+
+    @Override
+    public OTPCredentialProvider getCredentialProvider(KeycloakSession session) {
+        return (OTPCredentialProvider)session.getProvider(CredentialProvider.class, "keycloak-otp");
+    }
+
 }
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/OTPFormAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/OTPFormAuthenticatorFactory.java
index d71659ce0b..8f3a4e7d75 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/OTPFormAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/OTPFormAuthenticatorFactory.java
@@ -26,7 +26,7 @@ import org.keycloak.authentication.authenticators.console.ConsoleOTPFormAuthenti
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
-import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
 
 import java.util.List;
@@ -74,7 +74,7 @@ public class OTPFormAuthenticatorFactory implements AuthenticatorFactory, Displa
 
     @Override
     public String getReferenceCategory() {
-        return UserCredentialModel.TOTP;
+        return OTPCredentialModel.TYPE;
     }
 
     @Override
@@ -87,11 +87,6 @@ public class OTPFormAuthenticatorFactory implements AuthenticatorFactory, Displa
         return true;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.OPTIONAL,
-            AuthenticationExecutionModel.Requirement.DISABLED};
-
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
         return REQUIREMENT_CHOICES;
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/PasswordForm.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/PasswordForm.java
new file mode 100755
index 0000000000..b40c5d0508
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/PasswordForm.java
@@ -0,0 +1,47 @@
+/*
+ * Copyright 2016 Red Hat, Inc. and/or its affiliates
+ * and other contributors as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.keycloak.authentication.authenticators.browser;
+
+import org.keycloak.authentication.AuthenticationFlowContext;
+import org.keycloak.forms.login.LoginFormsProvider;
+
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.Response;
+
+public class PasswordForm extends UsernamePasswordForm {
+
+    protected boolean validateForm(AuthenticationFlowContext context, MultivaluedMap<String, String> formData) {
+        return validatePassword(context, context.getUser(), formData, false);
+    }
+
+    @Override
+    public void authenticate(AuthenticationFlowContext context) {
+        Response challengeResponse = context.form().setAuthContext(context).createLoginPassword();
+        context.challenge(challengeResponse);
+    }
+
+    @Override
+    public boolean requiresUser() {
+        return true;
+    }
+
+    @Override
+    protected Response createLoginForm(LoginFormsProvider form) {
+        return form.createLoginPassword();
+    }
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/PasswordFormFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/PasswordFormFactory.java
new file mode 100755
index 0000000000..c314f379fa
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/PasswordFormFactory.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2016 Red Hat, Inc. and/or its affiliates
+ * and other contributors as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.keycloak.authentication.authenticators.browser;
+
+import org.keycloak.Config;
+import org.keycloak.OAuth2Constants;
+import org.keycloak.authentication.Authenticator;
+import org.keycloak.authentication.AuthenticatorFactory;
+import org.keycloak.authentication.DisplayTypeAuthenticatorFactory;
+import org.keycloak.authentication.authenticators.console.ConsolePasswordAuthenticator;
+import org.keycloak.authentication.authenticators.console.ConsoleUsernamePasswordAuthenticator;
+import org.keycloak.models.AuthenticationExecutionModel;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.KeycloakSessionFactory;
+import org.keycloak.models.credential.PasswordCredentialModel;
+import org.keycloak.provider.ProviderConfigProperty;
+
+import java.util.List;
+
+/**
+ * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class PasswordFormFactory implements AuthenticatorFactory, DisplayTypeAuthenticatorFactory {
+
+    public static final String PROVIDER_ID = "auth-password-form";
+    public static final PasswordForm SINGLETON = new PasswordForm();
+
+    @Override
+    public Authenticator create(KeycloakSession session) {
+        return SINGLETON;
+    }
+
+    @Override
+    public Authenticator createDisplay(KeycloakSession session, String displayType) {
+        if (displayType == null) return SINGLETON;
+        if (!OAuth2Constants.DISPLAY_CONSOLE.equalsIgnoreCase(displayType)) return null;
+        return ConsolePasswordAuthenticator.SINGLETON;
+    }
+
+    @Override
+    public void init(Config.Scope config) {
+
+    }
+
+    @Override
+    public void postInit(KeycloakSessionFactory factory) {
+
+    }
+
+    @Override
+    public void close() {
+
+    }
+
+    @Override
+    public String getId() {
+        return PROVIDER_ID;
+    }
+
+    @Override
+    public String getReferenceCategory() {
+        return PasswordCredentialModel.TYPE;
+    }
+
+    @Override
+    public boolean isConfigurable() {
+        return false;
+    }
+
+    @Override
+    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
+        return REQUIREMENT_CHOICES;
+    }
+
+    @Override
+    public String getDisplayType() {
+        return "Password Form";
+    }
+
+    @Override
+    public String getHelpText() {
+        return "Validates a password from login form.";
+    }
+
+    @Override
+    public List<ProviderConfigProperty> getConfigProperties() {
+        return null;
+    }
+
+    @Override
+    public boolean isUserSetupAllowed() {
+        return false;
+    }
+
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/ScriptBasedAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/ScriptBasedAuthenticatorFactory.java
index f5fabe25bb..ec3d1131ea 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/ScriptBasedAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/ScriptBasedAuthenticatorFactory.java
@@ -51,7 +51,7 @@ public class ScriptBasedAuthenticatorFactory implements AuthenticatorFactory, En
 
     static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
             AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.OPTIONAL,
+            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
             AuthenticationExecutionModel.Requirement.DISABLED};
 
     static final ScriptBasedAuthenticator SINGLETON = new ScriptBasedAuthenticator();
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/SpnegoAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/SpnegoAuthenticatorFactory.java
index ae5dd0c297..dccc5ae44b 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/SpnegoAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/SpnegoAuthenticatorFactory.java
@@ -76,11 +76,6 @@ public class SpnegoAuthenticatorFactory implements AuthenticatorFactory, Display
         return false;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.DISABLED};
-
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
         return REQUIREMENT_CHOICES;
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernameForm.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernameForm.java
new file mode 100755
index 0000000000..94b2d66dc8
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernameForm.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2016 Red Hat, Inc. and/or its affiliates
+ * and other contributors as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.keycloak.authentication.authenticators.browser;
+
+import org.keycloak.authentication.AuthenticationFlowContext;
+import org.keycloak.forms.login.LoginFormsProvider;
+
+import javax.ws.rs.core.MultivaluedMap;
+import javax.ws.rs.core.Response;
+
+public final class UsernameForm extends UsernamePasswordForm {
+
+    @Override
+    protected boolean validateForm(AuthenticationFlowContext context, MultivaluedMap<String, String> formData) {
+        return validateUser(context, formData) != null;
+    }
+
+    @Override
+    protected Response challenge(AuthenticationFlowContext context, MultivaluedMap<String, String> formData) {
+        LoginFormsProvider forms = context.form().setAuthContext(context);
+
+        if (!formData.isEmpty()) forms.setFormData(formData);
+
+        return forms.createLoginUsername();
+    }
+
+    @Override
+    protected Response createLoginForm(LoginFormsProvider form) {
+        return form.createLoginUsername();
+    }
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernameFormFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernameFormFactory.java
new file mode 100755
index 0000000000..b6e0b49da5
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernameFormFactory.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright 2016 Red Hat, Inc. and/or its affiliates
+ * and other contributors as indicated by the @author tags.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package org.keycloak.authentication.authenticators.browser;
+
+import org.keycloak.Config;
+import org.keycloak.OAuth2Constants;
+import org.keycloak.authentication.Authenticator;
+import org.keycloak.authentication.AuthenticatorFactory;
+import org.keycloak.authentication.DisplayTypeAuthenticatorFactory;
+import org.keycloak.authentication.authenticators.console.ConsoleUsernameAuthenticator;
+import org.keycloak.authentication.authenticators.console.ConsoleUsernamePasswordAuthenticator;
+import org.keycloak.models.AuthenticationExecutionModel;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.KeycloakSessionFactory;
+import org.keycloak.models.credential.PasswordCredentialModel;
+import org.keycloak.provider.ProviderConfigProperty;
+
+import java.util.List;
+
+/**
+ * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
+ * @version $Revision: 1 $
+ */
+public class UsernameFormFactory implements AuthenticatorFactory, DisplayTypeAuthenticatorFactory {
+
+    public static final String PROVIDER_ID = "auth-username-form";
+    public static final UsernameForm SINGLETON = new UsernameForm();
+
+    @Override
+    public Authenticator create(KeycloakSession session) {
+        return SINGLETON;
+    }
+
+    @Override
+    public Authenticator createDisplay(KeycloakSession session, String displayType) {
+        if (displayType == null) return SINGLETON;
+        if (!OAuth2Constants.DISPLAY_CONSOLE.equalsIgnoreCase(displayType)) return null;
+        return ConsoleUsernameAuthenticator.SINGLETON;
+    }
+
+    @Override
+    public void init(Config.Scope config) {
+
+    }
+
+    @Override
+    public void postInit(KeycloakSessionFactory factory) {
+
+    }
+
+    @Override
+    public void close() {
+
+    }
+
+    @Override
+    public String getId() {
+        return PROVIDER_ID;
+    }
+
+    @Override
+    public String getReferenceCategory() {
+        return PasswordCredentialModel.TYPE;
+    }
+
+    @Override
+    public boolean isConfigurable() {
+        return false;
+    }
+    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
+            AuthenticationExecutionModel.Requirement.REQUIRED
+    };
+
+    @Override
+    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
+        return REQUIREMENT_CHOICES;
+    }
+
+    @Override
+    public String getDisplayType() {
+        return "Username Form";
+    }
+
+    @Override
+    public String getHelpText() {
+        return "Selects a user from his username.";
+    }
+
+    @Override
+    public List<ProviderConfigProperty> getConfigProperties() {
+        return null;
+    }
+
+    @Override
+    public boolean isUserSetupAllowed() {
+        return false;
+    }
+
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernamePasswordForm.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernamePasswordForm.java
index 43383a0e30..37f5c60848 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernamePasswordForm.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernamePasswordForm.java
@@ -20,6 +20,9 @@ package org.keycloak.authentication.authenticators.browser;
 import org.jboss.resteasy.specimpl.MultivaluedMapImpl;
 import org.keycloak.authentication.AuthenticationFlowContext;
 import org.keycloak.authentication.Authenticator;
+import org.keycloak.authentication.CredentialValidator;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.PasswordCredentialProvider;
 import org.keycloak.forms.login.LoginFormsProvider;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
@@ -35,7 +38,7 @@ import javax.ws.rs.core.Response;
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class UsernamePasswordForm extends AbstractUsernameFormAuthenticator implements Authenticator {
+public class UsernamePasswordForm extends AbstractUsernameFormAuthenticator implements Authenticator, CredentialValidator<PasswordCredentialProvider> {
     protected static ServicesLogger log = ServicesLogger.LOGGER;
 
     @Override
@@ -80,11 +83,11 @@ public class UsernamePasswordForm extends AbstractUsernameFormAuthenticator impl
     }
 
     protected Response challenge(AuthenticationFlowContext context, MultivaluedMap<String, String> formData) {
-        LoginFormsProvider forms = context.form();
+        LoginFormsProvider forms = context.form().setAuthContext(context);
 
         if (formData.size() > 0) forms.setFormData(formData);
 
-        return forms.createLogin();
+        return forms.createLoginUsernamePassword();
     }
 
 
@@ -103,4 +106,9 @@ public class UsernamePasswordForm extends AbstractUsernameFormAuthenticator impl
     public void close() {
 
     }
+
+    @Override
+    public PasswordCredentialProvider getCredentialProvider(KeycloakSession session) {
+        return (PasswordCredentialProvider)session.getProvider(CredentialProvider.class, "keycloak-password");
+    }
 }
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernamePasswordFormFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernamePasswordFormFactory.java
index fe42f48e21..d7fc8393ac 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernamePasswordFormFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/browser/UsernamePasswordFormFactory.java
@@ -27,6 +27,7 @@ import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
 import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
 
 import java.util.List;
@@ -74,7 +75,7 @@ public class UsernamePasswordFormFactory implements AuthenticatorFactory, Displa
 
     @Override
     public String getReferenceCategory() {
-        return UserCredentialModel.PASSWORD;
+        return PasswordCredentialModel.TYPE;
     }
 
     @Override
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthAuthenticator.java
index 57fa40e1fb..fe7a91c089 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthAuthenticator.java
@@ -49,14 +49,14 @@ public class BasicAuthAuthenticator extends AbstractUsernameFormAuthenticator im
         String authorizationHeader = getAuthorizationHeader(context);
 
         if (authorizationHeader == null) {
-            context.challenge(challenge(context, null));
+            context.attempted();
             return;
         }
 
         String[] challenge = getChallenge(authorizationHeader);
 
         if (challenge == null) {
-            context.challenge(challenge(context, null));
+            context.attempted();
             return;
         }
 
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthAuthenticatorFactory.java
index b4540b7939..db00134ad4 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthAuthenticatorFactory.java
@@ -22,7 +22,7 @@ import org.keycloak.authentication.AuthenticatorFactory;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
-import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
 
 import java.util.Collections;
@@ -64,16 +64,13 @@ public class BasicAuthAuthenticatorFactory implements AuthenticatorFactory {
 
     @Override
     public String getReferenceCategory() {
-        return UserCredentialModel.PASSWORD;
+        return PasswordCredentialModel.TYPE;
     }
 
     @Override
     public boolean isConfigurable() {
         return false;
     }
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED, AuthenticationExecutionModel.Requirement.OPTIONAL, AuthenticationExecutionModel.Requirement.DISABLED
-    };
 
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthOTPAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthOTPAuthenticator.java
index 6ad463d4a5..d7a4409092 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthOTPAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthOTPAuthenticator.java
@@ -19,14 +19,16 @@ package org.keycloak.authentication.authenticators.challenge;
 import org.keycloak.authentication.AuthenticationFlowContext;
 import org.keycloak.authentication.AuthenticationFlowError;
 import org.keycloak.authentication.Authenticator;
-import org.keycloak.authentication.authenticators.browser.AbstractUsernameFormAuthenticator;
-import org.keycloak.events.Details;
+import org.keycloak.authentication.CredentialValidator;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.OTPCredentialProvider;
 import org.keycloak.events.Errors;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.OTPPolicy;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.services.messages.Messages;
 
 import javax.ws.rs.core.Response;
@@ -35,7 +37,7 @@ import javax.ws.rs.core.Response;
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class BasicAuthOTPAuthenticator extends BasicAuthAuthenticator implements Authenticator {
+public class BasicAuthOTPAuthenticator extends BasicAuthAuthenticator implements Authenticator, CredentialValidator<OTPCredentialProvider> {
 
     @Override
     protected boolean onAuthenticate(AuthenticationFlowContext context, String[] challenge) {
@@ -62,13 +64,14 @@ public class BasicAuthOTPAuthenticator extends BasicAuthAuthenticator implements
     }
 
     private boolean checkOtp(AuthenticationFlowContext context, String otp) {
-        boolean valid = context.getSession().userCredentialManager().isValid(context.getRealm(), context.getUser(),
-                UserCredentialModel.otp(context.getRealm().getOTPPolicy().getType(), otp));
+        OTPCredentialModel preferredCredential = getCredentialProvider(context.getSession())
+                .getPreferredCredential(context.getRealm(), context.getUser());
+        boolean valid = getCredentialProvider(context.getSession()).isValid(context.getRealm(), context.getUser(),
+                new UserCredentialModel(preferredCredential.getId(), getCredentialProvider(context.getSession()).getType(), otp));
 
         if (!valid) {
             context.getEvent().user(context.getUser()).error(Errors.INVALID_USER_CREDENTIALS);
-            Response challengeResponse = challenge(context, Messages.INVALID_TOTP);
-            context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, challengeResponse);
+            context.attempted();
             return false;
         }
 
@@ -77,7 +80,12 @@ public class BasicAuthOTPAuthenticator extends BasicAuthAuthenticator implements
 
     @Override
     public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
-        return session.userCredentialManager().isConfiguredFor(realm, user, realm.getOTPPolicy().getType());
+        return getCredentialProvider(session).isConfiguredFor(realm, user);
+    }
+
+    @Override
+    public OTPCredentialProvider getCredentialProvider(KeycloakSession session) {
+        return (OTPCredentialProvider)session.getProvider(CredentialProvider.class, "keycloak-otp");
     }
 }
 
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthOTPAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthOTPAuthenticatorFactory.java
index 580e1e21b6..95326724e0 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthOTPAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/BasicAuthOTPAuthenticatorFactory.java
@@ -25,7 +25,7 @@ import org.keycloak.authentication.AuthenticatorFactory;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
-import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
 
 /**
@@ -64,16 +64,13 @@ public class BasicAuthOTPAuthenticatorFactory implements AuthenticatorFactory {
 
     @Override
     public String getReferenceCategory() {
-        return UserCredentialModel.PASSWORD;
+        return PasswordCredentialModel.TYPE;
     }
 
     @Override
     public boolean isConfigurable() {
         return false;
     }
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED, AuthenticationExecutionModel.Requirement.OPTIONAL, AuthenticationExecutionModel.Requirement.DISABLED
-    };
 
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/NoCookieFlowRedirectAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/NoCookieFlowRedirectAuthenticatorFactory.java
index 452df58bdc..843fd7fcf6 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/challenge/NoCookieFlowRedirectAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/challenge/NoCookieFlowRedirectAuthenticatorFactory.java
@@ -26,6 +26,7 @@ import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
 import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
 
 /**
@@ -64,7 +65,7 @@ public class NoCookieFlowRedirectAuthenticatorFactory implements AuthenticatorFa
 
     @Override
     public String getReferenceCategory() {
-        return UserCredentialModel.PASSWORD;
+        return PasswordCredentialModel.TYPE;
     }
 
     @Override
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/cli/CliUsernamePasswordAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/cli/CliUsernamePasswordAuthenticatorFactory.java
index cce13c0ed9..dc860ba4c2 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/cli/CliUsernamePasswordAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/cli/CliUsernamePasswordAuthenticatorFactory.java
@@ -25,6 +25,7 @@ import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
 import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
 
 import java.util.List;
@@ -65,7 +66,7 @@ public class CliUsernamePasswordAuthenticatorFactory implements AuthenticatorFac
 
     @Override
     public String getReferenceCategory() {
-        return UserCredentialModel.PASSWORD;
+        return PasswordCredentialModel.TYPE;
     }
 
     @Override
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/client/ClientIdAndSecretAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/client/ClientIdAndSecretAuthenticator.java
index f268f3673f..e07d916365 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/client/ClientIdAndSecretAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/client/ClientIdAndSecretAuthenticator.java
@@ -50,11 +50,6 @@ public class ClientIdAndSecretAuthenticator extends AbstractClientAuthenticator
 
     public static final String PROVIDER_ID = "client-secret";
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.DISABLED
-    };
-
     @Override
     public void authenticateClient(ClientAuthenticationFlowContext context) {
         String client_id = null;
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/client/JWTClientAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/client/JWTClientAuthenticator.java
index 4a7d89cd49..506fc0a330 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/client/JWTClientAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/client/JWTClientAuthenticator.java
@@ -67,10 +67,6 @@ public class JWTClientAuthenticator extends AbstractClientAuthenticator {
     public static final String ATTR_PREFIX = "jwt.credential";
     public static final String CERTIFICATE_ATTR = "jwt.credential.certificate";
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.DISABLED
-    };
 
     @Override
     public void authenticateClient(ClientAuthenticationFlowContext context) {
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/client/JWTClientSecretAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/client/JWTClientSecretAuthenticator.java
index bf4fbf36d8..5c7eb7b920 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/client/JWTClientSecretAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/client/JWTClientSecretAuthenticator.java
@@ -1,5 +1,6 @@
 package org.keycloak.authentication.authenticators.client;
 
+import java.nio.charset.StandardCharsets;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
@@ -21,7 +22,6 @@ import org.keycloak.authentication.ClientAuthenticationFlowContext;
 import org.keycloak.common.util.Time;
 import org.keycloak.jose.jws.JWSInput;
 import org.keycloak.jose.jws.crypto.HMACProvider;
-import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.AuthenticationExecutionModel.Requirement;
 import org.keycloak.models.SingleUseTokenStoreProvider;
 import org.keycloak.protocol.oidc.OIDCLoginProtocol;
@@ -48,11 +48,7 @@ public class JWTClientSecretAuthenticator extends AbstractClientAuthenticator {
 	private static final Logger logger = Logger.getLogger(JWTClientSecretAuthenticator.class);
 	
     public static final String PROVIDER_ID = "client-secret-jwt";
-    
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.DISABLED
-    };
+
 
     @Override
     public void authenticateClient(ClientAuthenticationFlowContext context) {
@@ -114,7 +110,7 @@ public class JWTClientSecretAuthenticator extends AbstractClientAuthenticator {
             // According to <a href="http://openid.net/specs/openid-connect-core-1_0.html#ClientAuthentication">OIDC's client authentication spec</a>,
             // The HMAC (Hash-based Message Authentication Code) is calculated using the octets of the UTF-8 representation of the client_secret as the shared key. 
             // Use "HmacSHA256" consulting <a href="https://docs.oracle.com/javase/jp/8/docs/api/javax/crypto/Mac.html">java8 api</a>.
-            SecretKey clientSecret = new SecretKeySpec(clientSecretString.getBytes("UTF-8"), "HmacSHA256");
+            SecretKey clientSecret = new SecretKeySpec(clientSecretString.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
 
             boolean signatureValid;
             try {
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/client/X509ClientAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/client/X509ClientAuthenticator.java
index 324f806ae9..b60a4b484b 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/client/X509ClientAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/client/X509ClientAuthenticator.java
@@ -1,16 +1,12 @@
 package org.keycloak.authentication.authenticators.client;
 
-import org.apache.commons.codec.binary.StringUtils;
-import org.keycloak.Config;
 import org.keycloak.OAuth2Constants;
 import org.keycloak.authentication.AuthenticationFlowError;
 import org.keycloak.authentication.ClientAuthenticationFlowContext;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.ClientModel;
-import org.keycloak.models.KeycloakSessionFactory;
 import org.keycloak.protocol.oidc.OIDCLoginProtocol;
 import org.keycloak.provider.ProviderConfigProperty;
-import org.keycloak.representations.idm.CredentialRepresentation;
 import org.keycloak.services.ServicesLogger;
 import org.keycloak.services.x509.X509ClientCertificateLookup;
 
@@ -22,7 +18,6 @@ import java.security.cert.X509Certificate;
 import java.util.*;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 public class X509ClientAuthenticator extends AbstractClientAuthenticator {
 
@@ -32,10 +27,6 @@ public class X509ClientAuthenticator extends AbstractClientAuthenticator {
 
     protected static ServicesLogger logger = ServicesLogger.LOGGER;
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.DISABLED
-    };
 
     @Override
     public void authenticateClient(ClientAuthenticationFlowContext context) {
@@ -160,8 +151,7 @@ public class X509ClientAuthenticator extends AbstractClientAuthenticator {
    @Override
     public Set<String> getProtocolAuthenticatorMethods(String loginProtocol) {
         if (loginProtocol.equals(OIDCLoginProtocol.LOGIN_PROTOCOL)) {
-            Set<String> results = new HashSet<>();
-            return results;
+            return new HashSet<>();
         } else {
             return Collections.emptySet();
         }
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockAuthenticator.java
new file mode 100644
index 0000000000..a3fa4d33dc
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockAuthenticator.java
@@ -0,0 +1,19 @@
+package org.keycloak.authentication.authenticators.conditional;
+
+import org.keycloak.authentication.Authenticator;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.RealmModel;
+import org.keycloak.models.UserModel;
+import org.keycloak.authentication.AuthenticationFlowContext;
+
+public interface ConditionalBlockAuthenticator extends Authenticator {
+    boolean matchCondition(AuthenticationFlowContext context);
+
+    default void authenticate(AuthenticationFlowContext context) {
+        // authenticate is not called for ConditionalBlockAuthenticators
+    }
+
+    default boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
+        return true;
+    }
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockAuthenticatorFactory.java
new file mode 100644
index 0000000000..8d2455defa
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockAuthenticatorFactory.java
@@ -0,0 +1,26 @@
+package org.keycloak.authentication.authenticators.conditional;
+
+import org.keycloak.OAuth2Constants;
+import org.keycloak.authentication.Authenticator;
+import org.keycloak.authentication.AuthenticatorFactory;
+import org.keycloak.authentication.DisplayTypeAuthenticatorFactory;
+import org.keycloak.authentication.authenticators.AttemptedAuthenticator;
+import org.keycloak.models.KeycloakSession;
+
+public interface ConditionalBlockAuthenticatorFactory extends AuthenticatorFactory, DisplayTypeAuthenticatorFactory {
+
+    @Override
+    default Authenticator create(KeycloakSession session) {
+        return getSingleton();
+    }
+
+    @Override
+    default Authenticator createDisplay(KeycloakSession session, String displayType) {
+        if (displayType == null) return getSingleton();
+        if (!OAuth2Constants.DISPLAY_CONSOLE.equalsIgnoreCase(displayType)) return null;
+        return getSingleton();
+    }
+
+    ConditionalBlockAuthenticator getSingleton();
+
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockRoleAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockRoleAuthenticator.java
new file mode 100644
index 0000000000..cfd56bc2a6
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockRoleAuthenticator.java
@@ -0,0 +1,46 @@
+package org.keycloak.authentication.authenticators.conditional;
+
+import org.keycloak.authentication.AuthenticationFlowContext;
+import org.keycloak.models.AuthenticatorConfigModel;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.RealmModel;
+import org.keycloak.models.RoleModel;
+import org.keycloak.models.UserModel;
+
+import java.util.Set;
+
+public class ConditionalBlockRoleAuthenticator implements ConditionalBlockAuthenticator {
+    public static final ConditionalBlockRoleAuthenticator SINGLETON = new ConditionalBlockRoleAuthenticator();
+
+    @Override
+    public boolean matchCondition(AuthenticationFlowContext context) {
+        UserModel user = context.getUser();
+        AuthenticatorConfigModel authConfig = context.getAuthenticatorConfig();
+        if (user != null && authConfig!=null && authConfig.getConfig()!=null) {
+            Set<RoleModel> roles = user.getRoleMappings();
+            String requiredRole = authConfig.getConfig().get(ConditionalBlockRoleAuthenticatorFactory.CONDITIONAL_USER_ROLE);
+            return roles.stream().anyMatch(r -> r.getName().equals(requiredRole));
+        }
+        return false;
+    }
+
+    @Override
+    public void action(AuthenticationFlowContext context) {
+        // Not used
+    }
+
+    @Override
+    public boolean requiresUser() {
+        return true;
+    }
+
+    @Override
+    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {
+        // Not used
+    }
+
+    @Override
+    public void close() {
+        // Does nothing
+    }
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockRoleAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockRoleAuthenticatorFactory.java
new file mode 100644
index 0000000000..1c39a87304
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockRoleAuthenticatorFactory.java
@@ -0,0 +1,92 @@
+package org.keycloak.authentication.authenticators.conditional;
+
+import org.keycloak.Config.Scope;
+import org.keycloak.authentication.Authenticator;
+import org.keycloak.authentication.AuthenticatorFactory;
+import org.keycloak.models.AuthenticationExecutionModel;
+import org.keycloak.models.AuthenticationExecutionModel.Requirement;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.KeycloakSessionFactory;
+import org.keycloak.provider.ProviderConfigProperty;
+import org.keycloak.provider.ProviderConfigurationBuilder;
+
+import java.util.Collections;
+import java.util.List;
+
+public class ConditionalBlockRoleAuthenticatorFactory implements ConditionalBlockAuthenticatorFactory {
+    private static final String PROVIDER_ID = "conditional-user-role";
+    protected static final String CONDITIONAL_USER_ROLE = "condUserRole";
+
+    private static List<ProviderConfigProperty> commonConfig;
+
+    static {
+        commonConfig = Collections.unmodifiableList(ProviderConfigurationBuilder.create()
+            .property().name(CONDITIONAL_USER_ROLE).label("User role").helpText("Role the user should have to execute this flow").type(ProviderConfigProperty.STRING_TYPE).add()
+            .build()
+        );
+    }
+
+    @Override
+    public void init(Scope config) {
+        // no-op
+    }
+
+    @Override
+    public void postInit(KeycloakSessionFactory factory) {
+        // no-op
+    }
+
+    @Override
+    public void close() {
+        // no-op
+    }
+
+    @Override
+    public String getId() {
+        return PROVIDER_ID;
+    }
+
+    @Override
+    public String getDisplayType() {
+        return "Conditional block - user role";
+    }
+
+    @Override
+    public String getReferenceCategory() {
+        return "condition";
+    }
+
+    @Override
+    public boolean isConfigurable() {
+        return true;
+    }
+
+    private static final Requirement[] REQUIREMENT_CHOICES = {
+        AuthenticationExecutionModel.Requirement.REQUIRED, AuthenticationExecutionModel.Requirement.DISABLED
+    };
+
+    @Override
+    public Requirement[] getRequirementChoices() {
+        return REQUIREMENT_CHOICES;
+    }
+
+    @Override
+    public boolean isUserSetupAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getHelpText() {
+        return "Flow is executed only if user has the given role.";
+    }
+
+    @Override
+    public List<ProviderConfigProperty> getConfigProperties() {
+        return commonConfig;
+    }
+
+    @Override
+    public ConditionalBlockAuthenticator getSingleton() {
+        return ConditionalBlockRoleAuthenticator.SINGLETON;
+    }
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockUserConfiguredAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockUserConfiguredAuthenticator.java
new file mode 100644
index 0000000000..485df90ff8
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockUserConfiguredAuthenticator.java
@@ -0,0 +1,74 @@
+package org.keycloak.authentication.authenticators.conditional;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.keycloak.authentication.AuthenticationFlowContext;
+import org.keycloak.authentication.Authenticator;
+import org.keycloak.authentication.AuthenticatorFactory;
+import org.keycloak.models.AuthenticationExecutionModel;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.RealmModel;
+import org.keycloak.models.UserModel;
+
+public class ConditionalBlockUserConfiguredAuthenticator implements ConditionalBlockAuthenticator {
+    public static final ConditionalBlockUserConfiguredAuthenticator SINGLETON = new ConditionalBlockUserConfiguredAuthenticator();
+
+    @Override
+    public boolean matchCondition(AuthenticationFlowContext context) {
+        return matchConditionInFlow(context, context.getExecution().getParentFlow());
+    }
+
+    private boolean matchConditionInFlow(AuthenticationFlowContext context, String flowId) {
+        List<AuthenticationExecutionModel> executions = context.getRealm().getAuthenticationExecutions(flowId);
+        if (executions==null) {
+            return true;
+        }
+        List<AuthenticationExecutionModel> requiredExecutions = new ArrayList<>();
+        List<AuthenticationExecutionModel> alternativeExecutions = new ArrayList<>();
+        executions.forEach(e -> {
+            if (!context.getExecution().getId().equals(e.getId())) {
+                if (e.isRequired() || e.isOptional()) {
+                    requiredExecutions.add(e);
+                } else if (e.isAlternative()) {
+                    alternativeExecutions.add(e);
+                }
+            }
+        });
+        if (!requiredExecutions.isEmpty()) {
+            return requiredExecutions.stream().allMatch(e -> isConfiguredFor(e, context));
+        } else  if (!alternativeExecutions.isEmpty()) {
+            return alternativeExecutions.stream().anyMatch(e -> isConfiguredFor(e, context));
+        }
+        return true;
+    }
+
+    private boolean isConfiguredFor(AuthenticationExecutionModel model, AuthenticationFlowContext context) {
+        if (model.isAuthenticatorFlow()) {
+            return matchConditionInFlow(context, model.getId());
+        }
+        AuthenticatorFactory factory = (AuthenticatorFactory) context.getSession().getKeycloakSessionFactory().getProviderFactory(Authenticator.class, model.getAuthenticator());
+        Authenticator authenticator = factory.create(context.getSession());
+        return authenticator.configuredFor(context.getSession(), context.getRealm(), context.getUser());
+    }
+
+    @Override
+    public void action(AuthenticationFlowContext context) {
+        // Not used
+    }
+
+    @Override
+    public boolean requiresUser() {
+        return true;
+    }
+
+    @Override
+    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {
+        // Not used
+    }
+
+    @Override
+    public void close() {
+        // Does nothing
+    }
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockUserConfiguredAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockUserConfiguredAuthenticatorFactory.java
new file mode 100644
index 0000000000..8886acbe0f
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalBlockUserConfiguredAuthenticatorFactory.java
@@ -0,0 +1,81 @@
+package org.keycloak.authentication.authenticators.conditional;
+
+import java.util.List;
+
+import org.keycloak.Config.Scope;
+import org.keycloak.authentication.Authenticator;
+import org.keycloak.authentication.AuthenticatorFactory;
+import org.keycloak.models.AuthenticationExecutionModel.Requirement;
+import org.keycloak.models.AuthenticationExecutionModel;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.KeycloakSessionFactory;
+import org.keycloak.provider.ProviderConfigProperty;
+
+public class ConditionalBlockUserConfiguredAuthenticatorFactory implements ConditionalBlockAuthenticatorFactory {
+    private static final String PROVIDER_ID = "conditional-user-configured";
+    protected static final String CONDITIONAL_USER_ROLE = "condUserConfigured";
+
+    @Override
+    public void init(Scope config) {
+        // no-op
+    }
+
+    @Override
+    public void postInit(KeycloakSessionFactory factory) {
+        // no-op
+    }
+
+    @Override
+    public void close() {
+        // no-op
+    }
+
+    @Override
+    public String getId() {
+        return PROVIDER_ID;
+    }
+
+    @Override
+    public String getDisplayType() {
+        return "Conditional block - user configured";
+    }
+
+    @Override
+    public String getReferenceCategory() {
+        return "condition";
+    }
+
+    @Override
+    public boolean isConfigurable() {
+        return false;
+    }
+
+    private static final Requirement[] REQUIREMENT_CHOICES = {
+        AuthenticationExecutionModel.Requirement.REQUIRED, AuthenticationExecutionModel.Requirement.DISABLED
+    };
+
+    @Override
+    public Requirement[] getRequirementChoices() {
+        return REQUIREMENT_CHOICES;
+    }
+
+    @Override
+    public boolean isUserSetupAllowed() {
+        return false;
+    }
+
+    @Override
+    public String getHelpText() {
+        return "Executes the current flow only if authenticators are configured";
+    }
+
+    @Override
+    public List<ProviderConfigProperty> getConfigProperties() {
+        return null;
+    }
+
+    @Override
+    public ConditionalBlockAuthenticator getSingleton() {
+        return ConditionalBlockUserConfiguredAuthenticator.SINGLETON;
+    }
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleOTPFormAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleOTPFormAuthenticator.java
index 0335b17436..28e2a08c32 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleOTPFormAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleOTPFormAuthenticator.java
@@ -21,6 +21,7 @@ import org.keycloak.authentication.AuthenticationFlowContext;
 import org.keycloak.authentication.Authenticator;
 import org.keycloak.authentication.ConsoleDisplayMode;
 import org.keycloak.authentication.authenticators.browser.OTPFormAuthenticator;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.representations.idm.CredentialRepresentation;
 
 import javax.ws.rs.core.Response;
@@ -40,7 +41,7 @@ public class ConsoleOTPFormAuthenticator extends OTPFormAuthenticator implements
     protected ConsoleDisplayMode challenge(AuthenticationFlowContext context) {
         return ConsoleDisplayMode.challenge(context)
                 .header()
-                .param(CredentialRepresentation.TOTP)
+                .param(OTPCredentialModel.TYPE)
                 .label("console-otp")
                  .challenge();
     }
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsolePasswordAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsolePasswordAuthenticator.java
new file mode 100644
index 0000000000..fb15c1e8aa
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsolePasswordAuthenticator.java
@@ -0,0 +1,36 @@
+package org.keycloak.authentication.authenticators.console;
+
+import org.keycloak.authentication.AuthenticationFlowContext;
+import org.keycloak.authentication.ConsoleDisplayMode;
+
+import javax.ws.rs.core.MultivaluedMap;
+
+public final class ConsolePasswordAuthenticator extends ConsoleUsernamePasswordAuthenticator {
+
+    public static ConsolePasswordAuthenticator SINGLETON = new ConsolePasswordAuthenticator();
+
+    @Override
+    protected ConsoleDisplayMode challenge(AuthenticationFlowContext context) {
+        return ConsoleDisplayMode.challenge(context)
+                .header()
+                .param("password")
+                .label("console-password")
+                .mask(true)
+                .challenge();
+    }
+
+    @Override
+    public void action(AuthenticationFlowContext context) {
+        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();
+        if (!validatePassword(context, context.getUser(), formData, false)) {
+            return;
+        }
+        context.success();
+    }
+
+    @Override
+    public boolean requiresUser() {
+        return true;
+    }
+
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernameAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernameAuthenticator.java
new file mode 100644
index 0000000000..d043adec7d
--- /dev/null
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernameAuthenticator.java
@@ -0,0 +1,29 @@
+package org.keycloak.authentication.authenticators.console;
+
+import org.keycloak.authentication.AuthenticationFlowContext;
+import org.keycloak.authentication.ConsoleDisplayMode;
+
+import javax.ws.rs.core.MultivaluedMap;
+
+public final class ConsoleUsernameAuthenticator extends ConsoleUsernamePasswordAuthenticator {
+    public static ConsoleUsernameAuthenticator SINGLETON = new ConsoleUsernameAuthenticator();
+
+    @Override
+    protected ConsoleDisplayMode challenge(AuthenticationFlowContext context) {
+        return ConsoleDisplayMode.challenge(context)
+                .header()
+                .param("username")
+                .label("console-username")
+                .mask(true)
+                .challenge();
+    }
+
+    @Override
+    public void action(AuthenticationFlowContext context) {
+        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();
+        if (validateUser(context, formData) == null) {
+            return;
+        }
+        context.success();
+    }
+}
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticator.java
index 11b9118b6b..fdfe86968d 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticator.java
@@ -50,13 +50,10 @@ public class ConsoleUsernamePasswordAuthenticator extends AbstractUsernameFormAu
                 .challenge();
     }
 
-
     @Override
     public void authenticate(AuthenticationFlowContext context) {
         Response response = challenge(context).form().createForm("cli_splash.ftl");
         context.challenge(response);
-
-
     }
 
     @Override
@@ -79,7 +76,6 @@ public class ConsoleUsernamePasswordAuthenticator extends AbstractUsernameFormAu
         if (!validateUserAndPassword(context, formData)) {
             return;
         }
-
         context.success();
     }
 
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticatorFactory.java
index 05aa235723..69ff517cd5 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/console/ConsoleUsernamePasswordAuthenticatorFactory.java
@@ -24,6 +24,7 @@ import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
 import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
 
 import java.util.List;
@@ -63,7 +64,7 @@ public class ConsoleUsernamePasswordAuthenticatorFactory implements Authenticato
 
     @Override
     public String getReferenceCategory() {
-        return UserCredentialModel.PASSWORD;
+        return PasswordCredentialModel.TYPE;
     }
 
     @Override
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidateOTP.java b/services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidateOTP.java
index 69968ccb31..4b788fdeae 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidateOTP.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidateOTP.java
@@ -19,14 +19,17 @@ package org.keycloak.authentication.authenticators.directgrant;
 
 import org.keycloak.authentication.AuthenticationFlowContext;
 import org.keycloak.authentication.AuthenticationFlowError;
+import org.keycloak.authentication.CredentialValidator;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.OTPCredentialProvider;
 import org.keycloak.events.Errors;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.provider.ProviderConfigProperty;
-import org.keycloak.representations.idm.CredentialRepresentation;
 
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.Response;
@@ -37,13 +40,13 @@ import java.util.List;
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class ValidateOTP extends AbstractDirectGrantAuthenticator {
+public class ValidateOTP extends AbstractDirectGrantAuthenticator implements CredentialValidator<OTPCredentialProvider> {
 
     public static final String PROVIDER_ID = "direct-grant-validate-otp";
 
     @Override
     public void authenticate(AuthenticationFlowContext context) {
-        if (!isConfigured(context.getSession(), context.getRealm(), context.getUser())) {
+        if (!configuredFor(context.getSession(), context.getRealm(), context.getUser())) {
             if (context.getExecution().isOptional()) {
                 context.attempted();
             } else if (context.getExecution().isRequired()) {
@@ -53,7 +56,13 @@ public class ValidateOTP extends AbstractDirectGrantAuthenticator {
             }
             return;
         }
-        String otp = retrieveOTP(context);
+        MultivaluedMap<String, String> inputData = context.getHttpRequest().getDecodedFormParameters();
+
+        String otp = inputData.getFirst("otp");
+        String credentialId = context.getSelectedCredentialId();
+        if (credentialId == null || credentialId.isEmpty()) {
+            credentialId = getCredentialProvider(context.getSession()).getPreferredCredential(context.getRealm(), context.getUser()).getId();
+        }
         if (otp == null) {
             if (context.getUser() != null) {
                 context.getEvent().user(context.getUser());
@@ -63,7 +72,7 @@ public class ValidateOTP extends AbstractDirectGrantAuthenticator {
             context.failure(AuthenticationFlowError.INVALID_USER, challengeResponse);
             return;
         }
-        boolean valid = context.getSession().userCredentialManager().isValid(context.getRealm(), context.getUser(), UserCredentialModel.otp(context.getRealm().getOTPPolicy().getType(), otp));
+        boolean valid = getCredentialProvider(context.getSession()).isValid(context.getRealm(), context.getUser(), new UserCredentialModel(credentialId, OTPCredentialModel.TYPE, otp));
         if (!valid) {
             context.getEvent().user(context.getUser());
             context.getEvent().error(Errors.INVALID_USER_CREDENTIALS);
@@ -82,11 +91,7 @@ public class ValidateOTP extends AbstractDirectGrantAuthenticator {
 
     @Override
     public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
-        return true;
-    }
-
-    private boolean isConfigured(KeycloakSession session, RealmModel realm, UserModel user) {
-        return session.userCredentialManager().isConfiguredFor(realm, user, realm.getOTPPolicy().getType());
+        return getCredentialProvider(session).isConfiguredFor(realm, user);
     }
 
     @Override
@@ -115,12 +120,6 @@ public class ValidateOTP extends AbstractDirectGrantAuthenticator {
         return false;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.OPTIONAL,
-            AuthenticationExecutionModel.Requirement.DISABLED
-    };
-
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
         return REQUIREMENT_CHOICES;
@@ -140,9 +139,9 @@ public class ValidateOTP extends AbstractDirectGrantAuthenticator {
     public String getId() {
         return PROVIDER_ID;
     }
-    
-    protected String retrieveOTP(AuthenticationFlowContext context) {
-        MultivaluedMap<String, String> inputData = context.getHttpRequest().getDecodedFormParameters();
-        return inputData.getFirst(CredentialRepresentation.TOTP);
+
+    public OTPCredentialProvider getCredentialProvider(KeycloakSession session) {
+        return (OTPCredentialProvider)session.getProvider(CredentialProvider.class, "keycloak-otp");
     }
+
 }
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidatePassword.java b/services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidatePassword.java
index b992225013..833584f1a3 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidatePassword.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/directgrant/ValidatePassword.java
@@ -19,6 +19,9 @@ package org.keycloak.authentication.authenticators.directgrant;
 
 import org.keycloak.authentication.AuthenticationFlowContext;
 import org.keycloak.authentication.AuthenticationFlowError;
+import org.keycloak.authentication.CredentialValidator;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.PasswordCredentialProvider;
 import org.keycloak.events.Errors;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.KeycloakSession;
@@ -92,11 +95,6 @@ public class ValidatePassword extends AbstractDirectGrantAuthenticator {
         return false;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.DISABLED
-    };
-
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
         return REQUIREMENT_CHOICES;
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/AbstractSetRequiredActionAuthenticator.java b/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/AbstractSetRequiredActionAuthenticator.java
index bc818d3ba5..d9381ffd50 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/AbstractSetRequiredActionAuthenticator.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/AbstractSetRequiredActionAuthenticator.java
@@ -35,12 +35,6 @@ import java.util.List;
  * @version $Revision: 1 $
  */
 public abstract class AbstractSetRequiredActionAuthenticator implements Authenticator, AuthenticatorFactory {
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.OPTIONAL,
-            AuthenticationExecutionModel.Requirement.DISABLED
-
-    };
 
     @Override
     public void action(AuthenticationFlowContext context) {
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/ResetOTP.java b/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/ResetOTP.java
index 4c1fdadac1..80000cdb95 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/ResetOTP.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/ResetOTP.java
@@ -18,28 +18,35 @@
 package org.keycloak.authentication.authenticators.resetcred;
 
 import org.keycloak.authentication.AuthenticationFlowContext;
+import org.keycloak.authentication.CredentialValidator;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.OTPCredentialProvider;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserModel;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class ResetOTP extends AbstractSetRequiredActionAuthenticator {
+public class ResetOTP extends AbstractSetRequiredActionAuthenticator implements CredentialValidator<OTPCredentialProvider> {
 
     public static final String PROVIDER_ID = "reset-otp";
 
     @Override
     public void authenticate(AuthenticationFlowContext context) {
-        if (context.getExecution().isRequired() ||
-                (context.getExecution().isOptional() &&
-                        configuredFor(context))) {
-            context.getAuthenticationSession().addRequiredAction(UserModel.RequiredAction.CONFIGURE_TOTP);
-        }
+        context.getAuthenticationSession().addRequiredAction(UserModel.RequiredAction.CONFIGURE_TOTP);
         context.success();
     }
 
-    protected boolean configuredFor(AuthenticationFlowContext context) {
-        return context.getSession().userCredentialManager().isConfiguredFor(context.getRealm(), context.getUser(), context.getRealm().getOTPPolicy().getType());
+    @Override
+    public OTPCredentialProvider getCredentialProvider(KeycloakSession session) {
+        return (OTPCredentialProvider)session.getProvider(CredentialProvider.class, "keycloak-otp");
+    }
+
+    @Override
+    public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {
+        return getCredentialProvider(session).isConfiguredFor(realm, user);
     }
 
     @Override
@@ -49,11 +56,12 @@ public class ResetOTP extends AbstractSetRequiredActionAuthenticator {
 
     @Override
     public String getHelpText() {
-        return "Sets the Configure OTP required action if execution is REQUIRED.  Will also set it if execution is OPTIONAL and the OTP is currently configured for it.";
+        return "Sets the Configure OTP required action.";
     }
 
     @Override
     public String getId() {
         return PROVIDER_ID;
     }
+
 }
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/ResetPassword.java b/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/ResetPassword.java
index 68b8bfc21e..f1727dabbf 100755
--- a/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/ResetPassword.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/resetcred/ResetPassword.java
@@ -18,8 +18,8 @@
 package org.keycloak.authentication.authenticators.resetcred;
 
 import org.keycloak.authentication.AuthenticationFlowContext;
-import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
@@ -40,7 +40,7 @@ public class ResetPassword extends AbstractSetRequiredActionAuthenticator {
     }
 
     protected boolean configuredFor(AuthenticationFlowContext context) {
-        return context.getSession().userCredentialManager().isConfiguredFor(context.getRealm(), context.getUser(), UserCredentialModel.PASSWORD);
+        return context.getSession().userCredentialManager().isConfiguredFor(context.getRealm(), context.getUser(), PasswordCredentialModel.TYPE);
     }
 
     @Override
diff --git a/services/src/main/java/org/keycloak/authentication/authenticators/x509/X509ClientCertificateAuthenticatorFactory.java b/services/src/main/java/org/keycloak/authentication/authenticators/x509/X509ClientCertificateAuthenticatorFactory.java
index b36da5ef53..55779cdd5e 100644
--- a/services/src/main/java/org/keycloak/authentication/authenticators/x509/X509ClientCertificateAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/authentication/authenticators/x509/X509ClientCertificateAuthenticatorFactory.java
@@ -33,11 +33,6 @@ public class X509ClientCertificateAuthenticatorFactory  extends AbstractX509Clie
     public static final X509ClientCertificateAuthenticator SINGLETON =
             new X509ClientCertificateAuthenticator();
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.DISABLED
-    };
-
 
     @Override
     public String getHelpText() {
diff --git a/services/src/main/java/org/keycloak/authentication/forms/RegistrationPassword.java b/services/src/main/java/org/keycloak/authentication/forms/RegistrationPassword.java
index d2851b2c20..924eff5227 100755
--- a/services/src/main/java/org/keycloak/authentication/forms/RegistrationPassword.java
+++ b/services/src/main/java/org/keycloak/authentication/forms/RegistrationPassword.java
@@ -31,6 +31,7 @@ import org.keycloak.models.KeycloakSessionFactory;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.models.utils.FormMessage;
 import org.keycloak.policy.PasswordPolicyManagerProvider;
 import org.keycloak.policy.PolicyError;
@@ -91,9 +92,6 @@ public class RegistrationPassword implements FormAction, FormActionFactory {
     public void success(FormContext context) {
         MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();
         String password = formData.getFirst(RegistrationPage.FIELD_PASSWORD);
-        UserCredentialModel credentials = new UserCredentialModel();
-        credentials.setType(CredentialRepresentation.PASSWORD);
-        credentials.setValue(password);
         UserModel user = context.getUser();
         try {
             context.getSession().userCredentialManager().updateCredential(context.getRealm(), user, UserCredentialModel.password(formData.getFirst("password"), false));
@@ -140,7 +138,7 @@ public class RegistrationPassword implements FormAction, FormActionFactory {
 
     @Override
     public String getReferenceCategory() {
-        return UserCredentialModel.PASSWORD;
+        return PasswordCredentialModel.TYPE;
     }
 
     @Override
diff --git a/services/src/main/java/org/keycloak/authentication/requiredactions/ConsoleUpdateTotp.java b/services/src/main/java/org/keycloak/authentication/requiredactions/ConsoleUpdateTotp.java
index 32751b99e4..d2ff6adfb9 100644
--- a/services/src/main/java/org/keycloak/authentication/requiredactions/ConsoleUpdateTotp.java
+++ b/services/src/main/java/org/keycloak/authentication/requiredactions/ConsoleUpdateTotp.java
@@ -17,13 +17,19 @@
 
 package org.keycloak.authentication.requiredactions;
 
+import com.fasterxml.jackson.core.JsonProcessingException;
 import org.keycloak.authentication.RequiredActionContext;
 import org.keycloak.authentication.RequiredActionProvider;
 import org.keycloak.authentication.ConsoleDisplayMode;
+import org.keycloak.credential.CredentialModel;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.OTPCredentialProvider;
 import org.keycloak.events.EventBuilder;
 import org.keycloak.events.EventType;
 import org.keycloak.forms.login.freemarker.model.TotpBean;
+import org.keycloak.models.OTPPolicy;
 import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.CredentialValidation;
 import org.keycloak.services.messages.Messages;
 import org.keycloak.services.validation.Validation;
@@ -41,6 +47,7 @@ public class ConsoleUpdateTotp implements RequiredActionProvider {
     @Override
     public void evaluateTriggers(RequiredActionContext context) {
     }
+
     @Override
     public void requiredActionChallenge(RequiredActionContext context) {
         TotpBean totpBean = new TotpBean(context.getSession(), context.getRealm(), context.getUser(), context.getUriInfo().getRequestUriBuilder());
@@ -65,33 +72,26 @@ public class ConsoleUpdateTotp implements RequiredActionProvider {
         EventBuilder event = context.getEvent();
         event.event(EventType.UPDATE_TOTP);
         MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();
-        String totp = formData.getFirst("totp");
+        String challengeResponse = formData.getFirst("totp");
         String totpSecret = context.getAuthenticationSession().getAuthNote("totpSecret");
 
-        if (Validation.isBlank(totp)) {
-            context.challenge(
-                    challenge(context).message(Messages.MISSING_TOTP)
-            );
+        OTPPolicy policy = context.getRealm().getOTPPolicy();
+        OTPCredentialModel credentialModel = OTPCredentialModel.createFromPolicy(context.getRealm(), totpSecret);
+        if (Validation.isBlank(challengeResponse)) {
+            context.challenge(challenge(context).message(Messages.MISSING_TOTP));
             return;
-        } else if (!CredentialValidation.validOTP(context.getRealm(), totp, totpSecret)) {
-            context.challenge(
-                    challenge(context).message(Messages.INVALID_TOTP)
-            );
+        } else if (!CredentialValidation.validOTP(challengeResponse, credentialModel, policy.getLookAheadWindow())) {
+            context.challenge(challenge(context).message(Messages.INVALID_TOTP));
             return;
         }
 
-        UserCredentialModel credentials = new UserCredentialModel();
-        credentials.setType(context.getRealm().getOTPPolicy().getType());
-        credentials.setValue(totpSecret);
-        context.getSession().userCredentialManager().updateCredential(context.getRealm(), context.getUser(), credentials);
-
-
-        // if type is HOTP, to update counter we execute validation based on supplied token
-        UserCredentialModel cred = new UserCredentialModel();
-        cred.setType(context.getRealm().getOTPPolicy().getType());
-        cred.setValue(totp);
-        context.getSession().userCredentialManager().isValid(context.getRealm(), context.getUser(), cred);
-
+        OTPCredentialProvider otpCredentialProvider = (OTPCredentialProvider) context.getSession().getProvider(CredentialProvider.class, "keycloak-otp");
+        CredentialModel createdCredential = otpCredentialProvider.createCredential(context.getRealm(), context.getUser(), credentialModel);
+        UserCredentialModel credential = new UserCredentialModel(createdCredential.getId(), otpCredentialProvider.getType(), challengeResponse);
+        if (!otpCredentialProvider.isValid(context.getRealm(), context.getUser(), credential)) {
+            context.challenge(challenge(context).message(Messages.INVALID_TOTP));
+            return;
+        }
         context.getAuthenticationSession().removeAuthNote("totpSecret");
         context.success();
     }
diff --git a/services/src/main/java/org/keycloak/authentication/requiredactions/UpdatePassword.java b/services/src/main/java/org/keycloak/authentication/requiredactions/UpdatePassword.java
index 45fb05f436..fefb16f225 100755
--- a/services/src/main/java/org/keycloak/authentication/requiredactions/UpdatePassword.java
+++ b/services/src/main/java/org/keycloak/authentication/requiredactions/UpdatePassword.java
@@ -40,6 +40,7 @@ import org.keycloak.services.validation.Validation;
 
 import javax.ws.rs.core.MultivaluedMap;
 import javax.ws.rs.core.Response;
+import java.io.IOException;
 import java.util.concurrent.TimeUnit;
 
 /**
diff --git a/services/src/main/java/org/keycloak/authentication/requiredactions/UpdateTotp.java b/services/src/main/java/org/keycloak/authentication/requiredactions/UpdateTotp.java
index fdcf5ffb33..5f7f31107f 100644
--- a/services/src/main/java/org/keycloak/authentication/requiredactions/UpdateTotp.java
+++ b/services/src/main/java/org/keycloak/authentication/requiredactions/UpdateTotp.java
@@ -17,15 +17,21 @@
 
 package org.keycloak.authentication.requiredactions;
 
+import com.fasterxml.jackson.core.JsonProcessingException;
 import org.keycloak.Config;
 import org.keycloak.OAuth2Constants;
 import org.keycloak.authentication.*;
+import org.keycloak.credential.CredentialModel;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.OTPCredentialProvider;
 import org.keycloak.events.EventBuilder;
 import org.keycloak.events.EventType;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
+import org.keycloak.models.OTPPolicy;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.CredentialValidation;
 import org.keycloak.services.messages.Messages;
 import org.keycloak.services.validation.Validation;
@@ -37,7 +43,7 @@ import javax.ws.rs.core.Response;
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class UpdateTotp implements RequiredActionProvider, RequiredActionFactory, DisplayTypeRequiredActionFactory {
+public class UpdateTotp implements RequiredActionProvider, RequiredActionFactory, DisplayTypeRequiredActionFactory, CredentialRegistrator {
     @Override
     public void evaluateTriggers(RequiredActionContext context) {
     }
@@ -55,18 +61,20 @@ public class UpdateTotp implements RequiredActionProvider, RequiredActionFactory
         EventBuilder event = context.getEvent();
         event.event(EventType.UPDATE_TOTP);
         MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();
-        String totp = formData.getFirst("totp");
+        String challengeResponse = formData.getFirst("totp");
         String totpSecret = formData.getFirst("totpSecret");
         String mode = formData.getFirst("mode");
 
-        if (Validation.isBlank(totp)) {
+        OTPPolicy policy = context.getRealm().getOTPPolicy();
+        OTPCredentialModel credentialModel = OTPCredentialModel.createFromPolicy(context.getRealm(), totpSecret);
+        if (Validation.isBlank(challengeResponse)) {
             Response challenge = context.form()
                     .setAttribute("mode", mode)
                     .setError(Messages.MISSING_TOTP)
                     .createResponse(UserModel.RequiredAction.CONFIGURE_TOTP);
             context.challenge(challenge);
             return;
-        } else if (!CredentialValidation.validOTP(context.getRealm(), totp, totpSecret)) {
+        } else if (!CredentialValidation.validOTP(challengeResponse, credentialModel, policy.getLookAheadWindow())) {
             Response challenge = context.form()
                     .setAttribute("mode", mode)
                     .setError(Messages.INVALID_TOTP)
@@ -75,18 +83,17 @@ public class UpdateTotp implements RequiredActionProvider, RequiredActionFactory
             return;
         }
 
-        UserCredentialModel credentials = new UserCredentialModel();
-        credentials.setType(context.getRealm().getOTPPolicy().getType());
-        credentials.setValue(totpSecret);
-        context.getSession().userCredentialManager().updateCredential(context.getRealm(), context.getUser(), credentials);
-
-
-        // if type is HOTP, to update counter we execute validation based on supplied token
-        UserCredentialModel cred = new UserCredentialModel();
-        cred.setType(context.getRealm().getOTPPolicy().getType());
-        cred.setValue(totp);
-        context.getSession().userCredentialManager().isValid(context.getRealm(), context.getUser(), cred);
-
+        OTPCredentialProvider otpCredentialProvider = (OTPCredentialProvider) context.getSession().getProvider(CredentialProvider.class, "keycloak-otp");
+        CredentialModel createdCredential = otpCredentialProvider.createCredential(context.getRealm(), context.getUser(), credentialModel);
+        UserCredentialModel credential = new UserCredentialModel(createdCredential.getId(), otpCredentialProvider.getType(), challengeResponse);
+        if (!otpCredentialProvider.isValid(context.getRealm(), context.getUser(), credential)) {
+            Response challenge = context.form()
+                    .setAttribute("mode", mode)
+                    .setError(Messages.INVALID_TOTP)
+                    .createResponse(UserModel.RequiredAction.CONFIGURE_TOTP);
+            context.challenge(challenge);
+            return;
+        }
         context.success();
     }
 
diff --git a/services/src/main/java/org/keycloak/credential/OTPCredentialProvider.java b/services/src/main/java/org/keycloak/credential/OTPCredentialProvider.java
index e25de8819e..671a1ca9b8 100644
--- a/services/src/main/java/org/keycloak/credential/OTPCredentialProvider.java
+++ b/services/src/main/java/org/keycloak/credential/OTPCredentialProvider.java
@@ -18,237 +18,121 @@ package org.keycloak.credential;
 
 import org.jboss.logging.Logger;
 import org.keycloak.common.util.Time;
+import org.keycloak.models.credential.OTPCredentialModel;
+import org.keycloak.models.credential.dto.OTPCredentialData;
+import org.keycloak.models.credential.dto.OTPSecretData;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.OTPPolicy;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
-import org.keycloak.models.cache.CachedUserModel;
-import org.keycloak.models.cache.OnUserCache;
-import org.keycloak.models.cache.UserCache;
 import org.keycloak.models.utils.HmacOTP;
 import org.keycloak.models.utils.TimeBasedOTP;
 
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
+import java.nio.charset.StandardCharsets;
 
 /**
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class OTPCredentialProvider implements CredentialProvider, CredentialInputValidator, CredentialInputUpdater, OnUserCache {
+public class OTPCredentialProvider implements CredentialProvider<OTPCredentialModel>, CredentialInputValidator/*, OnUserCache*/ {
     private static final Logger logger = Logger.getLogger(OTPCredentialProvider.class);
 
     protected KeycloakSession session;
 
-    protected List<CredentialModel> getCachedCredentials(UserModel user, String type) {
+    /*protected List<CredentialModel> getCachedCredentials(UserModel user, String type) {
         if (!(user instanceof CachedUserModel)) return null;
         CachedUserModel cached = (CachedUserModel)user;
         if (cached.isMarkedForEviction()) return null;
-        List<CredentialModel> rtn = (List<CredentialModel>)cached.getCachedWith().get(OTPCredentialProvider.class.getName() + "." + type);
+        List<CredentialModel> rtn = (List<CredentialModel>)cached.getCachedWith().get(getType());
         if (rtn == null) return Collections.EMPTY_LIST;
         return rtn;
-    }
+    }*/
 
-    protected UserCredentialStore getCredentialStore() {
+    private UserCredentialStore getCredentialStore() {
         return session.userCredentialManager();
     }
 
-    @Override
+    /*@Override
     public void onCache(RealmModel realm, CachedUserModel user, UserModel delegate) {
-        List<CredentialModel> creds = getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.TOTP);
-        user.getCachedWith().put(OTPCredentialProvider.class.getName() + "." + CredentialModel.TOTP, creds);
+        List<CredentialModel> creds = getCredentialStore().getStoredCredentialsByType(realm, user, getType());
+        user.getCachedWith().put(getType(), creds);
 
-    }
+    }*/
 
     public OTPCredentialProvider(KeycloakSession session) {
         this.session = session;
     }
 
     @Override
-    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
-        if (!supportsCredentialType(input.getType())) return false;
-
-        if (!(input instanceof UserCredentialModel)) {
-            logger.debug("Expected instance of UserCredentialModel for CredentialInput");
-            return false;
-        }
-        UserCredentialModel inputModel = (UserCredentialModel)input;
-        CredentialModel model = null;
-        if (inputModel.getDevice() != null) {
-            model = getCredentialStore().getStoredCredentialByNameAndType(realm, user, inputModel.getDevice(), CredentialModel.TOTP);
-            if (model == null) {
-                model = getCredentialStore().getStoredCredentialByNameAndType(realm, user, inputModel.getDevice(), CredentialModel.HOTP);
-            }
-        }
-        if (model == null) {
-            // delete all existing
-            disableCredentialType(realm, user, CredentialModel.OTP);
-            model = new CredentialModel();
-        }
-
-        OTPPolicy policy = realm.getOTPPolicy();
-        model.setDigits(policy.getDigits());
-        model.setCounter(policy.getInitialCounter());
-        model.setAlgorithm(policy.getAlgorithm());
-        model.setType(input.getType());
-        model.setValue(inputModel.getValue());
-        model.setDevice(inputModel.getDevice());
-        model.setPeriod(policy.getPeriod());
-        model.setCreatedDate(Time.currentTimeMillis());
-        if (model.getId() == null) {
-            getCredentialStore().createCredential(realm, user, model);
-        } else {
-            getCredentialStore().updateCredential(realm, user, model);
+    public CredentialModel createCredential(RealmModel realm, UserModel user, OTPCredentialModel credentialModel) {
+        if (credentialModel.getCreatedDate() == null) {
+            credentialModel.setCreatedDate(Time.currentTimeMillis());
         }
-        UserCache userCache = session.userCache();
-        if (userCache != null) {
-            userCache.evict(realm, user);
-        }
-        return true;
-
-
-
+        return getCredentialStore().createCredential(realm, user, credentialModel);
     }
 
     @Override
-    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {
-        boolean disableTOTP = false, disableHOTP = false;
-        if (CredentialModel.OTP.equals(credentialType)) {
-            disableTOTP = true;
-            disableHOTP = true;
-        } else if (CredentialModel.HOTP.equals(credentialType)) {
-            disableHOTP = true;
-
-        } else if (CredentialModel.TOTP.equals(credentialType)) {
-            disableTOTP = true;
-        }
-        if (disableHOTP) {
-            List<CredentialModel> hotp = getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.HOTP);
-            for (CredentialModel cred : hotp) {
-                getCredentialStore().removeStoredCredential(realm, user, cred.getId());
-            }
-
-        }
-        if (disableTOTP) {
-            List<CredentialModel> totp = getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.TOTP);
-            if (!totp.isEmpty()) {
-                for (CredentialModel cred : totp) {
-                    getCredentialStore().removeStoredCredential(realm, user, cred.getId());
-                }
-            }
-
-        }
-        if (disableTOTP || disableHOTP) {
-            UserCache userCache = session.userCache();
-            if (userCache != null) {
-                userCache.evict(realm, user);
-            }
-        }
+    public void deleteCredential(RealmModel realm, UserModel user, String credentialId) {
+        getCredentialStore().removeStoredCredential(realm, user, credentialId);
     }
 
-    @Override
-    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {
-        if (!getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.HOTP).isEmpty()
-        || !getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.TOTP).isEmpty()) {
-            Set<String> set = new HashSet<>();
-            set.add(CredentialModel.OTP);
-            return set;
-        } else {
-            return Collections.EMPTY_SET;
+    public OTPCredentialModel getPreferredCredential(RealmModel realm, UserModel user) {
+        if (!isConfiguredFor(realm, user)) {
+            return null;
         }
+        return OTPCredentialModel.createFromCredentialModel(getCredentialStore().getStoredCredentialsByType(realm, user, getType()).get(0));
     }
 
-
     @Override
     public boolean supportsCredentialType(String credentialType) {
-        return CredentialModel.OTP.equals(credentialType)
-                || CredentialModel.HOTP.equals(credentialType)
-                || CredentialModel.TOTP.equals(credentialType);
+        return getType().equals(credentialType);
     }
 
     @Override
     public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
-        if (!supportsCredentialType(credentialType)) return false;
-        if (CredentialModel.OTP.equals(credentialType)) {
-            if (realm.getOTPPolicy().getType().equals(CredentialModel.HOTP)) {
-                return configuredForHOTP(realm, user);
-            } else {
-                return configuredForTOTP(realm, user);
-            }
-        } else if (CredentialModel.HOTP.equals(credentialType)) {
-            return configuredForHOTP(realm, user);
-
-        } else if (CredentialModel.TOTP.equals(credentialType)) {
-            return configuredForTOTP(realm, user);
-        } else {
-            return false;
-        }
-
-    }
-
-    protected boolean configuredForHOTP(RealmModel realm, UserModel user) {
-        return !getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.HOTP).isEmpty();
+        return !getCredentialStore().getStoredCredentialsByType(realm, user, credentialType).isEmpty();
     }
 
-    protected boolean configuredForTOTP(RealmModel realm, UserModel user) {
-        List<CredentialModel> cachedCredentials = getCachedCredentials(user, CredentialModel.TOTP);
-        if (cachedCredentials == null) return !getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.TOTP).isEmpty();
-        return !cachedCredentials.isEmpty();
-    }
-
-    public static boolean validOTP(RealmModel realm, String token, String secret) {
-        OTPPolicy policy = realm.getOTPPolicy();
-        if (policy.getType().equals(UserCredentialModel.TOTP)) {
-            TimeBasedOTP validator = new TimeBasedOTP(policy.getAlgorithm(), policy.getDigits(), policy.getPeriod(), policy.getLookAheadWindow());
-            return validator.validateTOTP(token, secret.getBytes());
-        } else {
-            HmacOTP validator = new HmacOTP(policy.getDigits(), policy.getAlgorithm(), policy.getLookAheadWindow());
-            int c = validator.validateHOTP(token, secret, policy.getInitialCounter());
-            return c > -1;
-        }
-
+    public boolean isConfiguredFor(RealmModel realm, UserModel user){
+        return isConfiguredFor(realm, user, getType());
     }
 
     @Override
-    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
-        if (! (input instanceof UserCredentialModel)) {
+    public boolean isValid(RealmModel realm, UserModel user, CredentialInput credentialInput) {
+        if (!(credentialInput instanceof UserCredentialModel)) {
             logger.debug("Expected instance of UserCredentialModel for CredentialInput");
             return false;
 
         }
-        String token = ((UserCredentialModel)input).getValue();
-        if (token == null) {
+        String challengeResponse = credentialInput.getChallengeResponse();
+        if (challengeResponse == null) {
             return false;
         }
 
+        CredentialModel credential = getCredentialStore().getStoredCredentialById(realm, user, credentialInput.getCredentialId());
+        OTPCredentialModel otpCredentialModel = OTPCredentialModel.createFromCredentialModel(credential);
+        OTPSecretData secretData = otpCredentialModel.getOTPSecretData();
+        OTPCredentialData credentialData = otpCredentialModel.getOTPCredentialData();
         OTPPolicy policy = realm.getOTPPolicy();
-        if (realm.getOTPPolicy().getType().equals(CredentialModel.HOTP)) {
-            HmacOTP validator = new HmacOTP(policy.getDigits(), policy.getAlgorithm(), policy.getLookAheadWindow());
-            for (CredentialModel cred : getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.HOTP)) {
-                int counter = validator.validateHOTP(token, cred.getValue(), cred.getCounter());
-                if (counter < 0) continue;
-                cred.setCounter(counter);
-                getCredentialStore().updateCredential(realm, user, cred);
-                return true;
-            }
-        } else {
-            TimeBasedOTP validator = new TimeBasedOTP(policy.getAlgorithm(), policy.getDigits(), policy.getPeriod(), policy.getLookAheadWindow());
-            List<CredentialModel> creds = getCachedCredentials(user, CredentialModel.TOTP);
-            if (creds == null) {
-                creds = getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.TOTP);
-            } else {
-                logger.debugv("Cache hit for TOTP for user {0}", user.getUsername());
+        if (OTPCredentialModel.HOTP.equals(credentialData.getSubType())) {
+            HmacOTP validator = new HmacOTP(credentialData.getDigits(), credentialData.getAlgorithm(), policy.getLookAheadWindow());
+            int counter = validator.validateHOTP(challengeResponse, secretData.getValue(), credentialData.getCounter());
+            if (counter < 0) {
+                return false;
             }
-            for (CredentialModel cred : creds) {
-                if (validator.validateTOTP(token, cred.getValue().getBytes())) {
-                    return true;
-                }
-            }
-
+            otpCredentialModel.updateCounter(counter);
+            getCredentialStore().updateCredential(realm, user, otpCredentialModel);
+            return true;
+        } else if (OTPCredentialModel.TOTP.equals(credentialData.getSubType())) {
+            TimeBasedOTP validator = new TimeBasedOTP(credentialData.getAlgorithm(), credentialData.getDigits(), credentialData.getPeriod(), policy.getLookAheadWindow());
+            return validator.validateTOTP(challengeResponse, secretData.getValue().getBytes(StandardCharsets.UTF_8));
         }
         return false;
     }
+
+    @Override
+    public String getType() {
+        return OTPCredentialModel.TYPE;
+    }
 }
diff --git a/services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java b/services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java
index 98fd9286a1..41a06f7fe3 100644
--- a/services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java
+++ b/services/src/main/java/org/keycloak/credential/PasswordCredentialProvider.java
@@ -19,8 +19,9 @@ package org.keycloak.credential;
 import org.jboss.logging.Logger;
 import org.keycloak.common.util.Time;
 import org.keycloak.credential.hash.PasswordHashProvider;
-import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.ModelException;
+import org.keycloak.models.credential.PasswordCredentialModel;
+import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.PasswordPolicy;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserCredentialModel;
@@ -31,8 +32,8 @@ import org.keycloak.models.cache.UserCache;
 import org.keycloak.policy.PasswordPolicyManagerProvider;
 import org.keycloak.policy.PolicyError;
 
+import java.io.IOException;
 import java.util.Collections;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
@@ -40,12 +41,12 @@ import java.util.Set;
  * @author <a href="mailto:bill@burkecentral.com">Bill Burke</a>
  * @version $Revision: 1 $
  */
-public class PasswordCredentialProvider implements CredentialProvider, CredentialInputValidator, CredentialInputUpdater, OnUserCache {
+public class PasswordCredentialProvider implements CredentialProvider<PasswordCredentialModel>, CredentialInputUpdater, CredentialInputValidator, OnUserCache {
 
-    public static final String PASSWORD_CACHE_KEY = PasswordCredentialProvider.class.getName() + "." + CredentialModel.PASSWORD;
+    public static final String PASSWORD_CACHE_KEY = PasswordCredentialProvider.class.getName() + "." + PasswordCredentialModel.TYPE;
     private static final Logger logger = Logger.getLogger(PasswordCredentialProvider.class);
 
-    protected KeycloakSession session;
+    protected final KeycloakSession session;
 
     public PasswordCredentialProvider(KeycloakSession session) {
         this.session = session;
@@ -55,78 +56,86 @@ public class PasswordCredentialProvider implements CredentialProvider, Credentia
         return session.userCredentialManager();
     }
 
-    public CredentialModel getPassword(RealmModel realm, UserModel user) {
+    public PasswordCredentialModel getPassword(RealmModel realm, UserModel user) {
         List<CredentialModel> passwords = null;
-        if (user instanceof CachedUserModel && !((CachedUserModel)user).isMarkedForEviction()) {
-            CachedUserModel cached = (CachedUserModel)user;
-            passwords = (List<CredentialModel>)cached.getCachedWith().get(PASSWORD_CACHE_KEY);
+        if (user instanceof CachedUserModel && !((CachedUserModel) user).isMarkedForEviction()) {
+            CachedUserModel cached = (CachedUserModel) user;
+            passwords = (List<CredentialModel>) cached.getCachedWith().get(PASSWORD_CACHE_KEY);
 
         }
         // if the model was marked for eviction while passwords were initialized, override it from credentialStore
-        if (! (user instanceof CachedUserModel) || ((CachedUserModel) user).isMarkedForEviction()) {
-            passwords = getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.PASSWORD);
+        if (!(user instanceof CachedUserModel) || ((CachedUserModel) user).isMarkedForEviction()) {
+            passwords = getCredentialStore().getStoredCredentialsByType(realm, user, getType());
         }
         if (passwords == null || passwords.isEmpty()) return null;
-        return passwords.get(0);
-    }
 
 
-    @Override
-    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
-        if (!supportsCredentialType(input.getType())) return false;
+        return PasswordCredentialModel.createFromCredentialModel(passwords.get(0));
+    }
 
-        if (!(input instanceof UserCredentialModel)) {
-            logger.debug("Expected instance of UserCredentialModel for CredentialInput");
-            return false;
-        }
-        UserCredentialModel cred = (UserCredentialModel)input;
+    public boolean createCredential(RealmModel realm, UserModel user, String password) {
         PasswordPolicy policy = realm.getPasswordPolicy();
 
-        PolicyError error = session.getProvider(PasswordPolicyManagerProvider.class).validate(realm, user, cred.getValue());
+        PolicyError error = session.getProvider(PasswordPolicyManagerProvider.class).validate(realm, user, password);
         if (error != null) throw new ModelException(error.getMessage(), error.getParameters());
 
-
         PasswordHashProvider hash = getHashProvider(policy);
         if (hash == null) {
             return false;
         }
-        CredentialModel oldPassword = getPassword(realm, user);
+        PasswordCredentialModel credentialModel = hash.encodedCredential(password, policy.getHashIterations());
+        credentialModel.setCreatedDate(Time.currentTimeMillis());
+        createCredential(realm, user, credentialModel);
+        return true;
+    }
 
-        expirePassword(realm, user, policy);
-        CredentialModel newPassword = new CredentialModel();
-        newPassword.setType(CredentialModel.PASSWORD);
-        long createdDate = Time.currentTimeMillis();
-        newPassword.setCreatedDate(createdDate);
-        hash.encode(cred.getValue(), policy.getHashIterations(), newPassword);
-        getCredentialStore().createCredential(realm, user, newPassword);
-        UserCache userCache = session.userCache();
-        if (userCache != null) {
-            userCache.evict(realm, user);
+    @Override
+    public CredentialModel createCredential(RealmModel realm, UserModel user, PasswordCredentialModel credentialModel) {
+        PasswordPolicy policy = realm.getPasswordPolicy();
+        try {
+            expirePassword(realm, user, policy);
+            if (credentialModel.getCreatedDate() == null) {
+                credentialModel.setCreatedDate(Time.currentTimeMillis());
+            }
+            CredentialModel createdCredential = getCredentialStore().createCredential(realm, user, credentialModel);
+            UserCache userCache = session.userCache();
+            if (userCache != null) {
+                userCache.evict(realm, user);
+            }
+            return createdCredential;
+        } catch (IOException e) {
+            throw new RuntimeException(e);
         }
-        return true;
     }
 
-    protected void expirePassword(RealmModel realm, UserModel user, PasswordPolicy policy) {
+    @Override
+    public void deleteCredential(RealmModel realm, UserModel user, String credentialId) {
+        getCredentialStore().removeStoredCredential(realm, user, credentialId);
+    }
+
+
+
+    protected void expirePassword(RealmModel realm, UserModel user, PasswordPolicy policy) throws IOException {
 
         CredentialModel oldPassword = getPassword(realm, user);
         if (oldPassword == null) return;
         int expiredPasswordsPolicyValue = policy.getExpiredPasswords();
-        List<CredentialModel> list = getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.PASSWORD_HISTORY);
+        List<CredentialModel> list = getCredentialStore().getStoredCredentialsByType(realm, user, PasswordCredentialModel.PASSWORD_HISTORY);
         if (expiredPasswordsPolicyValue > 1) {
             // oldPassword will expire few lines below, and there is one active password,
             // hence (expiredPasswordsPolicyValue - 2) passwords should be left in history
             final int passwordsToLeave = expiredPasswordsPolicyValue - 2;
             if (list.size() > passwordsToLeave) {
                 list.stream()
-                  .sorted((o1, o2) -> { // sort by date descending
-                      Long o1Date = o1.getCreatedDate() == null ? Long.MIN_VALUE : o1.getCreatedDate();
-                      Long o2Date = o2.getCreatedDate() == null ? Long.MIN_VALUE : o2.getCreatedDate();
-                      return (- o1Date.compareTo(o2Date));
-                  })
-                  .skip(passwordsToLeave)
-                  .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));
+                        .sorted((o1, o2) -> { // sort by date descending
+                            Long o1Date = o1.getCreatedDate() == null ? Long.MIN_VALUE : o1.getCreatedDate();
+                            Long o2Date = o2.getCreatedDate() == null ? Long.MIN_VALUE : o2.getCreatedDate();
+                            return (-o1Date.compareTo(o2Date));
+                        })
+                        .skip(passwordsToLeave)
+                        .forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));
             }
-            oldPassword.setType(CredentialModel.PASSWORD_HISTORY);
+            oldPassword.setType(PasswordCredentialModel.PASSWORD_HISTORY);
             getCredentialStore().updateCredential(realm, user, oldPassword);
         } else {
             list.stream().forEach(p -> getCredentialStore().removeStoredCredential(realm, user, p.getId()));
@@ -144,7 +153,42 @@ public class PasswordCredentialProvider implements CredentialProvider, Credentia
         return hash;
     }
 
-    @Override
+    /*@Override
+    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
+        if (!supportsCredentialType(input.getType())) return false;
+
+        if (!(input instanceof UserCredentialModel)) {
+            logger.debug("Expected instance of UserCredentialModel for CredentialInput");
+            return false;
+        }
+        UserCredentialModel cred = (UserCredentialModel)input;
+        PasswordPolicy policy = realm.getPasswordPolicy();
+
+        PolicyError error = session.getProvider(PasswordPolicyManagerProvider.class).validate(realm, user, cred.getValue());
+        if (error != null) throw new ModelException(error.getMessage(), error.getParameters());
+
+
+        PasswordHashProvider hash = getHashProvider(policy);
+        if (hash == null) {
+            return false;
+        }
+        CredentialModel oldPassword = getPassword(realm, user);
+
+        expirePassword(realm, user, policy);
+        CredentialModel newPassword = new CredentialModel();
+        newPassword.setType(CredentialModel.PASSWORD);
+        long createdDate = Time.currentTimeMillis();
+        newPassword.setCreatedDate(createdDate);
+        hash.encode(cred.getValue(), policy.getHashIterations(), newPassword);
+        getCredentialStore().createCredential(realm, user, newPassword);
+        UserCache userCache = session.userCache();
+        if (userCache != null) {
+            userCache.evict(realm, user);
+        }
+        return true;
+    }*/
+
+    /*@Override
     public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {
         if (!supportsCredentialType(credentialType)) return;
         PasswordPolicy policy = realm.getPasswordPolicy();
@@ -160,11 +204,26 @@ public class PasswordCredentialProvider implements CredentialProvider, Credentia
         } else {
             return Collections.EMPTY_SET;
         }
-    }
+    }*/
 
     @Override
     public boolean supportsCredentialType(String credentialType) {
-        return credentialType.equals(CredentialModel.PASSWORD);
+        return credentialType.equals(getType());
+    }
+
+    @Override
+    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
+        return createCredential(realm, user, input.getChallengeResponse());
+    }
+
+    @Override
+    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {
+
+    }
+
+    @Override
+    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {
+        return Collections.emptySet();
     }
 
     @Override
@@ -174,27 +233,26 @@ public class PasswordCredentialProvider implements CredentialProvider, Credentia
 
     @Override
     public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
-        if (! (input instanceof UserCredentialModel)) {
+        if (!(input instanceof UserCredentialModel)) {
             logger.debug("Expected instance of UserCredentialModel for CredentialInput");
             return false;
 
         }
-        UserCredentialModel cred = (UserCredentialModel)input;
-        if (cred.getValue() == null) {
+        if (input.getChallengeResponse() == null) {
             logger.debugv("Input password was null for user {0} ", user.getUsername());
             return false;
         }
-        CredentialModel password = getPassword(realm, user);
+        PasswordCredentialModel password = getPassword(realm, user);
         if (password == null) {
             logger.debugv("No password cached or stored for user {0} ", user.getUsername());
             return false;
         }
-        PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, password.getAlgorithm());
+        PasswordHashProvider hash = session.getProvider(PasswordHashProvider.class, password.getPasswordCredentialData().getAlgorithm());
         if (hash == null) {
-            logger.debugv("PasswordHashProvider {0} not found for user {1} ", password.getAlgorithm(), user.getUsername());
+            logger.debugv("PasswordHashProvider {0} not found for user {1} ", password.getPasswordCredentialData().getAlgorithm(), user.getUsername());
             return false;
         }
-        if (!hash.verify(cred.getValue(), password)) {
+        if (!hash.verify(input.getChallengeResponse(), password)) {
             logger.debugv("Failed password validation for user {0} ", user.getUsername());
             return false;
         }
@@ -210,8 +268,10 @@ public class PasswordCredentialProvider implements CredentialProvider, Credentia
             return true;
         }
 
-        CredentialModel newPassword = password.shallowClone();
-        hash.encode(cred.getValue(), policy.getHashIterations(), newPassword);
+        PasswordCredentialModel newPassword = hash.encodedCredential(input.getChallengeResponse(), policy.getHashIterations());
+        newPassword.setId(password.getId());
+        newPassword.setCreatedDate(password.getCreatedDate());
+        newPassword.setUserLabel(password.getUserLabel());
         getCredentialStore().updateCredential(realm, user, newPassword);
 
         UserCache userCache = session.userCache();
@@ -224,10 +284,15 @@ public class PasswordCredentialProvider implements CredentialProvider, Credentia
 
     @Override
     public void onCache(RealmModel realm, CachedUserModel user, UserModel delegate) {
-        List<CredentialModel> passwords = getCredentialStore().getStoredCredentialsByType(realm, user, CredentialModel.PASSWORD);
+        List<CredentialModel> passwords = getCredentialStore().getStoredCredentialsByType(realm, user, getType());
         if (passwords != null) {
             user.getCachedWith().put(PASSWORD_CACHE_KEY, passwords);
         }
 
     }
+
+    @Override
+    public String getType() {
+        return PasswordCredentialModel.TYPE;
+    }
 }
diff --git a/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java b/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java
index 16f789bfe1..26087936d0 100644
--- a/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java
+++ b/services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java
@@ -92,6 +92,11 @@ public class UserCredentialStoreManager implements UserCredentialManager, OnUser
         return getStoreForUser(user).getStoredCredentialByNameAndType(realm, user, name, type);
     }
 
+    @Override
+    public void moveCredentialTo(RealmModel realm, UserModel user, String id, String newPreviousCredentialId){
+        getStoreForUser(user).moveCredentialTo(realm, user, id, newPreviousCredentialId);
+    }
+
     @Override
     public boolean isValid(RealmModel realm, UserModel user, CredentialInput... inputs) {
         return isValid(realm, user, Arrays.asList(inputs));
diff --git a/services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java b/services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java
index 652cda2b8b..22cfff1433 100755
--- a/services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java
+++ b/services/src/main/java/org/keycloak/exportimport/util/ExportUtils.java
@@ -569,19 +569,7 @@ public class ExportUtils {
     }
 
     public static CredentialRepresentation exportCredential(CredentialModel userCred) {
-        CredentialRepresentation credRep = new CredentialRepresentation();
-        credRep.setType(userCred.getType());
-        credRep.setDevice(userCred.getDevice());
-        credRep.setHashedSaltedValue(userCred.getValue());
-        if (userCred.getSalt() != null) credRep.setSalt(Base64.encodeBytes(userCred.getSalt()));
-        credRep.setHashIterations(userCred.getHashIterations());
-        credRep.setCounter(userCred.getCounter());
-        credRep.setAlgorithm(userCred.getAlgorithm());
-        credRep.setDigits(userCred.getDigits());
-        credRep.setCreatedDate(userCred.getCreatedDate());
-        credRep.setConfig(userCred.getConfig());
-        credRep.setPeriod(userCred.getPeriod());
-        return credRep;
+        return ModelToRepresentation.toRepresentation(userCred);
     }
 
     // Streaming API
diff --git a/services/src/main/java/org/keycloak/forms/account/freemarker/model/TotpBean.java b/services/src/main/java/org/keycloak/forms/account/freemarker/model/TotpBean.java
index 9af43db732..47b6328f35 100644
--- a/services/src/main/java/org/keycloak/forms/account/freemarker/model/TotpBean.java
+++ b/services/src/main/java/org/keycloak/forms/account/freemarker/model/TotpBean.java
@@ -17,14 +17,20 @@
 
 package org.keycloak.forms.account.freemarker.model;
 
+import org.keycloak.credential.CredentialModel;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.OTPCredentialProvider;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.OTPPolicy;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.HmacOTP;
 import org.keycloak.utils.TotpUtils;
 
 import javax.ws.rs.core.UriBuilder;
+import java.util.Collections;
+import java.util.List;
 
 
 /**
@@ -38,10 +44,16 @@ public class TotpBean {
     private final String totpSecretQrCode;
     private final boolean enabled;
     private final UriBuilder uriBuilder;
+    private final List<CredentialModel> otpCredentials;
 
     public TotpBean(KeycloakSession session, RealmModel realm, UserModel user, UriBuilder uriBuilder) {
         this.uriBuilder = uriBuilder;
-        this.enabled = session.userCredentialManager().isConfiguredFor(realm, user, realm.getOTPPolicy().getType());
+        this.enabled = ((OTPCredentialProvider)session.getProvider(CredentialProvider.class, "keycloak-otp")).isConfiguredFor(realm, user);
+        if (enabled) {
+            otpCredentials = session.userCredentialManager().getStoredCredentialsByType(realm, user, OTPCredentialModel.TYPE);
+        } else {
+            otpCredentials = Collections.EMPTY_LIST;
+        }
 
         this.realm = realm;
         this.totpSecret = HmacOTP.generateSecret(20);
@@ -77,5 +89,9 @@ public class TotpBean {
         return realm.getOTPPolicy();
     }
 
+    public List<CredentialModel> getOtpCredentials() {
+        return otpCredentials;
+    }
+
 }
 
diff --git a/services/src/main/java/org/keycloak/forms/login/freemarker/FreeMarkerLoginFormsProvider.java b/services/src/main/java/org/keycloak/forms/login/freemarker/FreeMarkerLoginFormsProvider.java
index 80cfe53a29..6815176c1a 100755
--- a/services/src/main/java/org/keycloak/forms/login/freemarker/FreeMarkerLoginFormsProvider.java
+++ b/services/src/main/java/org/keycloak/forms/login/freemarker/FreeMarkerLoginFormsProvider.java
@@ -18,6 +18,7 @@ package org.keycloak.forms.login.freemarker;
 
 import org.jboss.logging.Logger;
 import org.keycloak.OAuth2Constants;
+import org.keycloak.authentication.AuthenticationFlowContext;
 import org.keycloak.authentication.requiredactions.util.UpdateProfileContext;
 import org.keycloak.authentication.requiredactions.util.UserUpdateProfileContext;
 import org.keycloak.broker.provider.BrokeredIdentityContext;
@@ -36,7 +37,13 @@ import org.keycloak.forms.login.freemarker.model.RequiredActionUrlFormatterMetho
 import org.keycloak.forms.login.freemarker.model.TotpBean;
 import org.keycloak.forms.login.freemarker.model.UrlBean;
 import org.keycloak.forms.login.freemarker.model.X509ConfirmBean;
-import org.keycloak.models.*;
+import org.keycloak.models.ClientModel;
+import org.keycloak.models.ClientScopeModel;
+import org.keycloak.models.Constants;
+import org.keycloak.models.IdentityProviderModel;
+import org.keycloak.models.KeycloakSession;
+import org.keycloak.models.RealmModel;
+import org.keycloak.models.UserModel;
 import org.keycloak.models.utils.FormMessage;
 import org.keycloak.services.Urls;
 import org.keycloak.services.messages.Messages;
@@ -61,8 +68,14 @@ import javax.ws.rs.core.UriInfo;
 import java.io.IOException;
 import java.net.URI;
 import java.text.MessageFormat;
-import java.util.*;
-
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Properties;
 
 import static org.keycloak.models.UserModel.RequiredAction.UPDATE_PASSWORD;
 
@@ -80,6 +93,7 @@ public class FreeMarkerLoginFormsProvider implements LoginFormsProvider {
     protected Map<String, String> httpResponseHeaders = new HashMap<>();
     protected URI actionUri;
     protected String execution;
+    protected AuthenticationFlowContext context;
 
     protected List<FormMessage> messages = null;
     protected MessageType messageType = MessageType.ERROR;
@@ -173,11 +187,16 @@ public class FreeMarkerLoginFormsProvider implements LoginFormsProvider {
         createCommonAttributes(theme, locale, messagesBundle, uriBuilder, page);
 
         attributes.put("login", new LoginBean(formData));
-
         if (status != null) {
             attributes.put("statusCode", status.getStatusCode());
         }
 
+        if (context != null) {
+            attributes.put("authenticationSelections", context.getAuthenticationSelections());
+            attributes.put("selectedCredential", context.getSelectedCredentialId());
+        }
+        attributes.put(Constants.EXECUTION, execution);
+
         switch (page) {
             case LOGIN_CONFIG_TOTP:
                 attributes.put("totp", new TotpBean(session, realm, user, uriInfo.getRequestUriBuilder()));
@@ -383,13 +402,13 @@ public class FreeMarkerLoginFormsProvider implements LoginFormsProvider {
             attributes.put("url", new UrlBean(realm, theme, baseUri, this.actionUri));
             attributes.put("requiredActionUrl", new RequiredActionUrlFormatterMethod(realm, baseUri));
 
+
             if (realm.isInternationalizationEnabled()) {
                 UriBuilder b;
                 if (page != null) {
                     switch (page) {
                         case LOGIN:
-                            b = UriBuilder.fromUri(Urls.realmLoginPage(baseUri, realm.getName()));
-                            break;
+                        case LOGIN_USERNAME:
                         case X509_CONFIRM:
                             b = UriBuilder.fromUri(Urls.realmLoginPage(baseUri, realm.getName()));
                             break;
@@ -446,10 +465,18 @@ public class FreeMarkerLoginFormsProvider implements LoginFormsProvider {
     }
 
     @Override
-    public Response createLogin() {
+    public Response createLoginUsernamePassword() {
         return createResponse(LoginFormsPages.LOGIN);
     }
 
+    public Response createLoginUsername(){
+        return createResponse(LoginFormsPages.LOGIN_USERNAME);
+    };
+
+    public Response createLoginPassword(){
+        return createResponse(LoginFormsPages.LOGIN_PASSWORD);
+    };
+
     @Override
     public Response createPasswordReset() {
         return createResponse(LoginFormsPages.LOGIN_RESET_PASSWORD);
@@ -667,6 +694,11 @@ public class FreeMarkerLoginFormsProvider implements LoginFormsProvider {
         return this;
     }
 
+    public LoginFormsProvider setAuthContext(AuthenticationFlowContext context){
+        this.context = context;
+        return this;
+    }
+
     @Override
     public void close() {
     }
diff --git a/services/src/main/java/org/keycloak/forms/login/freemarker/Templates.java b/services/src/main/java/org/keycloak/forms/login/freemarker/Templates.java
index 73921a595e..40f30fd9ed 100755
--- a/services/src/main/java/org/keycloak/forms/login/freemarker/Templates.java
+++ b/services/src/main/java/org/keycloak/forms/login/freemarker/Templates.java
@@ -28,8 +28,12 @@ public class Templates {
         switch (page) {
             case LOGIN:
                 return "login.ftl";
+            case LOGIN_USERNAME:
+                return "login-username.ftl";
+            case LOGIN_PASSWORD:
+                return "login-password.ftl";
             case LOGIN_TOTP:
-                return "login-totp.ftl";
+                return "login-otp.ftl";
             case LOGIN_CONFIG_TOTP:
                 return "login-config-totp.ftl";
             case LOGIN_VERIFY_EMAIL:
diff --git a/services/src/main/java/org/keycloak/forms/login/freemarker/model/TotpBean.java b/services/src/main/java/org/keycloak/forms/login/freemarker/model/TotpBean.java
index 84bbfecfa0..2b67bf1c61 100755
--- a/services/src/main/java/org/keycloak/forms/login/freemarker/model/TotpBean.java
+++ b/services/src/main/java/org/keycloak/forms/login/freemarker/model/TotpBean.java
@@ -21,6 +21,7 @@ import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.OTPPolicy;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.HmacOTP;
 import org.keycloak.utils.TotpUtils;
 
@@ -41,7 +42,7 @@ public class TotpBean {
     public TotpBean(KeycloakSession session, RealmModel realm, UserModel user, UriBuilder uriBuilder) {
         this.realm = realm;
         this.uriBuilder = uriBuilder;
-        this.enabled = session.userCredentialManager().isConfiguredFor(realm, user, CredentialModel.OTP);
+        this.enabled = session.userCredentialManager().isConfiguredFor(realm, user, OTPCredentialModel.TYPE);
         this.totpSecret = HmacOTP.generateSecret(20);
         this.totpSecretEncoded = TotpUtils.encode(totpSecret);
         this.totpSecretQrCode = TotpUtils.qrCode(totpSecret, realm, user);
diff --git a/services/src/main/java/org/keycloak/forms/login/freemarker/model/UrlBean.java b/services/src/main/java/org/keycloak/forms/login/freemarker/model/UrlBean.java
index 4b5052a4b9..d96f777c6f 100755
--- a/services/src/main/java/org/keycloak/forms/login/freemarker/model/UrlBean.java
+++ b/services/src/main/java/org/keycloak/forms/login/freemarker/model/UrlBean.java
@@ -54,6 +54,10 @@ public class UrlBean {
         return Urls.realmLoginRestartPage(baseURI, realm).toString();
     }
 
+    public boolean hasAction()  {
+        return actionuri != null;
+    }
+
     public String getRegistrationAction() {
         if (this.actionuri != null) {
             return this.actionuri.toString();
diff --git a/services/src/main/java/org/keycloak/protocol/saml/profile/ecp/authenticator/HttpBasicAuthenticatorFactory.java b/services/src/main/java/org/keycloak/protocol/saml/profile/ecp/authenticator/HttpBasicAuthenticatorFactory.java
index 01adca2dc0..37a548fd38 100755
--- a/services/src/main/java/org/keycloak/protocol/saml/profile/ecp/authenticator/HttpBasicAuthenticatorFactory.java
+++ b/services/src/main/java/org/keycloak/protocol/saml/profile/ecp/authenticator/HttpBasicAuthenticatorFactory.java
@@ -17,26 +17,15 @@
 
 package org.keycloak.protocol.saml.profile.ecp.authenticator;
 
-import org.jboss.resteasy.spi.HttpRequest;
 import org.keycloak.Config;
-import org.keycloak.authentication.AuthenticationFlowContext;
-import org.keycloak.authentication.AuthenticationFlowError;
 import org.keycloak.authentication.Authenticator;
 import org.keycloak.authentication.AuthenticatorFactory;
-import org.keycloak.common.util.Base64;
-import org.keycloak.events.Errors;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.AuthenticationExecutionModel.Requirement;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.KeycloakSessionFactory;
-import org.keycloak.models.RealmModel;
-import org.keycloak.models.UserCredentialModel;
-import org.keycloak.models.UserModel;
 import org.keycloak.provider.ProviderConfigProperty;
 
-import javax.ws.rs.core.HttpHeaders;
-import javax.ws.rs.core.Response;
-import java.io.IOException;
 import java.util.List;
 
 /**
diff --git a/services/src/main/java/org/keycloak/services/DefaultKeycloakSession.java b/services/src/main/java/org/keycloak/services/DefaultKeycloakSession.java
index f280ea73ac..3daa3872b3 100644
--- a/services/src/main/java/org/keycloak/services/DefaultKeycloakSession.java
+++ b/services/src/main/java/org/keycloak/services/DefaultKeycloakSession.java
@@ -44,11 +44,12 @@ import org.keycloak.storage.federated.UserFederatedStorageProvider;
 import org.keycloak.theme.DefaultThemeManager;
 
 import java.util.HashMap;
-import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.function.Consumer;
+import java.util.stream.Collectors;
 
 /**
  * @author <a href="mailto:sthorger@redhat.com">Stian Thorgersen</a>
@@ -57,7 +58,7 @@ public class DefaultKeycloakSession implements KeycloakSession {
 
     private final DefaultKeycloakSessionFactory factory;
     private final Map<Integer, Provider> providers = new HashMap<>();
-    private final List<Provider> closable = new LinkedList<Provider>();
+    private final List<Provider> closable = new LinkedList<>();
     private final DefaultKeycloakTransactionManager transactionManager;
     private final Map<String, Object> attributes = new HashMap<>();
     private RealmProvider model;
@@ -109,9 +110,10 @@ public class DefaultKeycloakSession implements KeycloakSession {
     }
 
     @Override
+    @SuppressWarnings("unchecked")
     public <T> T getAttribute(String attribute, Class<T> clazz) {
         Object value = getAttribute(attribute);
-        return value != null && clazz.isInstance(value) ? (T) value : null;
+        return clazz.isInstance(value) ? (T) value : null;
     }
 
     @Override
@@ -186,31 +188,28 @@ public class DefaultKeycloakSession implements KeycloakSession {
         return userCredentialStorageManager;
     }
 
+    @SuppressWarnings("unchecked")
     public <T extends Provider> T getProvider(Class<T> clazz) {
         Integer hash = clazz.hashCode();
-        T provider = (T) providers.get(hash);
-        if (provider == null) {
+        return (T) providers.computeIfAbsent(hash, k -> {
             ProviderFactory<T> providerFactory = factory.getProviderFactory(clazz);
             if (providerFactory != null) {
-                provider = providerFactory.create(this);
-                providers.put(hash, provider);
+                return providerFactory.create(DefaultKeycloakSession.this);
             }
-        }
-        return provider;
+            return null;
+        });
     }
 
+    @SuppressWarnings("unchecked")
     public <T extends Provider> T getProvider(Class<T> clazz, String id) {
         Integer hash = clazz.hashCode() + id.hashCode();
-        T provider = (T) providers.get(hash);
-        if (provider == null) {
+        return (T) providers.computeIfAbsent(hash, k -> {
             ProviderFactory<T> providerFactory = factory.getProviderFactory(clazz, id);
-
             if (providerFactory != null) {
-                provider = providerFactory.create(this);
-                providers.put(hash, provider);
+                return providerFactory.create(DefaultKeycloakSession.this);
             }
-        }
-        return provider;
+            return null;
+        });
     }
 
     @Override
@@ -227,6 +226,7 @@ public class DefaultKeycloakSession implements KeycloakSession {
             return null;
         }
 
+        @SuppressWarnings("unchecked")
         ComponentFactory<T, T> componentFactory = (ComponentFactory<T, T>) providerFactory;
         T provider = componentFactory.create(this, componentModel);
         enlistForClose(provider);
@@ -241,11 +241,9 @@ public class DefaultKeycloakSession implements KeycloakSession {
 
     @Override
     public <T extends Provider> Set<T> getAllProviders(Class<T> clazz) {
-        Set<T> providers = new HashSet<T>();
-        for (String id : listProviderIds(clazz)) {
-            providers.add(getProvider(clazz, id));
-        }
-        return providers;
+        return listProviderIds(clazz).stream()
+            .map(id -> getProvider(clazz, id))
+            .collect(Collectors.toSet());
     }
 
     @Override
@@ -303,17 +301,14 @@ public class DefaultKeycloakSession implements KeycloakSession {
     }
 
     public void close() {
-        for (Provider p : providers.values()) {
+        Consumer<? super Provider> safeClose = p -> {
             try {
                 p.close();
             } catch (Exception e) {
+                // Ignore exception
             }
-        }
-        for (Provider p : closable) {
-            try {
-                p.close();
-            } catch (Exception e) {
-            }
-        }
+        };
+        providers.values().forEach(safeClose);
+        closable.forEach(safeClose);
     }
 }
diff --git a/services/src/main/java/org/keycloak/services/managers/ApplianceBootstrap.java b/services/src/main/java/org/keycloak/services/managers/ApplianceBootstrap.java
index 84ce6f1c48..4bf4ea05af 100755
--- a/services/src/main/java/org/keycloak/services/managers/ApplianceBootstrap.java
+++ b/services/src/main/java/org/keycloak/services/managers/ApplianceBootstrap.java
@@ -103,9 +103,7 @@ public class ApplianceBootstrap {
         UserModel adminUser = session.users().addUser(realm, username);
         adminUser.setEnabled(true);
 
-        UserCredentialModel usrCredModel = new UserCredentialModel();
-        usrCredModel.setType(UserCredentialModel.PASSWORD);
-        usrCredModel.setValue(password);
+        UserCredentialModel usrCredModel = UserCredentialModel.password(password);
         session.userCredentialManager().updateCredential(realm, adminUser, usrCredModel);
 
         RoleModel adminRole = realm.getRole(AdminRoles.ADMIN);
diff --git a/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java b/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java
index cbd505438b..22037f0b16 100644
--- a/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java
+++ b/services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java
@@ -1,28 +1,34 @@
 package org.keycloak.services.resources.account;
 
+import org.jboss.resteasy.annotations.cache.NoCache;
+import org.keycloak.authentication.CredentialRegistrator;
+import org.keycloak.authentication.RequiredActionProvider;
 import org.keycloak.credential.CredentialModel;
 import org.keycloak.credential.CredentialProvider;
 import org.keycloak.credential.PasswordCredentialProvider;
 import org.keycloak.credential.PasswordCredentialProviderFactory;
 import org.keycloak.events.EventBuilder;
 import org.keycloak.events.EventType;
-import org.keycloak.models.KeycloakSession;
-import org.keycloak.models.RealmModel;
-import org.keycloak.models.UserCredentialModel;
-import org.keycloak.models.UserModel;
+import org.keycloak.models.*;
+import org.keycloak.models.utils.ModelToRepresentation;
+import org.keycloak.representations.idm.CredentialRepresentation;
 import org.keycloak.services.ErrorResponse;
+import org.keycloak.services.managers.Auth;
+import org.keycloak.services.messages.Messages;
 import org.keycloak.utils.MediaType;
 
 import javax.ws.rs.Consumes;
+import javax.ws.rs.DELETE;
 import javax.ws.rs.GET;
 import javax.ws.rs.POST;
+import javax.ws.rs.PUT;
 import javax.ws.rs.Path;
+import javax.ws.rs.PathParam;
 import javax.ws.rs.Produces;
 import javax.ws.rs.core.Response;
-import org.keycloak.models.AccountRoles;
-import org.keycloak.models.ModelException;
-import org.keycloak.services.managers.Auth;
-import org.keycloak.services.messages.Messages;
+import java.io.IOException;
+import java.util.List;
+import java.util.stream.Collectors;
 
 public class AccountCredentialResource {
 
@@ -40,10 +46,82 @@ public class AccountCredentialResource {
         realm = session.getContext().getRealm();
     }
 
+    @GET
+    @NoCache
+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)
+    public List<CredentialRepresentation> credentials(){
+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);
+        List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);
+        models.forEach(c -> c.setSecretData(null));
+        return models.stream().map(ModelToRepresentation::toRepresentation).collect(Collectors.toList());
+    }
+
+
+    @GET
+    @Path("registrators")
+    @NoCache
+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)
+    public List<String> getCredentialRegistrators(){
+        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);
+
+        return session.getContext().getRealm().getRequiredActionProviders().stream()
+                .map(RequiredActionProviderModel::getProviderId)
+                .filter(providerId ->  session.getProvider(RequiredActionProvider.class, providerId) instanceof CredentialRegistrator)
+                .collect(Collectors.toList());
+    }
+
+    /**
+     * Remove a credential for a user
+     *
+     */
+    @Path("{credentialId}")
+    @DELETE
+    @NoCache
+    public void removeCredential(final @PathParam("credentialId") String credentialId) {
+        auth.require(AccountRoles.MANAGE_ACCOUNT);
+        session.userCredentialManager().removeStoredCredential(realm, user, credentialId);
+    }
+
+    /**
+     * Update a credential label for a user
+     */
+    @PUT
+    @Consumes(javax.ws.rs.core.MediaType.TEXT_PLAIN)
+    @Path("{credentialId}/label")
+    public void setLabel(final @PathParam("credentialId") String credentialId, String userLabel) {
+        auth.require(AccountRoles.MANAGE_ACCOUNT);
+        // We update the existing credential representation and persist it
+        CredentialModel credential = session.userCredentialManager().getStoredCredentialById(realm, user, credentialId);
+        credential.setUserLabel(userLabel);
+        session.userCredentialManager().updateCredential(realm, user, credential);
+    }
+
+    /**
+     * Move a credential to a position behind another credential
+     * @param credentialId The credential to move
+     */
+    @Path("{credentialId}/moveToFirst")
+    @POST
+    public void moveToFirst(final @PathParam("credentialId") String credentialId){
+        moveCredentialAfter(credentialId, null);
+    }
+
+    /**
+     * Move a credential to a position behind another credential
+     * @param credentialId The credential to move
+     * @param newPreviousCredentialId The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
+     */
+    @Path("{credentialId}/moveAfter/{newPreviousCredentialId}")
+    @POST
+    public void moveCredentialAfter(final @PathParam("credentialId") String credentialId, final @PathParam("newPreviousCredentialId") String newPreviousCredentialId){
+        auth.require(AccountRoles.MANAGE_ACCOUNT);
+        session.userCredentialManager().moveCredentialTo(realm, user, credentialId, newPreviousCredentialId);
+    }
+
     @GET
     @Path("password")
     @Produces(MediaType.APPLICATION_JSON)
-    public PasswordDetails passwordDetails() {
+    public PasswordDetails passwordDetails() throws IOException {
         auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);
         
         PasswordCredentialProvider passwordProvider = (PasswordCredentialProvider) session.getProvider(CredentialProvider.class, PasswordCredentialProviderFactory.PROVIDER_ID);
diff --git a/services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java b/services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java
index 8b20d1d1aa..aef5b77bfa 100755
--- a/services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java
+++ b/services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java
@@ -24,12 +24,12 @@ import org.keycloak.authorization.model.Resource;
 import org.keycloak.authorization.model.Scope;
 import org.keycloak.authorization.store.PermissionTicketStore;
 import org.keycloak.authorization.store.PolicyStore;
-import org.keycloak.common.Profile;
-import org.keycloak.common.Profile.Feature;
 import org.keycloak.common.util.Base64Url;
 import org.keycloak.common.util.Time;
 import org.keycloak.common.util.UriUtils;
 import org.keycloak.credential.CredentialModel;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.OTPCredentialProvider;
 import org.keycloak.events.Details;
 import org.keycloak.events.Errors;
 import org.keycloak.events.Event;
@@ -47,10 +47,13 @@ import org.keycloak.models.IdentityProviderModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.ModelDuplicateException;
 import org.keycloak.models.ModelException;
+import org.keycloak.models.OTPPolicy;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
 import org.keycloak.models.UserSessionModel;
+import org.keycloak.models.credential.OTPCredentialModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.models.utils.CredentialValidation;
 import org.keycloak.models.utils.FormMessage;
 import org.keycloak.protocol.oidc.utils.RedirectUtils;
@@ -93,7 +96,6 @@ import java.net.URI;
 import java.nio.charset.StandardCharsets;
 import java.security.MessageDigest;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
@@ -109,7 +111,8 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
     private static final Logger logger = Logger.getLogger(AccountFormService.class);
 
-    private static Set<String> VALID_PATHS = new HashSet<String>();
+    private static Set<String> VALID_PATHS = new HashSet<>();
+
     static {
         for (Method m : AccountFormService.class.getMethods()) {
             Path p = m.getAnnotation(Path.class);
@@ -245,6 +248,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
     public static UriBuilder totpUrl(UriBuilder base) {
         return RealmsResource.accountUrl(base).path(AccountFormService.class, "totpPage");
     }
+
     @Path("totp")
     @GET
     public Response totpPage() {
@@ -255,6 +259,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
     public static UriBuilder passwordUrl(UriBuilder base) {
         return RealmsResource.accountUrl(base).path(AccountFormService.class, "passwordPage");
     }
+
     @Path("password")
     @GET
     public Response passwordPage() {
@@ -308,9 +313,9 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
     /**
      * Update account information.
-     *
+     * <p>
      * Form params:
-     *
+     * <p>
      * firstName
      * lastName
      * email
@@ -343,7 +348,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
         List<FormMessage> errors = Validation.validateUpdateProfileForm(realm, formData);
         if (errors != null && !errors.isEmpty()) {
             setReferrerOnPage();
-            return account.setErrors(Response.Status.BAD_REQUEST, errors).setProfileFormData(formData).createResponse(AccountPages.ACCOUNT);
+            return account.setErrors(Status.OK, errors).setProfileFormData(formData).createResponse(AccountPages.ACCOUNT);
         }
 
         try {
@@ -412,11 +417,11 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
         String clientId = formData.getFirst("clientId");
         if (clientId == null) {
-            return account.setError(Response.Status.BAD_REQUEST, Messages.CLIENT_NOT_FOUND).createResponse(AccountPages.APPLICATIONS);
+            return account.setError(Status.OK, Messages.CLIENT_NOT_FOUND).createResponse(AccountPages.APPLICATIONS);
         }
         ClientModel client = realm.getClientById(clientId);
         if (client == null) {
-            return account.setError(Response.Status.BAD_REQUEST, Messages.CLIENT_NOT_FOUND).createResponse(AccountPages.APPLICATIONS);
+            return account.setError(Status.OK, Messages.CLIENT_NOT_FOUND).createResponse(AccountPages.APPLICATIONS);
         }
 
         // Revoke grant in UserModel
@@ -442,9 +447,9 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
     /**
      * Update the TOTP for this account.
-     *
+     * <p>
      * form parameters:
-     *
+     * <p>
      * totp - otp generated by authenticator
      * totpSecret - totp secret to register
      *
@@ -473,36 +478,39 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
         UserModel user = auth.getUser();
 
+        OTPCredentialProvider otpCredentialProvider = (OTPCredentialProvider) session.getProvider(CredentialProvider.class, "keycloak-otp");
         if (action != null && action.equals("Delete")) {
-            session.userCredentialManager().disableCredentialType(realm, user, CredentialModel.OTP);
-
+            String credentialId = formData.getFirst("credentialId");
+            if (credentialId == null) {
+                setReferrerOnPage();
+                return account.setError(Status.OK, Messages.UNEXPECTED_ERROR_HANDLING_REQUEST).createResponse(AccountPages.TOTP);
+            }
+            otpCredentialProvider.deleteCredential(realm, user, credentialId);
             event.event(EventType.REMOVE_TOTP).client(auth.getClient()).user(auth.getUser()).success();
-
             setReferrerOnPage();
             return account.setSuccess(Messages.SUCCESS_TOTP_REMOVED).createResponse(AccountPages.TOTP);
         } else {
-            String totp = formData.getFirst("totp");
+            String challengeResponse = formData.getFirst("totp");
             String totpSecret = formData.getFirst("totpSecret");
+            String userLabel = formData.getFirst("userLabel");
 
-            if (Validation.isBlank(totp)) {
+            OTPPolicy policy = realm.getOTPPolicy();
+            OTPCredentialModel credentialModel = OTPCredentialModel.createFromPolicy(realm, totpSecret, userLabel);
+            if (Validation.isBlank(challengeResponse)) {
                 setReferrerOnPage();
-                return account.setError(Response.Status.BAD_REQUEST, Messages.MISSING_TOTP).createResponse(AccountPages.TOTP);
-            } else if (!CredentialValidation.validOTP(realm, totp, totpSecret)) {
+                return account.setError(Status.OK, Messages.MISSING_TOTP).createResponse(AccountPages.TOTP);
+            } else if (!CredentialValidation.validOTP(challengeResponse, credentialModel, policy.getLookAheadWindow())) {
                 setReferrerOnPage();
-                return account.setError(Response.Status.BAD_REQUEST, Messages.INVALID_TOTP).createResponse(AccountPages.TOTP);
+                return account.setError(Status.OK, Messages.INVALID_TOTP).createResponse(AccountPages.TOTP);
             }
 
-            UserCredentialModel credentials = new UserCredentialModel();
-            credentials.setType(realm.getOTPPolicy().getType());
-            credentials.setValue(totpSecret);
-            session.userCredentialManager().updateCredential(realm, user, credentials);
-
-            // to update counter
-            UserCredentialModel cred = new UserCredentialModel();
-            cred.setType(realm.getOTPPolicy().getType());
-            cred.setValue(totp);
-            session.userCredentialManager().isValid(realm, user, cred);
 
+            CredentialModel createdCredential = otpCredentialProvider.createCredential(realm, user, credentialModel);
+            UserCredentialModel credential = new UserCredentialModel(createdCredential.getId(), otpCredentialProvider.getType(), challengeResponse);
+            if (!otpCredentialProvider.isValid(realm, user, credential)) {
+                setReferrerOnPage();
+                return account.setError(Status.OK, Messages.INVALID_TOTP).createResponse(AccountPages.TOTP);
+            }
             event.event(EventType.UPDATE_TOTP).client(auth.getClient()).user(auth.getUser()).success();
 
             setReferrerOnPage();
@@ -512,9 +520,9 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
     /**
      * Update account password
-     *
+     * <p>
      * Form params:
-     *
+     * <p>
      * password - old password
      * password-new
      * pasword-confirm
@@ -550,27 +558,27 @@ public class AccountFormService extends AbstractSecuredLocalService {
             if (Validation.isBlank(password)) {
                 setReferrerOnPage();
                 errorEvent.error(Errors.PASSWORD_MISSING);
-                return account.setError(Response.Status.BAD_REQUEST, Messages.MISSING_PASSWORD).createResponse(AccountPages.PASSWORD);
+                return account.setError(Status.OK, Messages.MISSING_PASSWORD).createResponse(AccountPages.PASSWORD);
             }
 
             UserCredentialModel cred = UserCredentialModel.password(password);
             if (!session.userCredentialManager().isValid(realm, user, cred)) {
                 setReferrerOnPage();
                 errorEvent.error(Errors.INVALID_USER_CREDENTIALS);
-                return account.setError(Response.Status.BAD_REQUEST, Messages.INVALID_PASSWORD_EXISTING).createResponse(AccountPages.PASSWORD);
+                return account.setError(Status.OK, Messages.INVALID_PASSWORD_EXISTING).createResponse(AccountPages.PASSWORD);
             }
         }
 
         if (Validation.isBlank(passwordNew)) {
             setReferrerOnPage();
             errorEvent.error(Errors.PASSWORD_MISSING);
-            return account.setError(Response.Status.BAD_REQUEST, Messages.MISSING_PASSWORD).createResponse(AccountPages.PASSWORD);
+            return account.setError(Status.OK, Messages.MISSING_PASSWORD).createResponse(AccountPages.PASSWORD);
         }
 
         if (!passwordNew.equals(passwordConfirm)) {
             setReferrerOnPage();
             errorEvent.error(Errors.PASSWORD_CONFIRM_ERROR);
-            return account.setError(Response.Status.BAD_REQUEST, Messages.INVALID_PASSWORD_CONFIRM).createResponse(AccountPages.PASSWORD);
+            return account.setError(Status.OK, Messages.INVALID_PASSWORD_CONFIRM).createResponse(AccountPages.PASSWORD);
         }
 
         try {
@@ -621,12 +629,12 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
         if (Validation.isEmpty(providerId)) {
             setReferrerOnPage();
-            return account.setError(Response.Status.BAD_REQUEST, Messages.MISSING_IDENTITY_PROVIDER).createResponse(AccountPages.FEDERATED_IDENTITY);
+            return account.setError(Status.OK, Messages.MISSING_IDENTITY_PROVIDER).createResponse(AccountPages.FEDERATED_IDENTITY);
         }
         AccountSocialAction accountSocialAction = AccountSocialAction.getAction(action);
         if (accountSocialAction == null) {
             setReferrerOnPage();
-            return account.setError(Response.Status.BAD_REQUEST, Messages.INVALID_FEDERATED_IDENTITY_ACTION).createResponse(AccountPages.FEDERATED_IDENTITY);
+            return account.setError(Status.OK, Messages.INVALID_FEDERATED_IDENTITY_ACTION).createResponse(AccountPages.FEDERATED_IDENTITY);
         }
 
         boolean hasProvider = false;
@@ -639,12 +647,12 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
         if (!hasProvider) {
             setReferrerOnPage();
-            return account.setError(Response.Status.BAD_REQUEST, Messages.IDENTITY_PROVIDER_NOT_FOUND).createResponse(AccountPages.FEDERATED_IDENTITY);
+            return account.setError(Status.OK, Messages.IDENTITY_PROVIDER_NOT_FOUND).createResponse(AccountPages.FEDERATED_IDENTITY);
         }
 
         if (!user.isEnabled()) {
             setReferrerOnPage();
-            return account.setError(Response.Status.BAD_REQUEST, Messages.ACCOUNT_DISABLED).createResponse(AccountPages.FEDERATED_IDENTITY);
+            return account.setError(Status.OK, Messages.ACCOUNT_DISABLED).createResponse(AccountPages.FEDERATED_IDENTITY);
         }
 
         switch (accountSocialAction) {
@@ -654,7 +662,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
                 try {
                     String nonce = UUID.randomUUID().toString();
                     MessageDigest md = MessageDigest.getInstance("SHA-256");
-                    String input = nonce + auth.getSession().getId() +  client.getClientId() + providerId;
+                    String input = nonce + auth.getSession().getId() + client.getClientId() + providerId;
                     byte[] check = md.digest(input.getBytes(StandardCharsets.UTF_8));
                     String hash = Base64Url.encode(check);
                     URI linkUrl = Urls.identityProviderLinkRequest(this.session.getContext().getUri().getBaseUri(), providerId, realm.getName());
@@ -690,11 +698,11 @@ public class AccountFormService extends AbstractSecuredLocalService {
                         return account.setSuccess(Messages.IDENTITY_PROVIDER_REMOVED).createResponse(AccountPages.FEDERATED_IDENTITY);
                     } else {
                         setReferrerOnPage();
-                        return account.setError(Response.Status.BAD_REQUEST, Messages.FEDERATED_IDENTITY_REMOVING_LAST_PROVIDER).createResponse(AccountPages.FEDERATED_IDENTITY);
+                        return account.setError(Status.OK, Messages.FEDERATED_IDENTITY_REMOVING_LAST_PROVIDER).createResponse(AccountPages.FEDERATED_IDENTITY);
                     }
                 } else {
                     setReferrerOnPage();
-                    return account.setError(Response.Status.BAD_REQUEST, Messages.FEDERATED_IDENTITY_NOT_ACTIVE).createResponse(AccountPages.FEDERATED_IDENTITY);
+                    return account.setError(Status.OK, Messages.FEDERATED_IDENTITY_NOT_ACTIVE).createResponse(AccountPages.FEDERATED_IDENTITY);
                 }
             default:
                 throw new IllegalArgumentException();
@@ -715,7 +723,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
     @Path("resource/{resource_id}/grant")
     @POST
-    public Response grantPermission(@PathParam("resource_id") String resourceId, @FormParam("action") String action, @FormParam("permission_id") String[] permissionId, @FormParam("requester") String requester) {
+    public Response grantPermission(@PathParam("resource_id") String resourceId, @FormParam("action") String action, @FormParam("permission_id") List<String> permissionId, @FormParam("requester") String requester) {
         AuthorizationProvider authorization = session.getProvider(AuthorizationProvider.class);
         PermissionTicketStore ticketStore = authorization.getStoreFactory().getPermissionTicketStore();
         Resource resource = authorization.getStoreFactory().getResourceStore().findById(resourceId, null);
@@ -735,7 +743,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
         boolean isRevokePolicyAll = "revokePolicyAll".equals(action);
 
         if (isRevokePolicy || isRevokePolicyAll) {
-            List<String> ids = new ArrayList(Arrays.asList(permissionId));
+            List<String> ids = new ArrayList<>(permissionId);
             Iterator<String> iterator = ids.iterator();
             PolicyStore policyStore = authorization.getStoreFactory().getPolicyStore();
             Policy policy = null;
@@ -794,7 +802,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
                 PermissionTicket ticket = iterator.next();
 
                 if (isGrant) {
-                    if (permissionId != null && permissionId.length > 0 && !Arrays.asList(permissionId).contains(ticket.getId())) {
+                    if (permissionId != null && permissionId.size() > 0 && !permissionId.contains(ticket.getId())) {
                         continue;
                     }
                 }
@@ -803,7 +811,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
                     ticket.setGrantedTimestamp(System.currentTimeMillis());
                     iterator.remove();
                 } else if (isDeny || isRevoke) {
-                    if (permissionId != null && permissionId.length > 0 && Arrays.asList(permissionId).contains(ticket.getId())) {
+                    if (permissionId != null && permissionId.size() > 0 && permissionId.contains(ticket.getId())) {
                         iterator.remove();
                     }
                 }
@@ -823,7 +831,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
     @Path("resource/{resource_id}/share")
     @POST
-    public Response shareResource(@PathParam("resource_id") String resourceId, @FormParam("user_id") String[] userIds, @FormParam("scope_id") String[] scopes) {
+    public Response shareResource(@PathParam("resource_id") String resourceId, @FormParam("user_id") List<String> userIds, @FormParam("scope_id") List<String> scopes) {
         AuthorizationProvider authorization = session.getProvider(AuthorizationProvider.class);
         PermissionTicketStore ticketStore = authorization.getStoreFactory().getPermissionTicketStore();
         Resource resource = authorization.getStoreFactory().getResourceStore().findById(resourceId, null);
@@ -832,8 +840,8 @@ public class AccountFormService extends AbstractSecuredLocalService {
             return ErrorResponse.error("Invalid resource", Response.Status.BAD_REQUEST);
         }
 
-        if (userIds == null || userIds.length == 0) {
-            return account.setError(Status.BAD_REQUEST, Messages.MISSING_PASSWORD).createResponse(AccountPages.PASSWORD);
+        if (userIds == null || userIds.isEmpty()) {
+            return account.setError(Status.OK, Messages.MISSING_PASSWORD).createResponse(AccountPages.PASSWORD);
         }
 
         for (String id : userIds) {
@@ -848,7 +856,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
             }
 
             if (user == null) {
-                return account.setError(Status.BAD_REQUEST, Messages.INVALID_USER).createResponse(AccountPages.RESOURCE_DETAIL);
+                return account.setError(Status.OK, Messages.INVALID_USER).createResponse(AccountPages.RESOURCE_DETAIL);
             }
 
             Map<String, String> filters = new HashMap<>();
@@ -860,7 +868,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
             List<PermissionTicket> tickets = ticketStore.find(filters, resource.getResourceServer().getId(), -1, -1);
 
             if (tickets.isEmpty()) {
-                if (scopes != null && scopes.length > 0) {
+                if (scopes != null && !scopes.isEmpty()) {
                     for (String scope : scopes) {
                         PermissionTicket ticket = ticketStore.create(resourceId, scope, user.getId(), resource.getResourceServer());
                         ticket.setGrantedTimestamp(System.currentTimeMillis());
@@ -876,8 +884,8 @@ public class AccountFormService extends AbstractSecuredLocalService {
                         }
                     }
                 }
-            } else if (scopes != null && scopes.length > 0) {
-                List<String> grantScopes = new ArrayList<>(Arrays.asList(scopes));
+            } else if (scopes != null && !scopes.isEmpty()) {
+                List<String> grantScopes = new ArrayList<>(scopes);
 
                 for (PermissionTicket ticket : tickets) {
                     Scope scope = ticket.getScope();
@@ -899,7 +907,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
 
     @Path("resource")
     @POST
-    public Response processResourceActions(@FormParam("resource_id") String[] resourceIds, @FormParam("action") String action) {
+    public Response processResourceActions(@FormParam("resource_id") List<String> resourceIds, @FormParam("action") String action) {
         AuthorizationProvider authorization = session.getProvider(AuthorizationProvider.class);
         PermissionTicketStore ticketStore = authorization.getStoreFactory().getPermissionTicketStore();
 
@@ -943,7 +951,7 @@ public class AccountFormService extends AbstractSecuredLocalService {
     }
 
     public static boolean isPasswordSet(KeycloakSession session, RealmModel realm, UserModel user) {
-        return session.userCredentialManager().isConfiguredFor(realm, user, CredentialModel.PASSWORD);
+        return session.userCredentialManager().isConfiguredFor(realm, user, PasswordCredentialModel.TYPE);
     }
 
     private String[] getReferrer() {
diff --git a/services/src/main/java/org/keycloak/services/resources/account/CorsPreflightService.java b/services/src/main/java/org/keycloak/services/resources/account/CorsPreflightService.java
index f9c0fa6ec2..3bafc27237 100644
--- a/services/src/main/java/org/keycloak/services/resources/account/CorsPreflightService.java
+++ b/services/src/main/java/org/keycloak/services/resources/account/CorsPreflightService.java
@@ -23,7 +23,7 @@ public class CorsPreflightService {
      *
      * @return
      */
-    @Path("/")
+    @Path("{any:.*}")
     @OPTIONS
     public Response preflight() {
         Cors cors = Cors.add(request, Response.ok()).auth().allowedMethods("GET", "POST", "HEAD", "OPTIONS").preflight();
diff --git a/services/src/main/java/org/keycloak/services/resources/account/PasswordUtil.java b/services/src/main/java/org/keycloak/services/resources/account/PasswordUtil.java
index a178a1be10..88f19a6938 100644
--- a/services/src/main/java/org/keycloak/services/resources/account/PasswordUtil.java
+++ b/services/src/main/java/org/keycloak/services/resources/account/PasswordUtil.java
@@ -1,9 +1,9 @@
 package org.keycloak.services.resources.account;
 
-import org.keycloak.credential.CredentialModel;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 
 public class PasswordUtil {
 
@@ -16,7 +16,7 @@ public class PasswordUtil {
     }
 
     public boolean isConfigured(KeycloakSession session, RealmModel realm, UserModel user) {
-        return session.userCredentialManager().isConfiguredFor(realm, user, CredentialModel.PASSWORD);
+        return session.userCredentialManager().isConfiguredFor(realm, user, PasswordCredentialModel.TYPE);
     }
 
     public void update() {
diff --git a/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java b/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java
index 087aeb1246..7994c61d86 100755
--- a/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java
+++ b/services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java
@@ -509,9 +509,10 @@ public class AuthenticationManagementResource {
             if (execution.isAuthenticatorFlow()) {
                 AuthenticationFlowModel flowRef = realm.getAuthenticationFlowById(execution.getFlowId());
                 if (AuthenticationFlow.BASIC_FLOW.equals(flowRef.getProviderId())) {
-                    rep.getRequirementChoices().add(AuthenticationExecutionModel.Requirement.ALTERNATIVE.name());
                     rep.getRequirementChoices().add(AuthenticationExecutionModel.Requirement.REQUIRED.name());
+                    rep.getRequirementChoices().add(AuthenticationExecutionModel.Requirement.ALTERNATIVE.name());
                     rep.getRequirementChoices().add(AuthenticationExecutionModel.Requirement.DISABLED.name());
+                    rep.getRequirementChoices().add(AuthenticationExecutionModel.Requirement.OPTIONAL.name());
                 } else if (AuthenticationFlow.FORM_FLOW.equals(flowRef.getProviderId())) {
                     rep.getRequirementChoices().add(AuthenticationExecutionModel.Requirement.REQUIRED.name());
                     rep.getRequirementChoices().add(AuthenticationExecutionModel.Requirement.DISABLED.name());
@@ -1168,7 +1169,6 @@ public class AuthenticationManagementResource {
             throw new NotFoundException("Could not find authenticator config");
 
         }
-        List<AuthenticationFlowModel> flows = new LinkedList<>();
         for (AuthenticationFlowModel flow : realm.getAuthenticationFlows()) {
             for (AuthenticationExecutionModel exe : realm.getAuthenticationExecutions(flow.getId())) {
                 if (id.equals(exe.getAuthenticatorConfig())) {
diff --git a/services/src/main/java/org/keycloak/services/resources/admin/RealmAdminResource.java b/services/src/main/java/org/keycloak/services/resources/admin/RealmAdminResource.java
index d35ccaf698..01599a8cbc 100644
--- a/services/src/main/java/org/keycloak/services/resources/admin/RealmAdminResource.java
+++ b/services/src/main/java/org/keycloak/services/resources/admin/RealmAdminResource.java
@@ -24,9 +24,13 @@ import org.jboss.resteasy.spi.NotFoundException;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 import org.keycloak.Config;
 import org.keycloak.KeyPairVerifier;
+import org.keycloak.authentication.CredentialRegistrator;
+import org.keycloak.authentication.RequiredActionFactory;
+import org.keycloak.authentication.RequiredActionProvider;
 import org.keycloak.common.ClientConnection;
 import org.keycloak.common.VerificationException;
 import org.keycloak.common.util.PemUtils;
+import org.keycloak.credential.CredentialProvider;
 import org.keycloak.email.EmailTemplateProvider;
 import org.keycloak.events.Event;
 import org.keycloak.events.EventQuery;
@@ -41,17 +45,7 @@ import org.keycloak.exportimport.ClientDescriptionConverterFactory;
 import org.keycloak.exportimport.util.ExportOptions;
 import org.keycloak.exportimport.util.ExportUtils;
 import org.keycloak.keys.PublicKeyStorageProvider;
-import org.keycloak.models.ClientModel;
-import org.keycloak.models.ClientScopeModel;
-import org.keycloak.models.Constants;
-import org.keycloak.models.GroupModel;
-import org.keycloak.models.KeycloakSession;
-import org.keycloak.models.LDAPConstants;
-import org.keycloak.models.ModelDuplicateException;
-import org.keycloak.models.ModelException;
-import org.keycloak.models.RealmModel;
-import org.keycloak.models.UserModel;
-import org.keycloak.models.UserSessionModel;
+import org.keycloak.models.*;
 import org.keycloak.models.cache.CacheRealmProvider;
 import org.keycloak.models.cache.UserCache;
 import org.keycloak.models.utils.KeycloakModelUtils;
@@ -107,6 +101,7 @@ import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.stream.Collectors;
 
 import static org.keycloak.models.utils.StripSecretsUtils.stripForExport;
 import static org.keycloak.util.JsonSerialization.readValue;
@@ -1152,4 +1147,16 @@ public class RealmAdminResource {
         return resource;
     }
 
+    @GET
+    @Path("credential-registrators")
+    @NoCache
+    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)
+    public List<String> getCredentialRegistrators(){
+        auth.realm().requireViewRealm();
+        return session.getContext().getRealm().getRequiredActionProviders().stream()
+                .map(RequiredActionProviderModel::getProviderId)
+                .filter(providerId ->  session.getProvider(RequiredActionProvider.class, providerId) instanceof CredentialRegistrator)
+                .collect(Collectors.toList());
+    }
+
 }
diff --git a/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java b/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java
index 4d367fdf74..14b5ac347a 100755
--- a/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java
+++ b/services/src/main/java/org/keycloak/services/resources/admin/UserResource.java
@@ -19,7 +19,6 @@ package org.keycloak.services.resources.admin;
 import org.jboss.logging.Logger;
 import org.jboss.resteasy.annotations.cache.NoCache;
 import org.jboss.resteasy.spi.BadRequestException;
-import org.jboss.resteasy.spi.NotFoundException;
 import org.jboss.resteasy.spi.ResteasyProviderFactory;
 import org.keycloak.authentication.RequiredActionProvider;
 import org.keycloak.authentication.actiontoken.execactions.ExecuteActionsActionToken;
@@ -27,6 +26,8 @@ import org.keycloak.common.ClientConnection;
 import org.keycloak.common.Profile;
 import org.keycloak.common.util.Time;
 import org.keycloak.credential.CredentialModel;
+import org.keycloak.credential.CredentialProvider;
+import org.keycloak.credential.PasswordCredentialProvider;
 import org.keycloak.email.EmailException;
 import org.keycloak.email.EmailTemplateProvider;
 import org.keycloak.events.Details;
@@ -40,13 +41,11 @@ import org.keycloak.models.Constants;
 import org.keycloak.models.FederatedIdentityModel;
 import org.keycloak.models.GroupModel;
 import org.keycloak.models.IdentityProviderModel;
-import org.keycloak.models.ImpersonationSessionNote;
 import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.ModelDuplicateException;
 import org.keycloak.models.ModelException;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserConsentModel;
-import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserLoginFailureModel;
 import org.keycloak.models.UserManager;
 import org.keycloak.models.UserModel;
@@ -79,6 +78,7 @@ import org.keycloak.utils.ProfileHelper;
 import javax.ws.rs.Consumes;
 import javax.ws.rs.DELETE;
 import javax.ws.rs.GET;
+import javax.ws.rs.NotFoundException;
 import javax.ws.rs.POST;
 import javax.ws.rs.PUT;
 import javax.ws.rs.Path;
@@ -105,6 +105,7 @@ import java.util.Objects;
 import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
 
 import static org.keycloak.models.ImpersonationSessionNote.IMPERSONATOR_ID;
 import static org.keycloak.models.ImpersonationSessionNote.IMPERSONATOR_USERNAME;
@@ -477,6 +478,7 @@ public class UserResource {
         return result;
     }
 
+
     /**
      * Revoke consent and offline tokens for particular client from user
      *
@@ -562,36 +564,36 @@ public class UserResource {
     @PUT
     @Consumes(MediaType.APPLICATION_JSON)
     public void disableCredentialType(List<String> credentialTypes) {
-        auth.users().requireManage(user);
+        //TODO this is currently useless. To be replaced by a function to delete credentials
+        /*auth.users().requireManage(user);
         if (credentialTypes == null) return;
         for (String type : credentialTypes) {
             session.userCredentialManager().disableCredentialType(realm, user, type);
 
         }
-
-
+    */
     }
 
     /**
      * Set up a new password for the user.
      *
-     * @param pass The representation must contain a value and the type equals to "password"
+     * @param cred The representation must contain a rawPassword with the plain-text password
      */
     @Path("reset-password")
     @PUT
     @Consumes(MediaType.APPLICATION_JSON)
-    public void resetPassword(CredentialRepresentation pass) {
+    public void resetPassword(CredentialRepresentation cred) {
         auth.users().requireManage(user);
-        if (pass == null || pass.getValue() == null || !CredentialRepresentation.PASSWORD.equals(pass.getType())) {
+        if (cred == null || cred.getValue() == null) {
             throw new BadRequestException("No password provided");
         }
-        if (Validation.isBlank(pass.getValue())) {
+        if (Validation.isBlank(cred.getValue())) {
             throw new BadRequestException("Empty password not allowed");
         }
 
-        UserCredentialModel cred = UserCredentialModel.password(pass.getValue(), true);
         try {
-            session.userCredentialManager().updateCredential(realm, user, cred);
+            PasswordCredentialProvider provider = (PasswordCredentialProvider)session.getProvider(CredentialProvider.class, "keycloak-password");
+            provider.createCredential(realm, user, cred.getValue());
         } catch (IllegalStateException ise) {
             throw new BadRequestException("Resetting to N old passwords is not allowed.");
         } catch (ReadOnlyException mre) {
@@ -601,23 +603,103 @@ public class UserResource {
             throw new ErrorResponseException(e.getMessage(), MessageFormat.format(messages.getProperty(e.getMessage(), e.getMessage()), e.getParameters()),
                     Status.BAD_REQUEST);
         }
-        if (pass.isTemporary() != null && pass.isTemporary()) user.addRequiredAction(UserModel.RequiredAction.UPDATE_PASSWORD);
+        if (cred.isTemporary() != null && cred.isTemporary()) user.addRequiredAction(UserModel.RequiredAction.UPDATE_PASSWORD);
 
         adminEvent.operation(OperationType.ACTION).resourcePath(session.getContext().getUri()).success();
     }
 
+
+    @GET
+    @Path("credentials")
+    @NoCache
+    @Produces(MediaType.APPLICATION_JSON)
+    public List<CredentialRepresentation> credentials(){
+        auth.users().requireManage(user);
+        List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);
+        models.forEach(c -> c.setSecretData(null));
+        return models.stream().map(ModelToRepresentation::toRepresentation).collect(Collectors.toList());
+    }
+
+
     /**
-     * Remove TOTP from the user
+     * Remove a credential for a user
      *
      */
-    @Path("remove-totp")
+    @Path("credentials/{credentialId}")
+    @DELETE
+    @NoCache
+    public void removeCredential(final @PathParam("credentialId") String credentialId) {
+        auth.users().requireManage(user);
+        session.userCredentialManager().removeStoredCredential(realm, user, credentialId);
+        adminEvent.operation(OperationType.ACTION).resourcePath(session.getContext().getUri()).success();
+    }
+
+    /**
+     * Update a credential for a user
+     */
     @PUT
     @Consumes(MediaType.APPLICATION_JSON)
-    public void removeTotp() {
+    @Path("credentials/{credentialId}")
+    public void updateCredential(final @PathParam("credentialId") String credentialId, CredentialRepresentation credentialRepresentation){
         auth.users().requireManage(user);
+        // We update the existing credential representation and persist it
+        CredentialModel credential = session.userCredentialManager().getStoredCredentialById(realm, user, credentialId);
+        if (credential == null) {
+            // we do this to make sure somebody can't phish ids
+            if (auth.users().canQuery()) throw new NotFoundException("User not found");
+            else throw new ForbiddenException();
+        }
+        updateCredentialFromRep(credential, credentialRepresentation);
+        session.userCredentialManager().updateCredential(realm, user, credential);
+    }
 
-        session.userCredentialManager().disableCredentialType(realm, user, CredentialModel.OTP);
-        adminEvent.operation(OperationType.ACTION).resourcePath(session.getContext().getUri()).success();
+    /**
+     * Update a credential model. Inspiration : org.keycloak.servUserCredentialStoreManagerices.resources.admin.UserResource#updateUserFromRep()
+     * @param credential
+     * @param rep
+     */
+    private void updateCredentialFromRep(CredentialModel credential, CredentialRepresentation rep) {
+        // On purpose, for obvious security reasons, I omitted "secretData" and "type"
+        if (rep.getId() != null) {
+            credential.setId(rep.getId());
+        }
+        if (rep.getCreatedDate() != null) {
+            credential.setCreatedDate(rep.getCreatedDate());
+        }
+        if (rep.getCredentialData() != null) {
+            credential.setCredentialData(rep.getCredentialData());
+        }
+        if (rep.getUserLabel() != null) {
+            credential.setUserLabel(rep.getUserLabel());
+        }
+    }
+
+    /**
+     * Move a credential to a position behind another credential
+     * @param credentialId The credential to move
+     */
+    @Path("credentials/{credentialId}/moveToFirst")
+    @POST
+    public void moveToFirst(final @PathParam("credentialId") String credentialId){
+        moveCredentialAfter(credentialId, null);
+    }
+
+    /**
+     * Move a credential to a position behind another credential
+     * @param credentialId The credential to move
+     * @param newPreviousCredentialId The credential that will be the previous element in the list. If set to null, the moved credential will be the first element in the list.
+     */
+    @Path("credentials/{credentialId}/moveAfter/{newPreviousCredentialId}")
+    @POST
+    public void moveCredentialAfter(final @PathParam("credentialId") String credentialId, final @PathParam("newPreviousCredentialId") String newPreviousCredentialId){
+        auth.users().requireManage(user);
+        CredentialModel credential = session.userCredentialManager().getStoredCredentialById(realm, user, credentialId);
+        if (credential == null) {
+            // we do this to make sure somebody can't phish ids
+            if (auth.users().canQuery()) throw new NotFoundException("User not found");
+            else throw new ForbiddenException();
+        }
+        session.userCredentialManager().moveCredentialTo(realm, user, credentialId, newPreviousCredentialId);
     }
 
     /**
diff --git a/services/src/main/resources/META-INF/services/org.keycloak.authentication.AuthenticatorFactory b/services/src/main/resources/META-INF/services/org.keycloak.authentication.AuthenticatorFactory
index 121bd9e749..1f62943a09 100755
--- a/services/src/main/resources/META-INF/services/org.keycloak.authentication.AuthenticatorFactory
+++ b/services/src/main/resources/META-INF/services/org.keycloak.authentication.AuthenticatorFactory
@@ -17,10 +17,14 @@
 
 org.keycloak.authentication.authenticators.browser.CookieAuthenticatorFactory
 org.keycloak.authentication.authenticators.browser.UsernamePasswordFormFactory
+org.keycloak.authentication.authenticators.browser.UsernameFormFactory
+org.keycloak.authentication.authenticators.browser.PasswordFormFactory
 org.keycloak.authentication.authenticators.browser.OTPFormAuthenticatorFactory
 org.keycloak.authentication.authenticators.browser.ScriptBasedAuthenticatorFactory
 org.keycloak.authentication.authenticators.browser.SpnegoAuthenticatorFactory
 org.keycloak.authentication.authenticators.browser.IdentityProviderAuthenticatorFactory
+org.keycloak.authentication.authenticators.conditional.ConditionalBlockRoleAuthenticatorFactory
+org.keycloak.authentication.authenticators.conditional.ConditionalBlockUserConfiguredAuthenticatorFactory
 org.keycloak.authentication.authenticators.directgrant.ValidateOTP
 org.keycloak.authentication.authenticators.directgrant.ValidatePassword
 org.keycloak.authentication.authenticators.directgrant.ValidateUsername
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/DummyUserFederationProvider.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/DummyUserFederationProvider.java
index c1ff83bdb2..1a6825ad22 100644
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/DummyUserFederationProvider.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/DummyUserFederationProvider.java
@@ -27,6 +27,7 @@ import org.keycloak.models.RealmModel;
 import org.keycloak.models.RoleModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.user.UserLookupProvider;
 import org.keycloak.storage.user.UserRegistrationProvider;
@@ -103,7 +104,7 @@ public class DummyUserFederationProvider implements UserStorageProvider,
     }
 
     public Set<String> getSupportedCredentialTypes() {
-        return Collections.singleton(UserCredentialModel.PASSWORD);
+        return Collections.singleton(PasswordCredentialModel.TYPE);
     }
 
     @Override
@@ -113,7 +114,7 @@ public class DummyUserFederationProvider implements UserStorageProvider,
 
     @Override
     public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
-        if (!CredentialModel.PASSWORD.equals(credentialType)) return false;
+        if (!PasswordCredentialModel.TYPE.equals(credentialType)) return false;
 
         if (user.getUsername().equals("test-user")) {
             return true;
@@ -123,14 +124,12 @@ public class DummyUserFederationProvider implements UserStorageProvider,
     }
 
     @Override
-    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
+    public boolean isValid(RealmModel realm, UserModel user, CredentialInput credentialInput) {
         if (user.getUsername().equals("test-user")) {
-            UserCredentialModel password = (UserCredentialModel)input;
-            if (password.getType().equals(UserCredentialModel.PASSWORD)) {
-                return "secret".equals(password.getValue());
-            }
+            return "secret".equals(credentialInput.getChallengeResponse());
         }
-        return false;    }
+        return false;
+    }
 
      @Override
     public void close() {
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/FailableHardcodedStorageProvider.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/FailableHardcodedStorageProvider.java
index 4c6ec3290a..b23946d67f 100644
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/FailableHardcodedStorageProvider.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/FailableHardcodedStorageProvider.java
@@ -27,6 +27,7 @@ import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.models.utils.UserModelDelegate;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.user.ImportedUserValidation;
@@ -72,7 +73,7 @@ public class FailableHardcodedStorageProvider implements UserStorageProvider, Us
     @Override
     public boolean supportsCredentialType(String credentialType) {
         checkForceFail();
-        return CredentialModel.PASSWORD.equals(credentialType);
+        return PasswordCredentialModel.TYPE.equals(credentialType);
     }
 
     @Override
@@ -81,8 +82,8 @@ public class FailableHardcodedStorageProvider implements UserStorageProvider, Us
         if (!(input instanceof UserCredentialModel)) return false;
         if (!user.getUsername().equals(username)) throw new RuntimeException("UNKNOWN USER!");
 
-        if (input.getType().equals(UserCredentialModel.PASSWORD)) {
-            password = ((UserCredentialModel)input).getValue();
+        if (input.getType().equals(PasswordCredentialModel.TYPE)) {
+            password = input.getChallengeResponse();
             return true;
 
         } else {
@@ -105,16 +106,15 @@ public class FailableHardcodedStorageProvider implements UserStorageProvider, Us
     @Override
     public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
         checkForceFail();
-        return CredentialModel.PASSWORD.equals(credentialType);
+        return PasswordCredentialModel.TYPE.equals(credentialType);
     }
 
     @Override
-    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
+    public boolean isValid(RealmModel realm, UserModel user, CredentialInput credentialInput) {
         checkForceFail();
-        if (!(input instanceof UserCredentialModel)) return false;
         if (!user.getUsername().equals("billb")) throw new RuntimeException("UNKNOWN USER!");
-        if (input.getType().equals(UserCredentialModel.PASSWORD)) {
-            return password != null && password.equals( ((UserCredentialModel)input).getValue());
+        if (credentialInput.getType().equals(PasswordCredentialModel.TYPE)) {
+            return password != null && password.equals(credentialInput.getChallengeResponse());
         } else {
             return false;
         }
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java
index 2e993855e9..6a8d309fa9 100644
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/PassThroughFederatedUserStorageProvider.java
@@ -25,6 +25,7 @@ import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.storage.StorageId;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.adapter.AbstractUserAdapterFederatedStorage;
@@ -47,7 +48,7 @@ public class PassThroughFederatedUserStorageProvider implements
         CredentialInputUpdater
 {
 
-    public static final Set<String> CREDENTIAL_TYPES = Collections.singleton(UserCredentialModel.PASSWORD);
+    public static final Set<String> CREDENTIAL_TYPES = Collections.singleton(PasswordCredentialModel.TYPE);
     public static final String PASSTHROUGH_USERNAME = "passthrough";
     public static final String INITIAL_PASSWORD = "secret";
     private KeycloakSession session;
@@ -69,20 +70,19 @@ public class PassThroughFederatedUserStorageProvider implements
 
     @Override
     public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
-        if (!CredentialModel.PASSWORD.equals(credentialType)) return false;
+        if (!PasswordCredentialModel.TYPE.equals(credentialType)) return false;
         return true;
     }
 
     @Override
     public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
-        UserCredentialModel password = (UserCredentialModel)input;
-        if (password.getType().equals(UserCredentialModel.PASSWORD)) {
-             if (INITIAL_PASSWORD.equals(password.getValue())) {
+        if (input.getType().equals(PasswordCredentialModel.TYPE)) {
+             if (INITIAL_PASSWORD.equals(input.getChallengeResponse())) {
                  return true;
              }
             List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), "CLEAR_TEXT_PASSWORD");
             if (existing.isEmpty()) return false;
-            return existing.get(0).getConfig().getFirst("VALUE").equals(password.getValue());
+            return existing.get(0).getSecretData().equals("{\"value\":\"" + input.getChallengeResponse() + "\"}");
         }
         return false;
     }
@@ -90,18 +90,17 @@ public class PassThroughFederatedUserStorageProvider implements
     @Override
     public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {
         // testing federated credential attributes
-        UserCredentialModel password = (UserCredentialModel)input;
-        if (password.getType().equals(UserCredentialModel.PASSWORD)) {
+        if (input.getType().equals(PasswordCredentialModel.TYPE)) {
             List<CredentialModel> existing = session.userFederatedStorage().getStoredCredentialsByType(realm, user.getId(), "CLEAR_TEXT_PASSWORD");
             if (existing.isEmpty()) {
                 CredentialModel model = new CredentialModel();
                 model.setType("CLEAR_TEXT_PASSWORD");
-                model.getConfig().putSingle("VALUE", password.getValue());
+                model.setSecretData("{\"value\":\"" + input.getChallengeResponse() + "\"}");
                 session.userFederatedStorage().createCredential(realm, user.getId(), model);
             } else {
                 CredentialModel model = existing.get(0);
                 model.setType("CLEAR_TEXT_PASSWORD");
-                model.getConfig().putSingle("VALUE", password.getValue());
+                model.setSecretData("{\"value\":\"" + input.getChallengeResponse() + "\"}");
                 session.userFederatedStorage().updateCredential(realm, user.getId(), model);
 
             }
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java
index b2f80bbeea..b0005d8faf 100644
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserMapStorage.java
@@ -27,6 +27,7 @@ import org.keycloak.models.RealmModel;
 import org.keycloak.models.RoleModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.storage.StorageId;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.adapter.AbstractUserAdapterFederatedStorage;
@@ -92,7 +93,7 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,
 
     @Override
     public boolean supportsCredentialType(String credentialType) {
-        return CredentialModel.PASSWORD.equals(credentialType);
+        return PasswordCredentialModel.TYPE.equals(credentialType);
     }
 
     @Override
@@ -100,8 +101,8 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,
         if (!(input instanceof UserCredentialModel)) {
             return false;
         }
-        if (input.getType().equals(UserCredentialModel.PASSWORD)) {
-            userPasswords.put(user.getUsername(), ((UserCredentialModel) input).getValue());
+        if (input.getType().equals(PasswordCredentialModel.TYPE)) {
+            userPasswords.put(user.getUsername(), input.getChallengeResponse());
             return true;
 
         } else {
@@ -121,7 +122,7 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,
 
     @Override
     public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
-        return CredentialModel.PASSWORD.equals(credentialType);
+        return PasswordCredentialModel.TYPE.equals(credentialType);
     }
 
     @Override
@@ -129,9 +130,9 @@ public class UserMapStorage implements UserLookupProvider, UserStorageProvider,
         if (!(input instanceof UserCredentialModel)) {
             return false;
         }
-        if (input.getType().equals(UserCredentialModel.PASSWORD)) {
+        if (input.getType().equals(PasswordCredentialModel.TYPE)) {
             String pw = userPasswords.get(user.getUsername());
-            return pw != null && pw.equals(((UserCredentialModel) input).getValue());
+            return pw != null && pw.equals(input.getChallengeResponse());
         } else {
             return false;
         }
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java
index b4ec0244c6..a0c11afbb7 100644
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/UserPropertyFileStorage.java
@@ -25,6 +25,7 @@ import org.keycloak.models.RealmModel;
 import org.keycloak.models.RoleModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.storage.StorageId;
 import org.keycloak.storage.UserStorageProvider;
 import org.keycloak.storage.adapter.AbstractUserAdapter;
@@ -118,20 +119,20 @@ public class UserPropertyFileStorage implements UserLookupProvider, UserStorageP
 
     @Override
     public boolean supportsCredentialType(String credentialType) {
-        return credentialType.equals(UserCredentialModel.PASSWORD);
+        return credentialType.equals(PasswordCredentialModel.TYPE);
     }
 
     @Override
     public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {
-        return credentialType.equals(UserCredentialModel.PASSWORD) && userPasswords.get(user.getUsername()) != null;
+        return credentialType.equals(PasswordCredentialModel.TYPE) && userPasswords.get(user.getUsername()) != null;
     }
 
     @Override
     public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {
         if (!(input instanceof UserCredentialModel)) return false;
-        if (input.getType().equals(UserCredentialModel.PASSWORD)) {
+        if (input.getType().equals(PasswordCredentialModel.TYPE)) {
             String pw = (String)userPasswords.get(user.getUsername());
-            return pw != null && pw.equals( ((UserCredentialModel)input).getValue());
+            return pw != null && pw.equals(input.getChallengeResponse());
         } else {
             return false;
         }
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/ClickThroughAuthenticator.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/ClickThroughAuthenticator.java
index 428b2b9286..f4ccea725d 100644
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/ClickThroughAuthenticator.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/ClickThroughAuthenticator.java
@@ -88,11 +88,6 @@ public class ClickThroughAuthenticator implements Authenticator, AuthenticatorFa
         return false;
     }
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.DISABLED
-    };
-
     @Override
     public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {
         return REQUIREMENT_CHOICES;
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/DummyClientAuthenticator.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/DummyClientAuthenticator.java
index d4a6c6b9b1..84ee4c691e 100755
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/DummyClientAuthenticator.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/DummyClientAuthenticator.java
@@ -41,10 +41,6 @@ public class DummyClientAuthenticator extends AbstractClientAuthenticator {
 
     public static final String PROVIDER_ID = "testsuite-client-dummy";
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE
-    };
-
     @Override
     public void authenticateClient(ClientAuthenticationFlowContext context) {
         ClientIdAndSecretAuthenticator authenticator = new ClientIdAndSecretAuthenticator();
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/PassThroughClientAuthenticator.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/PassThroughClientAuthenticator.java
index 5088e7acd7..54aac26ca7 100755
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/PassThroughClientAuthenticator.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/forms/PassThroughClientAuthenticator.java
@@ -40,12 +40,6 @@ public class PassThroughClientAuthenticator extends AbstractClientAuthenticator
     public static final String PROVIDER_ID = "testsuite-client-passthrough";
     public static String clientId = "test-app";
 
-    public static final AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {
-            AuthenticationExecutionModel.Requirement.REQUIRED,
-            AuthenticationExecutionModel.Requirement.ALTERNATIVE,
-            AuthenticationExecutionModel.Requirement.DISABLED
-    };
-
     private static final List<ProviderConfigProperty> clientConfigProperties = new ArrayList<ProviderConfigProperty>();
 
     static {
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/runonserver/RunOnServer.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/runonserver/RunOnServer.java
index bd9524b9c3..86be999326 100644
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/runonserver/RunOnServer.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/runonserver/RunOnServer.java
@@ -19,6 +19,7 @@ package org.keycloak.testsuite.runonserver;
 
 import org.keycloak.models.KeycloakSession;
 
+import java.io.IOException;
 import java.io.Serializable;
 
 /**
@@ -26,6 +27,6 @@ import java.io.Serializable;
  */
 public interface RunOnServer extends Serializable {
 
-    void run(KeycloakSession session);
+    void run(KeycloakSession session) throws IOException;
 
 }
diff --git a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/util/LDAPTestUtils.java b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/util/LDAPTestUtils.java
index 4be3fa9123..15fe154154 100644
--- a/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/util/LDAPTestUtils.java
+++ b/testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/util/LDAPTestUtils.java
@@ -62,9 +62,7 @@ public class LDAPTestUtils {
         user.setEmail(email);
         user.setEnabled(true);
 
-        UserCredentialModel creds = new UserCredentialModel();
-        creds.setType(CredentialRepresentation.PASSWORD);
-        creds.setValue(password);
+        UserCredentialModel creds = UserCredentialModel.password(password);
 
         session.userCredentialManager().updateCredential(realm, user, creds);
         return user;
diff --git a/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/admin/Users.java b/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/admin/Users.java
index 5d4ee2e270..3a5e3b29b1 100644
--- a/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/admin/Users.java
+++ b/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/admin/Users.java
@@ -32,12 +32,14 @@ import static org.keycloak.representations.idm.CredentialRepresentation.PASSWORD
 public class Users {
 
     public static String getPasswordOf(UserRepresentation user) {
-        String value = null;
-        CredentialRepresentation password = getPasswordCredentialOf(user);
-        if (password != null) {
-            value = password.getValue();
+        CredentialRepresentation credential = getPasswordCredentialOf(user);
+        if (credential == null) {
+            return null;
         }
-        return value;
+        if (credential.getValue() != null && !credential.getValue().isEmpty()) {
+            return credential.getValue();
+        }
+        return credential.getSecretData();
     }
 
     public static CredentialRepresentation getPasswordCredentialOf(UserRepresentation user) {
diff --git a/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/LoginTotpPage.java b/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/LoginTotpPage.java
index f58540bee7..6bbf39e116 100755
--- a/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/LoginTotpPage.java
+++ b/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/pages/LoginTotpPage.java
@@ -25,8 +25,8 @@ import org.openqa.selenium.support.FindBy;
  */
 public class LoginTotpPage extends AbstractPage {
 
-    @FindBy(id = "totp")
-    private WebElement totpInput;
+    @FindBy(id = "otp")
+    private WebElement otpInput;
 
     @FindBy(id = "password-token")
     private WebElement passwordToken;
@@ -41,8 +41,8 @@ public class LoginTotpPage extends AbstractPage {
     private WebElement loginErrorMessage;
 
     public void login(String totp) {
-        totpInput.clear();
-        if (totp != null) totpInput.sendKeys(totp);
+        otpInput.clear();
+        if (totp != null) otpInput.sendKeys(totp);
 
         submitButton.click();
     }
@@ -58,7 +58,7 @@ public class LoginTotpPage extends AbstractPage {
     public boolean isCurrent() {
         if (driver.getTitle().startsWith("Log in to ")) {
             try {
-                driver.findElement(By.id("totp"));
+                driver.findElement(By.id("otp"));
                 return true;
             } catch (Throwable t) {
             }
diff --git a/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/OAuthClient.java b/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/OAuthClient.java
index 782003de4a..b3e1c897d8 100644
--- a/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/OAuthClient.java
+++ b/testsuite/integration-arquillian/tests/base/src/main/java/org/keycloak/testsuite/util/OAuthClient.java
@@ -430,7 +430,7 @@ public class OAuthClient {
             parameters.add(new BasicNameValuePair("username", username));
             parameters.add(new BasicNameValuePair("password", password));
             if (totp != null) {
-                parameters.add(new BasicNameValuePair("totp", totp));
+                parameters.add(new BasicNameValuePair("otp", totp));
 
             }
             if (clientSecret != null) {
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/AccountFormServiceTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/AccountFormServiceTest.java
index c8c1901d01..54591f3399 100755
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/AccountFormServiceTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/AccountFormServiceTest.java
@@ -63,8 +63,6 @@ import org.keycloak.testsuite.util.OAuthClient;
 import org.keycloak.testsuite.util.RealmBuilder;
 import org.keycloak.testsuite.util.UIUtils;
 import org.keycloak.testsuite.util.UserBuilder;
-import java.io.Closeable;
-import java.io.IOException;
 import java.util.Collections;
 import org.openqa.selenium.By;
 import org.openqa.selenium.WebDriver;
@@ -465,23 +463,23 @@ public class AccountFormServiceTest extends AbstractTestRealmKeycloakTest {
         assertChangePasswordSucceeds("password",  "password3"); // current: password
         assertNumberOfStoredCredentials(2);
 
-        assertChangePasswordFails   ("password3", "password");  // current: password1, history: password
+        assertChangePasswordFails   ("password3", "password");  // current: password3, history: password
         assertNumberOfStoredCredentials(2);
         assertChangePasswordFails   ("password3", "password3"); // current: password1, history: password
         assertNumberOfStoredCredentials(2);
         assertChangePasswordSucceeds("password3", "password4"); // current: password1, history: password
         assertNumberOfStoredCredentials(3);
 
-        assertChangePasswordFails   ("password4", "password");  // current: password2, history: password, password1
+        assertChangePasswordFails   ("password4", "password");  // current: password4, history: password3, password
         assertNumberOfStoredCredentials(3);
-        assertChangePasswordFails   ("password4", "password3"); // current: password2, history: password, password1
+        assertChangePasswordFails   ("password4", "password3"); // current: password4, history: password3, password
         assertNumberOfStoredCredentials(3);
-        assertChangePasswordFails   ("password4", "password4"); // current: password2, history: password, password1
+        assertChangePasswordFails   ("password4", "password4"); // current: password4, history: password3, password
         assertNumberOfStoredCredentials(3);
-        assertChangePasswordSucceeds("password4", "password5"); // current: password2, history: password, password1
+        assertChangePasswordSucceeds("password4", "password5"); // current: password4, history: password3, password
         assertNumberOfStoredCredentials(3);
 
-        assertChangePasswordSucceeds("password5", "password");  // current: password3, history: password1, password2
+        assertChangePasswordSucceeds("password5", "password");  // current: password5, history: password4, password3
         assertNumberOfStoredCredentials(3);
     }
 
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/custom/AbstractCustomAccountManagementTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/custom/AbstractCustomAccountManagementTest.java
index 265b23183b..d36a38d143 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/custom/AbstractCustomAccountManagementTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/custom/AbstractCustomAccountManagementTest.java
@@ -23,6 +23,8 @@ import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.representations.idm.AuthenticationExecutionInfoRepresentation;
 
 import java.util.List;
+import java.util.Optional;
+import java.util.function.Function;
 
 /**
  *
@@ -52,6 +54,15 @@ public abstract class AbstractCustomAccountManagementTest extends AbstractAccoun
         exec.setRequirement(requirement.name());
         authMgmtResource.updateExecutions(flowAlias, exec);
     }
+
+    protected void updateRequirement(String flowAlias, AuthenticationExecutionModel.Requirement requirement, Function<AuthenticationExecutionInfoRepresentation, Boolean> filterFunc){
+        List<AuthenticationExecutionInfoRepresentation> executionReps = authMgmtResource.getExecutions(flowAlias);
+        AuthenticationExecutionInfoRepresentation exec =  executionReps.stream().filter(filterFunc::apply).findFirst().orElse(null);
+        if (exec != null) {
+            exec.setRequirement(requirement.name());
+            authMgmtResource.updateExecutions(flowAlias, exec);
+        }
+    }
     
     protected AuthenticationExecutionInfoRepresentation getExecution(String flowAlias, String provider) {
         List<AuthenticationExecutionInfoRepresentation> executionReps = authMgmtResource.getExecutions(flowAlias);
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/custom/CustomAuthFlowOTPTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/custom/CustomAuthFlowOTPTest.java
index 686b72a167..515e238447 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/custom/CustomAuthFlowOTPTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/custom/CustomAuthFlowOTPTest.java
@@ -22,6 +22,7 @@ import org.junit.Test;
 import org.keycloak.models.AuthenticationExecutionModel.Requirement;
 import org.keycloak.models.utils.DefaultAuthenticationFlows;
 import org.keycloak.models.utils.TimeBasedOTP;
+import org.keycloak.representations.idm.AuthenticationExecutionInfoRepresentation;
 import org.keycloak.representations.idm.AuthenticationFlowRepresentation;
 import org.keycloak.representations.idm.AuthenticatorConfigRepresentation;
 import org.keycloak.representations.idm.RealmRepresentation;
@@ -109,7 +110,7 @@ public class CustomAuthFlowOTPTest extends AbstractCustomAccountManagementTest {
         realm.setBrowserFlow("browser");
         testRealmResource().update(realm);
 
-        updateRequirement("browser", "auth-otp-form", Requirement.REQUIRED);
+        updateRequirement("browser", Requirement.REQUIRED, (authExec) -> authExec.getDisplayName().equals("Browser - Conditional OTP"));
         testRealmAccountManagementPage.navigateTo();
         testRealmLoginPage.form().login(testUser);
         assertTrue(loginConfigTotpPage.isCurrent());
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/RequiredActionTotpSetupTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/RequiredActionTotpSetupTest.java
index 22215764d2..b163b2d13f 100755
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/RequiredActionTotpSetupTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/actions/RequiredActionTotpSetupTest.java
@@ -28,9 +28,11 @@ import org.keycloak.events.EventType;
 import org.keycloak.models.AuthenticationExecutionModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.HmacOTP;
 import org.keycloak.models.utils.TimeBasedOTP;
 import org.keycloak.representations.idm.AuthenticationExecutionInfoRepresentation;
+import org.keycloak.representations.idm.AuthenticationFlowRepresentation;
 import org.keycloak.representations.idm.EventRepresentation;
 import org.keycloak.representations.idm.RealmRepresentation;
 import org.keycloak.representations.idm.RequiredActionProviderRepresentation;
@@ -54,8 +56,10 @@ import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
 
+import static org.hamcrest.Matchers.is;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
+import static org.junit.Assert.assertThat;
 import static org.junit.Assert.assertTrue;
 
 /**
@@ -80,13 +84,12 @@ public class RequiredActionTotpSetupTest extends AbstractTestRealmKeycloakTest {
 
     @Before
     public void setOTPAuthRequired() {
-        for (AuthenticationExecutionInfoRepresentation execution : adminClient.realm("test").flows().getExecutions("browser")) {
-            String providerId = execution.getProviderId();
-            if ("auth-otp-form".equals(providerId)) {
-                execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED.name());
-                adminClient.realm("test").flows().updateExecutions("browser", execution);
-            }
-        }
+
+        adminClient.realm("test").flows().getExecutions("browser").
+                stream().filter(execution -> execution.getDisplayName().equals("Browser - Conditional OTP"))
+                .forEach(execution ->
+                {execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED.name());
+                adminClient.realm("test").flows().updateExecutions("browser", execution);});
 
         ApiUtil.removeUserByUsername(testRealm(), "test-user@localhost");
         UserRepresentation user = UserBuilder.create().enabled(true)
@@ -398,7 +401,7 @@ public class RequiredActionTotpSetupTest extends AbstractTestRealmKeycloakTest {
                     .otpLookAheadWindow(1)
                     .otpDigits(8)
                     .otpPeriod(30)
-                    .otpType(UserCredentialModel.TOTP)
+                    .otpType(OTPCredentialModel.TOTP)
                     .otpAlgorithm(HmacOTP.HMAC_SHA1)
                     .otpInitialCounter(0);
         adminClient.realm("test").update(realmRep);
@@ -450,7 +453,7 @@ public class RequiredActionTotpSetupTest extends AbstractTestRealmKeycloakTest {
                     .otpLookAheadWindow(0)
                     .otpDigits(6)
                     .otpPeriod(30)
-                    .otpType(UserCredentialModel.HOTP)
+                    .otpType(OTPCredentialModel.HOTP)
                     .otpAlgorithm(HmacOTP.HMAC_SHA1)
                     .otpInitialCounter(0);
         adminClient.realm("test").update(realmRep);
@@ -479,8 +482,9 @@ public class RequiredActionTotpSetupTest extends AbstractTestRealmKeycloakTest {
 
         loginPage.open();
         loginPage.login("test-user@localhost", "password");
-        String token = otpgen.generateHOTP(totpSecret, 1);
-        loginTotpPage.login(token);
+        loginTotpPage.assertCurrent();
+        loginTotpPage.login(otpgen.generateHOTP(totpSecret, 1));
+
 
         assertEquals(RequestType.AUTH_RESPONSE, appPage.getRequestType());
 
@@ -495,7 +499,7 @@ public class RequiredActionTotpSetupTest extends AbstractTestRealmKeycloakTest {
                     .otpLookAheadWindow(5)
                     .otpDigits(6)
                     .otpPeriod(30)
-                    .otpType(UserCredentialModel.HOTP)
+                    .otpType(OTPCredentialModel.HOTP)
                     .otpAlgorithm(HmacOTP.HMAC_SHA1)
                     .otpInitialCounter(0);
         adminClient.realm("test").update(realmRep);
@@ -503,9 +507,8 @@ public class RequiredActionTotpSetupTest extends AbstractTestRealmKeycloakTest {
 
         loginPage.open();
         loginPage.login("test-user@localhost", "password");
-        token = otpgen.generateHOTP(totpSecret, 4);
         loginTotpPage.assertCurrent();
-        loginTotpPage.login(token);
+        loginTotpPage.login(otpgen.generateHOTP(totpSecret, 2));
 
         assertEquals(RequestType.AUTH_RESPONSE, appPage.getRequestType());
 
@@ -517,7 +520,7 @@ public class RequiredActionTotpSetupTest extends AbstractTestRealmKeycloakTest {
                 .otpLookAheadWindow(1)
                 .otpDigits(6)
                 .otpPeriod(30)
-                .otpType(UserCredentialModel.TOTP)
+                .otpType(OTPCredentialModel.TOTP)
                 .otpAlgorithm(HmacOTP.HMAC_SHA1)
                 .otpInitialCounter(0);
         adminClient.realm("test").update(realmRep);
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adduser/AddUserTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adduser/AddUserTest.java
index 0370177deb..0be890585e 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adduser/AddUserTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adduser/AddUserTest.java
@@ -26,6 +26,8 @@ import org.keycloak.admin.client.resource.RealmResource;
 import org.keycloak.admin.client.resource.UserResource;
 import org.keycloak.credential.hash.Pbkdf2Sha256PasswordHashProviderFactory;
 import org.keycloak.models.Constants;
+import org.keycloak.models.credential.PasswordCredentialModel;
+import org.keycloak.models.utils.RepresentationToModel;
 import org.keycloak.representations.idm.*;
 import org.keycloak.testsuite.AbstractKeycloakTest;
 import org.keycloak.testsuite.util.ContainerAssume;
@@ -91,8 +93,9 @@ public class AddUserTest extends AbstractKeycloakTest {
         //------------------Credentials-----------------------------//
         assertThat("User Credentials are NULL", user.getCredentials().get(0), notNullValue());
         CredentialRepresentation credentials = user.getCredentials().get(0);
-        assertThat("User Credentials have wrong Algorithm.", credentials.getAlgorithm(), is(Pbkdf2Sha256PasswordHashProviderFactory.ID));
-        assertThat("User Credentials have wrong Hash Iterations", credentials.getHashIterations(), is(100000));
+        PasswordCredentialModel pcm = PasswordCredentialModel.createFromCredentialModel(RepresentationToModel.toModel(credentials));
+        assertThat("User Credentials have wrong Algorithm.", pcm.getPasswordCredentialData().getAlgorithm(), is(Pbkdf2Sha256PasswordHashProviderFactory.ID));
+        assertThat("User Credentials have wrong Hash Iterations", pcm.getPasswordCredentialData().getHashIterations(), is(100000));
 
         //------------------Restart--Container---------------------//
         controller.stop(authServerQualifier);
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/PermissionsTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/PermissionsTest.java
index 367087dd01..5c14158a77 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/PermissionsTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/PermissionsTest.java
@@ -28,6 +28,7 @@ import org.keycloak.admin.client.resource.AuthorizationResource;
 import org.keycloak.admin.client.resource.RealmResource;
 import org.keycloak.models.AdminRoles;
 import org.keycloak.models.Constants;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.representations.KeyStoreConfig;
 import org.keycloak.representations.idm.AuthenticationExecutionInfoRepresentation;
 import org.keycloak.representations.idm.AuthenticationExecutionRepresentation;
@@ -37,7 +38,7 @@ import org.keycloak.representations.idm.ClientInitialAccessCreatePresentation;
 import org.keycloak.representations.idm.ClientRepresentation;
 import org.keycloak.representations.idm.ClientScopeRepresentation;
 import org.keycloak.representations.idm.ComponentRepresentation;
-import org.keycloak.representations.idm.ConfigPropertyRepresentation;
+import org.keycloak.representations.idm.CredentialRepresentation;
 import org.keycloak.representations.idm.GroupRepresentation;
 import org.keycloak.representations.idm.IdentityProviderMapperRepresentation;
 import org.keycloak.representations.idm.IdentityProviderRepresentation;
@@ -81,7 +82,7 @@ import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 import static org.keycloak.services.resources.admin.AdminAuth.Resource.AUTHORIZATION;
 import static org.keycloak.services.resources.admin.AdminAuth.Resource.CLIENT;
-import org.keycloak.testsuite.ProfileAssume;
+
 import org.keycloak.testsuite.utils.tls.TLSUtils;
 
 /**
@@ -1475,7 +1476,13 @@ public class PermissionsTest extends AbstractKeycloakTest {
         }, Resource.USER, true);
         invoke(new Invocation() {
             public void invoke(RealmResource realm) {
-                realm.users().get(user.getId()).removeTotp();
+                CredentialRepresentation totpCredential = realm.users().get(user.getId()).credentials().stream()
+                        .filter(c -> OTPCredentialModel.TYPE.equals(c.getType())).findFirst().orElse(null);
+                if (totpCredential != null) {
+                    realm.users().get(user.getId()).removeCredential(totpCredential.getId());
+                } else {
+                    realm.users().get(user.getId()).removeCredential("123");
+                }
             }
         }, Resource.USER, true);
         invoke(new Invocation() {
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTest.java
index f535aae85d..0fc45ca301 100755
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTest.java
@@ -31,7 +31,6 @@ import org.keycloak.admin.client.resource.RealmResource;
 import org.keycloak.admin.client.resource.RoleMappingResource;
 import org.keycloak.admin.client.resource.UserResource;
 import org.keycloak.admin.client.resource.UsersResource;
-import org.keycloak.common.util.Base64;
 import org.keycloak.credential.CredentialModel;
 import org.keycloak.events.admin.OperationType;
 import org.keycloak.events.admin.ResourceType;
@@ -39,6 +38,8 @@ import org.keycloak.models.Constants;
 import org.keycloak.models.PasswordPolicy;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
+import org.keycloak.models.utils.ModelToRepresentation;
 import org.keycloak.representations.idm.ClientRepresentation;
 import org.keycloak.representations.idm.ComponentRepresentation;
 import org.keycloak.representations.idm.CredentialRepresentation;
@@ -199,16 +200,10 @@ public class UserTest extends AbstractAdminTest {
         user.setUsername("user_creds");
         user.setEmail("email@localhost");
 
-        CredentialRepresentation hashedPassword = new CredentialRepresentation();
-        hashedPassword.setAlgorithm("my-algorithm");
-        hashedPassword.setCounter(11);
+        PasswordCredentialModel pcm = PasswordCredentialModel.createFromValues("my-algorithm", "theSalt".getBytes(), 22, "ABC");
+        CredentialRepresentation hashedPassword = ModelToRepresentation.toRepresentation(pcm);
         hashedPassword.setCreatedDate(1001l);
-        hashedPassword.setDevice("deviceX");
-        hashedPassword.setDigits(6);
-        hashedPassword.setHashIterations(22);
-        hashedPassword.setHashedSaltedValue("ABC");
-        hashedPassword.setPeriod(99);
-        hashedPassword.setSalt(Base64.encodeBytes("theSalt".getBytes()));
+        hashedPassword.setUserLabel("deviceX");
         hashedPassword.setType(CredentialRepresentation.PASSWORD);
 
         user.setCredentials(Arrays.asList(hashedPassword));
@@ -216,16 +211,14 @@ public class UserTest extends AbstractAdminTest {
         createUser(user);
 
         CredentialModel credentialHashed = fetchCredentials("user_creds");
+        PasswordCredentialModel pcmh = PasswordCredentialModel.createFromCredentialModel(credentialHashed);
         assertNotNull("Expecting credential", credentialHashed);
-        assertEquals("my-algorithm", credentialHashed.getAlgorithm());
-        assertEquals(11, credentialHashed.getCounter());
+        assertEquals("my-algorithm", pcmh.getPasswordCredentialData().getAlgorithm());
         assertEquals(Long.valueOf(1001), credentialHashed.getCreatedDate());
-        assertEquals("deviceX", credentialHashed.getDevice());
-        assertEquals(6, credentialHashed.getDigits());
-        assertEquals(22, credentialHashed.getHashIterations());
-        assertEquals("ABC", credentialHashed.getValue());
-        assertEquals(99, credentialHashed.getPeriod());
-        assertEquals("theSalt", new String(credentialHashed.getSalt()));
+        assertEquals("deviceX", credentialHashed.getUserLabel());
+        assertEquals(22, pcmh.getPasswordCredentialData().getHashIterations());
+        assertEquals("ABC", pcmh.getPasswordSecretData().getValue());
+        assertEquals("theSalt", new String(pcmh.getPasswordSecretData().getSalt()));
         assertEquals(CredentialRepresentation.PASSWORD, credentialHashed.getType());
     }
 
@@ -244,9 +237,10 @@ public class UserTest extends AbstractAdminTest {
 
         CredentialModel credential = fetchCredentials("user_rawpw");
         assertNotNull("Expecting credential", credential);
-        assertEquals(PasswordPolicy.HASH_ALGORITHM_DEFAULT, credential.getAlgorithm());
-        assertEquals(PasswordPolicy.HASH_ITERATIONS_DEFAULT, credential.getHashIterations());
-        assertNotEquals("ABCD", credential.getValue());
+        PasswordCredentialModel pcm = PasswordCredentialModel.createFromCredentialModel(credential);
+        assertEquals(PasswordPolicy.HASH_ALGORITHM_DEFAULT, pcm.getPasswordCredentialData().getAlgorithm());
+        assertEquals(PasswordPolicy.HASH_ITERATIONS_DEFAULT, pcm.getPasswordCredentialData().getHashIterations());
+        assertNotEquals("ABCD", pcm.getPasswordSecretData().getValue());
         assertEquals(CredentialRepresentation.PASSWORD, credential.getType());
     }
 
@@ -1229,11 +1223,12 @@ public class UserTest extends AbstractAdminTest {
 
         String id = createUser(user);
 
-        CredentialModel credential = fetchCredentials("user_rawpw");
+        PasswordCredentialModel credential = PasswordCredentialModel
+                .createFromCredentialModel(fetchCredentials("user_rawpw"));
         assertNotNull("Expecting credential", credential);
-        assertEquals(PasswordPolicy.HASH_ALGORITHM_DEFAULT, credential.getAlgorithm());
-        assertEquals(PasswordPolicy.HASH_ITERATIONS_DEFAULT, credential.getHashIterations());
-        assertNotEquals("ABCD", credential.getValue());
+        assertEquals(PasswordPolicy.HASH_ALGORITHM_DEFAULT, credential.getPasswordCredentialData().getAlgorithm());
+        assertEquals(PasswordPolicy.HASH_ITERATIONS_DEFAULT, credential.getPasswordCredentialData().getHashIterations());
+        assertNotEquals("ABCD", credential.getPasswordSecretData().getValue());
         assertEquals(CredentialRepresentation.PASSWORD, credential.getType());
 
         UserResource userResource = realm.users().get(id);
@@ -1246,11 +1241,12 @@ public class UserTest extends AbstractAdminTest {
 
         updateUser(userResource, userRep);
 
-        CredentialModel updatedCredential = fetchCredentials("user_rawpw");
+        PasswordCredentialModel updatedCredential = PasswordCredentialModel
+                .createFromCredentialModel(fetchCredentials("user_rawpw"));
         assertNotNull("Expecting credential", updatedCredential);
-        assertEquals(PasswordPolicy.HASH_ALGORITHM_DEFAULT, updatedCredential.getAlgorithm());
-        assertEquals(PasswordPolicy.HASH_ITERATIONS_DEFAULT, updatedCredential.getHashIterations());
-        assertNotEquals("EFGH", updatedCredential.getValue());
+        assertEquals(PasswordPolicy.HASH_ALGORITHM_DEFAULT, updatedCredential.getPasswordCredentialData().getAlgorithm());
+        assertEquals(PasswordPolicy.HASH_ITERATIONS_DEFAULT, updatedCredential.getPasswordCredentialData().getHashIterations());
+        assertNotEquals("EFGH", updatedCredential.getPasswordSecretData().getValue());
         assertEquals(CredentialRepresentation.PASSWORD, updatedCredential.getType());
     }
 
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTotpTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTotpTest.java
index 1fffa50fd7..9f297974b7 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTotpTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/UserTotpTest.java
@@ -24,18 +24,18 @@ import org.junit.Test;
 import org.keycloak.events.Details;
 import org.keycloak.events.EventType;
 import org.keycloak.events.admin.OperationType;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.TimeBasedOTP;
 import org.keycloak.representations.idm.AdminEventRepresentation;
+import org.keycloak.representations.idm.CredentialRepresentation;
 import org.keycloak.representations.idm.RealmRepresentation;
 import org.keycloak.representations.idm.UserRepresentation;
-import org.keycloak.services.resources.account.AccountFormService;
 import org.keycloak.testsuite.AssertEvents;
 import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;
 import org.keycloak.testsuite.pages.AccountTotpPage;
 import org.keycloak.testsuite.pages.AccountUpdateProfilePage;
 import org.keycloak.testsuite.pages.LoginPage;
 
-import javax.ws.rs.core.UriBuilder;
 import java.util.List;
 
 
@@ -85,7 +85,9 @@ public class UserTotpTest extends AbstractTestRealmKeycloakTest {
         List<UserRepresentation> users = adminClient.realms().realm("test").users().search("test-user@localhost", null, null, null, 0, 1);
         String userId = users.get(0).getId();
         testingClient.testing().clearAdminEventQueue();
-        adminClient.realms().realm("test").users().get(userId).removeTotp();
+        CredentialRepresentation totpCredential = adminClient.realms().realm("test").users().get(userId).credentials()
+                .stream().filter(c -> OTPCredentialModel.TYPE.equals(c.getType())).findFirst().get();
+        adminClient.realms().realm("test").users().get(userId).removeCredential(totpCredential.getId());
 
         totpPage.open();
         Assert.assertFalse(driver.getPageSource().contains("pficon-delete"));
@@ -93,6 +95,6 @@ public class UserTotpTest extends AbstractTestRealmKeycloakTest {
         AdminEventRepresentation event = testingClient.testing().pollAdminEvent();
         Assert.assertNotNull(event);
         Assert.assertEquals(OperationType.ACTION.name(), event.getOperationType());
-        Assert.assertEquals("users/" + userId + "/remove-totp", event.getResourcePath());
+        Assert.assertEquals("users/" + userId + "/credentials/" + totpCredential.getId(), event.getResourcePath());
     }
 }
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/authentication/ExecutionTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/authentication/ExecutionTest.java
index 323ce21611..5caae8780a 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/authentication/ExecutionTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/admin/authentication/ExecutionTest.java
@@ -149,7 +149,7 @@ public class ExecutionTest extends AbstractAuthenticationTest {
         // we'll need auth-cookie later
         AuthenticationExecutionInfoRepresentation authCookieExec = findExecutionByProvider("auth-cookie", executionReps);
 
-        compareExecution(newExecInfo("Review Profile", "idp-review-profile", true, 0, 4, DISABLED, null, new String[]{REQUIRED, DISABLED}), exec);
+        compareExecution(newExecInfo("Review Profile", "idp-review-profile", true, 0, 4, DISABLED, null, new String[]{REQUIRED, ALTERNATIVE,DISABLED}), exec);
 
         // remove execution
         authMgmtResource.removeExecution(exec.getId());
@@ -219,7 +219,7 @@ public class ExecutionTest extends AbstractAuthenticationTest {
 
         // Note: there is no checking in addExecution if requirement is one of requirementChoices
         // Thus we can have OPTIONAL which is neither ALTERNATIVE, nor DISABLED
-        compareExecution(newExecInfo("Cookie", "auth-cookie", false, 0, 3, OPTIONAL, null, new String[]{ALTERNATIVE, DISABLED}), exec);
+        compareExecution(newExecInfo("Cookie", "auth-cookie", false, 0, 3, OPTIONAL, null, new String[]{REQUIRED, ALTERNATIVE, DISABLED}), exec);
     }
 
     @Test
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/cli/KcinitTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/cli/KcinitTest.java
index 994614072f..35b1c5c636 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/cli/KcinitTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/cli/KcinitTest.java
@@ -47,6 +47,7 @@ import org.keycloak.models.RealmModel;
 import org.keycloak.models.RequiredActionProviderModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.DefaultAuthenticationFlows;
 import org.keycloak.models.utils.TimeBasedOTP;
 import org.keycloak.representations.idm.RealmRepresentation;
@@ -176,7 +177,7 @@ public class KcinitTest extends AbstractTestRealmKeycloakTest {
             realm.updateAuthenticationFlow(copy);
             execution = new AuthenticationExecutionModel();
             execution.setParentFlow(browser.getId());
-            execution.setRequirement(AuthenticationExecutionModel.Requirement.ALTERNATIVE);
+            execution.setRequirement(AuthenticationExecutionModel.Requirement.REQUIRED);
             execution.setFlowId(copy.getId());
             execution.setPriority(30);
             execution.setAuthenticatorFlow(true);
@@ -630,7 +631,9 @@ public class KcinitTest extends AbstractTestRealmKeycloakTest {
             testingClient.server().run(session -> {
                 RealmModel realm = session.realms().getRealmByName("test");
                 UserModel user = session.users().getUserByUsername("wburke", realm);
-                session.userCredentialManager().disableCredentialType(realm, user, CredentialModel.OTP);
+                for (CredentialModel c: session.userCredentialManager().getStoredCredentialsByType(realm, user, OTPCredentialModel.TYPE)){
+                    session.userCredentialManager().removeStoredCredential(realm, user, c.getId());
+                }
             });
         }
 
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/exportimport/ExportImportUtil.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/exportimport/ExportImportUtil.java
index 5f10066e17..9045ba6ab4 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/exportimport/ExportImportUtil.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/exportimport/ExportImportUtil.java
@@ -25,7 +25,6 @@ import org.keycloak.admin.client.resource.ClientResource;
 import org.keycloak.admin.client.resource.ClientScopeResource;
 import org.keycloak.admin.client.resource.RealmResource;
 import org.keycloak.admin.client.resource.UserResource;
-import org.keycloak.authentication.AuthenticationFlow;
 import org.keycloak.common.constants.KerberosConstants;
 import org.keycloak.models.Constants;
 import org.keycloak.models.LDAPConstants;
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/kerberos/AbstractKerberosSingleRealmTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/kerberos/AbstractKerberosSingleRealmTest.java
index 0adce7c0cc..a7b9e30925 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/kerberos/AbstractKerberosSingleRealmTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/kerberos/AbstractKerberosSingleRealmTest.java
@@ -70,7 +70,7 @@ public abstract class AbstractKerberosSingleRealmTest extends AbstractKerberosTe
         Response response = spnegoLogin("hnelson", "secret");
         updateKerberosAuthExecutionRequirement(oldRequirement);
 
-        Assert.assertEquals(Response.Status.OK.getStatusCode(), response.getStatus());
+        Assert.assertEquals(302, response.getStatus());
     }
 
 
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/kerberos/KerberosLdapTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/kerberos/KerberosLdapTest.java
index 7d032e7ecd..f55502e99e 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/kerberos/KerberosLdapTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/kerberos/KerberosLdapTest.java
@@ -85,7 +85,7 @@ public class KerberosLdapTest extends AbstractKerberosSingleRealmTest {
 
         for (AuthenticationExecutionInfoRepresentation execution : executions) {
             if ("basic-auth".equals(execution.getProviderId())) {
-                execution.setRequirement("OPTIONAL");
+                execution.setRequirement("ALTERNATIVE");
                 testRealmResource().flows().updateExecutions("http challenge", execution);
             }
             if ("auth-spnego".equals(execution.getProviderId())) {
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPProvidersIntegrationTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPProvidersIntegrationTest.java
index 953b89bade..0dbecf7795 100755
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPProvidersIntegrationTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPProvidersIntegrationTest.java
@@ -47,6 +47,7 @@ import org.keycloak.models.RoleModel;
 import org.keycloak.models.UserCredentialModel;
 import org.keycloak.models.UserModel;
 import org.keycloak.models.cache.CachedUserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.models.utils.KeycloakModelUtils;
 import org.keycloak.models.utils.ModelToRepresentation;
 import org.keycloak.representations.AccessToken;
@@ -913,8 +914,8 @@ public class LDAPProvidersIntegrationTest extends AbstractLDAPTest {
 
             UserCredentialModel cred = UserCredentialModel.password("Candycand1", true);
             session.userCredentialManager().updateCredential(appRealm, user, cred);
-            CredentialModel userCredentialValueModel = session.userCredentialManager().getStoredCredentialsByType(appRealm, user, CredentialModel.PASSWORD).get(0);
-            Assert.assertEquals(UserCredentialModel.PASSWORD, userCredentialValueModel.getType());
+            CredentialModel userCredentialValueModel = session.userCredentialManager().getStoredCredentialsByType(appRealm, user, PasswordCredentialModel.TYPE).get(0);
+            Assert.assertEquals(PasswordCredentialModel.TYPE, userCredentialValueModel.getType());
             Assert.assertTrue(session.userCredentialManager().isValid(appRealm, user, cred));
 
             // LDAP password is still unchanged
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/storage/FederatedStorageExportImportTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/storage/FederatedStorageExportImportTest.java
index e5efc30525..f9f7eb2bd7 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/storage/FederatedStorageExportImportTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/storage/FederatedStorageExportImportTest.java
@@ -35,6 +35,7 @@ import org.keycloak.models.KeycloakSession;
 import org.keycloak.models.PasswordPolicy;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.RoleModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.services.managers.RealmManager;
 import org.keycloak.testsuite.AbstractAuthTest;
 import org.keycloak.testsuite.runonserver.RunOnServerDeployment;
@@ -99,7 +100,7 @@ public class FederatedStorageExportImportTest extends AbstractAuthTest {
 
 
     @Test
-    public void testSingleFile() throws Exception {
+    public void testSingleFile() {
         ComponentExportImportTest.clearExportImportProperties(testingClient);
 
         final String userId = "f:1:path";
@@ -115,9 +116,8 @@ public class FederatedStorageExportImportTest extends AbstractAuthTest {
             session.userFederatedStorage().setSingleAttribute(realm, userId, "single1", "value1");
             session.userFederatedStorage().setAttribute(realm, userId, "list1", attrValues);
             session.userFederatedStorage().addRequiredAction(realm, userId, "UPDATE_PASSWORD");
-            CredentialModel credential = new CredentialModel();
-            FederatedStorageExportImportTest.getHashProvider(session, realm.getPasswordPolicy()).encode("password", realm.
-                    getPasswordPolicy().getHashIterations(), credential);
+            PasswordCredentialModel credential = FederatedStorageExportImportTest.getHashProvider(session, realm.getPasswordPolicy()).encodedCredential("password", realm.
+                    getPasswordPolicy().getHashIterations());
             session.userFederatedStorage().createCredential(realm, userId, credential);
             session.userFederatedStorage().grantRole(realm, userId, role);
             session.userFederatedStorage().joinGroup(realm, userId, group);
@@ -159,13 +159,13 @@ public class FederatedStorageExportImportTest extends AbstractAuthTest {
             Assert.assertTrue(session.userFederatedStorage().getGroups(realm, userId).contains(group));
             List<CredentialModel> creds = session.userFederatedStorage().getStoredCredentials(realm, userId);
             Assert.assertEquals(1, creds.size());
-            Assert.assertTrue(FederatedStorageExportImportTest.getHashProvider(session, realm.getPasswordPolicy()).verify("password", creds.get(0)));
+            Assert.assertTrue(FederatedStorageExportImportTest.getHashProvider(session, realm.getPasswordPolicy())
+                    .verify("password", PasswordCredentialModel.createFromCredentialModel(creds.get(0))));
         });
     }
 
-
     @Test
-    public void testDir() throws Exception {
+    public void testDir() {
         ComponentExportImportTest.clearExportImportProperties(testingClient);
 
         final String userId = "f:1:path";
@@ -181,9 +181,8 @@ public class FederatedStorageExportImportTest extends AbstractAuthTest {
             session.userFederatedStorage().setSingleAttribute(realm, userId, "single1", "value1");
             session.userFederatedStorage().setAttribute(realm, userId, "list1", attrValues);
             session.userFederatedStorage().addRequiredAction(realm, userId, "UPDATE_PASSWORD");
-            CredentialModel credential = new CredentialModel();
-            FederatedStorageExportImportTest.getHashProvider(session, realm.getPasswordPolicy()).encode("password", realm.
-                    getPasswordPolicy().getHashIterations(), credential);
+            PasswordCredentialModel credential = FederatedStorageExportImportTest.getHashProvider(session, realm.getPasswordPolicy()).encodedCredential("password", realm.
+                    getPasswordPolicy().getHashIterations());
             session.userFederatedStorage().createCredential(realm, userId, credential);
             session.userFederatedStorage().grantRole(realm, userId, role);
             session.userFederatedStorage().joinGroup(realm, userId, group);
@@ -228,7 +227,8 @@ public class FederatedStorageExportImportTest extends AbstractAuthTest {
             Assert.assertEquals(50, session.userFederatedStorage().getNotBeforeOfUser(realm, userId));
             List<CredentialModel> creds = session.userFederatedStorage().getStoredCredentials(realm, userId);
             Assert.assertEquals(1, creds.size());
-            Assert.assertTrue(FederatedStorageExportImportTest.getHashProvider(session, realm.getPasswordPolicy()).verify("password", creds.get(0)));
+            Assert.assertTrue(FederatedStorageExportImportTest.getHashProvider(session, realm.getPasswordPolicy())
+                    .verify("password", PasswordCredentialModel.createFromCredentialModel(creds.get(0))));
 
         });
 
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/BruteForceTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/BruteForceTest.java
index 5ccb869c3c..5e35a9a7b4 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/BruteForceTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/BruteForceTest.java
@@ -60,11 +60,7 @@ public class BruteForceTest extends AbstractTestRealmKeycloakTest {
     @Override
     public void configureTestRealm(RealmRepresentation testRealm) {
         UserRepresentation user = RealmRepUtil.findUser(testRealm, "test-user@localhost");
-        CredentialRepresentation credRep = new CredentialRepresentation();
-        credRep.setType(CredentialRepresentation.TOTP);
-        credRep.setValue("totpSecret");
-        user.getCredentials().add(credRep);
-        user.setTotp(Boolean.TRUE);
+        UserBuilder.edit(user).totpSecret("totpSecret");
 
         testRealm.setBruteForceProtected(true);
         testRealm.setFailureFactor(2);
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/CustomFlowTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/CustomFlowTest.java
index 259e03ac0f..a6273419a6 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/CustomFlowTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/CustomFlowTest.java
@@ -200,11 +200,9 @@ public class CustomFlowTest extends AbstractFlowTest {
 
     /**
      * KEYCLOAK-3506
-     *
-     * @throws Exception
      */
     @Test
-    public void testRequiredAfterAlternative() throws Exception {
+    public void testRequiredAfterAlternative() {
         AuthenticationManagementResource authMgmtResource = testRealm().flows();
         Map<String, String> params = new HashMap();
         String flowAlias = "Browser Flow With Extra";
@@ -235,11 +233,11 @@ public class CustomFlowTest extends AbstractFlowTest {
         Assert.assertEquals(flowAlias, rep.getBrowserFlow());
 
         loginPage.open();
-        String url = driver.getCurrentUrl();
+         /* In the new flows, any required execution will render any optional flows unused.
         // test to make sure we aren't skipping anything
         loginPage.login("test-user@localhost", "bad-password");
         Assert.assertTrue(loginPage.isCurrent());
-        loginPage.login("test-user@localhost", "password");
+        loginPage.login("test-user@localhost", "password");*/
         Assert.assertTrue(termsPage.isCurrent());
 
         // Revert dummy flow
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/FlowOverrideTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/FlowOverrideTest.java
index f5b9ba566e..14635a48f6 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/FlowOverrideTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/FlowOverrideTest.java
@@ -35,8 +35,10 @@ import org.keycloak.models.AuthenticationFlowBindings;
 import org.keycloak.models.AuthenticationFlowModel;
 import org.keycloak.models.ClientModel;
 import org.keycloak.models.RealmModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.TimeBasedOTP;
 import org.keycloak.representations.idm.ClientRepresentation;
+import org.keycloak.representations.idm.CredentialRepresentation;
 import org.keycloak.representations.idm.RealmRepresentation;
 import org.keycloak.representations.idm.UserRepresentation;
 import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;
@@ -399,8 +401,11 @@ public class FlowOverrideTest extends AbstractTestRealmKeycloakTest {
     @Test
     public void testDirectGrantHttpChallengeOTP() {
         UserRepresentation user = adminClient.realm("test").users().search("test-user@localhost").get(0);
-        UserRepresentation userUpdated = UserBuilder.edit(user).totpSecret("totpSecret").otpEnabled().build();
-        adminClient.realm("test").users().get(user.getId()).update(userUpdated);
+        UserRepresentation userUpdate = UserBuilder.edit(user).totpSecret("totpSecret").otpEnabled().build();
+        adminClient.realm("test").users().get(user.getId()).update(userUpdate);
+
+        CredentialRepresentation totpCredential = adminClient.realm("test").users()
+                .get(user.getId()).credentials().stream().filter(c -> OTPCredentialModel.TYPE.equals(c.getType())).findFirst().get();
 
         setupBruteForce();
 
@@ -439,7 +444,7 @@ public class FlowOverrideTest extends AbstractTestRealmKeycloakTest {
         response.close();
 
         clearBruteForce();
-        adminClient.realm("test").users().get(user.getId()).removeTotp();
+        adminClient.realm("test").users().get(user.getId()).removeCredential(totpCredential.getId());
     }
 
     @Test
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LoginHotpTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LoginHotpTest.java
index 424920da36..5355392bae 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LoginHotpTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LoginHotpTest.java
@@ -24,6 +24,7 @@ import org.junit.Test;
 import org.keycloak.events.Details;
 import org.keycloak.models.OTPPolicy;
 import org.keycloak.models.UserCredentialModel;
+import org.keycloak.models.credential.OTPCredentialModel;
 import org.keycloak.models.utils.HmacOTP;
 import org.keycloak.representations.idm.RealmRepresentation;
 import org.keycloak.representations.idm.UserRepresentation;
@@ -49,9 +50,10 @@ public class LoginHotpTest extends AbstractTestRealmKeycloakTest {
 
     @Override
     public void configureTestRealm(RealmRepresentation testRealm) {
-        testRealm.setOtpPolicyType(UserCredentialModel.HOTP);
+        testRealm.setOtpPolicyType(OTPCredentialModel.HOTP);
         testRealm.setOtpPolicyAlgorithm(HmacOTP.DEFAULT_ALGORITHM);
         testRealm.setOtpPolicyLookAheadWindow(2);
+        testRealm.setOtpPolicyDigits(6);
         UserRepresentation user = RealmRepUtil.findUser(testRealm, "test-user@localhost");
         UserBuilder.edit(user)
                    .hotpSecret("hotpSecret")
@@ -141,6 +143,8 @@ public class LoginHotpTest extends AbstractTestRealmKeycloakTest {
 
         loginTotpPage.login(otp.generateHOTP("hotpSecret", counter++));
 
+        appPage.assertCurrent();
+
         Assert.assertEquals(RequestType.AUTH_RESPONSE, appPage.getRequestType());
 
         events.expectLogin().assertEvent();
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/PasswordHashingTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/PasswordHashingTest.java
index 88877197db..f2d05d1710 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/PasswordHashingTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/PasswordHashingTest.java
@@ -28,6 +28,7 @@ import org.keycloak.credential.hash.Pbkdf2Sha256PasswordHashProviderFactory;
 import org.keycloak.credential.hash.Pbkdf2Sha512PasswordHashProviderFactory;
 import org.keycloak.models.RealmModel;
 import org.keycloak.models.UserModel;
+import org.keycloak.models.credential.PasswordCredentialModel;
 import org.keycloak.representations.idm.CredentialRepresentation;
 import org.keycloak.representations.idm.ErrorRepresentation;
 import org.keycloak.representations.idm.RealmRepresentation;
@@ -86,21 +87,21 @@ public class PasswordHashingTest extends AbstractTestRealmKeycloakTest {
         String username = "testPasswordRehashedOnAlgorithmChanged";
         createUser(username);
 
-        CredentialModel credential = fetchCredentials(username);
+        PasswordCredentialModel credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
 
-        assertEquals(Pbkdf2Sha256PasswordHashProviderFactory.ID, credential.getAlgorithm());
+        assertEquals(Pbkdf2Sha256PasswordHashProviderFactory.ID, credential.getPasswordCredentialData().getAlgorithm());
 
-        assertEncoded(credential, "password", credential.getSalt(), "PBKDF2WithHmacSHA256", 1);
+        assertEncoded(credential, "password", credential.getPasswordSecretData().getSalt(), "PBKDF2WithHmacSHA256", 1);
 
         setPasswordPolicy("hashAlgorithm(" + Pbkdf2PasswordHashProviderFactory.ID + ") and hashIterations(1)");
 
         loginPage.open();
         loginPage.login(username, "password");
 
-        credential = fetchCredentials(username);
+        credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
 
-        assertEquals(Pbkdf2PasswordHashProviderFactory.ID, credential.getAlgorithm());
-        assertEncoded(credential, "password", credential.getSalt(), "PBKDF2WithHmacSHA1", 1);
+        assertEquals(Pbkdf2PasswordHashProviderFactory.ID, credential.getPasswordCredentialData().getAlgorithm());
+        assertEncoded(credential, "password", credential.getPasswordSecretData().getSalt(), "PBKDF2WithHmacSHA1", 1);
     }
 
     @Test
@@ -110,42 +111,42 @@ public class PasswordHashingTest extends AbstractTestRealmKeycloakTest {
         String username = "testPasswordRehashedOnIterationsChanged";
         createUser(username);
 
-        CredentialModel credential = fetchCredentials(username);
+        PasswordCredentialModel credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
 
-        assertEquals(10000, credential.getHashIterations());
+        assertEquals(10000, credential.getPasswordCredentialData().getHashIterations());
 
         setPasswordPolicy("hashIterations(1)");
 
         loginPage.open();
         loginPage.login(username, "password");
 
-        credential = fetchCredentials(username);
+        credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
 
-        assertEquals(1, credential.getHashIterations());
-        assertEncoded(credential, "password", credential.getSalt(), "PBKDF2WithHmacSHA256", 1);
+        assertEquals(1, credential.getPasswordCredentialData().getHashIterations());
+        assertEncoded(credential, "password", credential.getPasswordSecretData().getSalt(), "PBKDF2WithHmacSHA256", 1);
     }
 
     // KEYCLOAK-5282
     @Test
-    public void testPasswordNotRehasedUnchangedIterations() throws Exception {
+    public void testPasswordNotRehasedUnchangedIterations() {
         setPasswordPolicy("");
 
         String username = "testPasswordNotRehasedUnchangedIterations";
         createUser(username);
 
-        CredentialModel credential = fetchCredentials(username);
+        PasswordCredentialModel credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
         String credentialId = credential.getId();
-        byte[] salt = credential.getSalt();
+        byte[] salt = credential.getPasswordSecretData().getSalt();
 
         setPasswordPolicy("hashIterations");
 
         loginPage.open();
         loginPage.login(username, "password");
 
-        credential = fetchCredentials(username);
+        credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
 
         assertEquals(credentialId, credential.getId());
-        assertArrayEquals(salt, credential.getSalt());
+        assertArrayEquals(salt, credential.getPasswordSecretData().getSalt());
 
         setPasswordPolicy("hashIterations(" + Pbkdf2Sha256PasswordHashProviderFactory.DEFAULT_ITERATIONS + ")");
 
@@ -155,14 +156,14 @@ public class PasswordHashingTest extends AbstractTestRealmKeycloakTest {
         loginPage.open();
         loginPage.login(username, "password");
 
-        credential = fetchCredentials(username);
+        credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
 
         assertEquals(credentialId, credential.getId());
-        assertArrayEquals(salt, credential.getSalt());
+        assertArrayEquals(salt, credential.getPasswordSecretData().getSalt());
     }
 
     @Test
-    public void testPasswordRehashedWhenCredentialImportedWithDifferentKeySize() throws Exception {
+    public void testPasswordRehashedWhenCredentialImportedWithDifferentKeySize() {
         setPasswordPolicy("hashAlgorithm(" + Pbkdf2Sha512PasswordHashProviderFactory.ID + ") and hashIterations("+ Pbkdf2Sha512PasswordHashProviderFactory.DEFAULT_ITERATIONS + ")");
 
         String username = "testPasswordRehashedWhenCredentialImportedWithDifferentKeySize";
@@ -176,17 +177,14 @@ public class PasswordHashingTest extends AbstractTestRealmKeycloakTest {
         String encodedPassword = specificKeySizeHashProvider.encode(password, -1);
 
         // Create a user with the encoded password, simulating a user import from a different system using a specific key size
-        CredentialRepresentation credentialRepresentation = new CredentialRepresentation();
-        credentialRepresentation.setAlgorithm(Pbkdf2Sha512PasswordHashProviderFactory.PBKDF2_ALGORITHM);
-        credentialRepresentation.setHashedSaltedValue(encodedPassword);
         UserRepresentation user = UserBuilder.create().username(username).password(encodedPassword).build();
         ApiUtil.createUserWithAdminClient(adminClient.realm("test"),user);
 
         loginPage.open();
         loginPage.login(username, password);
 
-        CredentialModel postLoginCredentials = fetchCredentials(username);
-        assertEquals(encodedPassword.length() * 2, postLoginCredentials.getValue().length());
+        PasswordCredentialModel postLoginCredentials = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
+        assertEquals(encodedPassword.length() * 2, postLoginCredentials.getPasswordSecretData().getValue().length());
 
     }
 
@@ -197,8 +195,8 @@ public class PasswordHashingTest extends AbstractTestRealmKeycloakTest {
         String username = "testPbkdf2Sha1";
         createUser(username);
 
-        CredentialModel credential = fetchCredentials(username);
-        assertEncoded(credential, "password", credential.getSalt(), "PBKDF2WithHmacSHA1", 20000);
+        PasswordCredentialModel credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
+        assertEncoded(credential, "password", credential.getPasswordSecretData().getSalt(), "PBKDF2WithHmacSHA1", 20000);
     }
 
     @Test
@@ -207,8 +205,8 @@ public class PasswordHashingTest extends AbstractTestRealmKeycloakTest {
         String username = "testDefault";
         createUser(username);
 
-        CredentialModel credential = fetchCredentials(username);
-        assertEncoded(credential, "password", credential.getSalt(), "PBKDF2WithHmacSHA256", 27500);
+        PasswordCredentialModel credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
+        assertEncoded(credential, "password", credential.getPasswordSecretData().getSalt(), "PBKDF2WithHmacSHA256", 27500);
     }
 
     @Test
@@ -217,8 +215,8 @@ public class PasswordHashingTest extends AbstractTestRealmKeycloakTest {
         String username = "testPbkdf2Sha256";
         createUser(username);
 
-        CredentialModel credential = fetchCredentials(username);
-        assertEncoded(credential, "password", credential.getSalt(), "PBKDF2WithHmacSHA256", 27500);
+        PasswordCredentialModel credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
+        assertEncoded(credential, "password", credential.getPasswordSecretData().getSalt(), "PBKDF2WithHmacSHA256", 27500);
     }
 
     @Test
@@ -227,8 +225,8 @@ public class PasswordHashingTest extends AbstractTestRealmKeycloakTest {
         String username = "testPbkdf2Sha512";
         createUser(username);
 
-        CredentialModel credential = fetchCredentials(username);
-        assertEncoded(credential, "password", credential.getSalt(), "PBKDF2WithHmacSHA512", 30000);
+        PasswordCredentialModel credential = PasswordCredentialModel.createFromCredentialModel(fetchCredentials(username));
+        assertEncoded(credential, "password", credential.getPasswordSecretData().getSalt(), "PBKDF2WithHmacSHA512", 30000);
     }
 
 
@@ -250,10 +248,10 @@ public class PasswordHashingTest extends AbstractTestRealmKeycloakTest {
         }, CredentialModel.class);
     }
 
-    private void assertEncoded(CredentialModel credential, String password, byte[] salt, String algorithm, int iterations) throws Exception {
+    private void assertEncoded(PasswordCredentialModel credential, String password, byte[] salt, String algorithm, int iterations) throws Exception {
         KeySpec spec = new PBEKeySpec(password.toCharArray(), salt, iterations, 512);
         byte[] key = SecretKeyFactory.getInstance(algorithm).generateSecret(spec).getEncoded();
-        assertEquals(Base64.encodeBytes(key), credential.getValue());
+        assertEquals(Base64.encodeBytes(key), credential.getPasswordSecretData().getValue());
     }
 
 }
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/ResetPasswordTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/ResetPasswordTest.java
index 2774b150a3..11b1e34566 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/ResetPasswordTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/ResetPasswordTest.java
@@ -18,7 +18,6 @@ package org.keycloak.testsuite.forms;
 
 import org.hamcrest.Matchers;
 import org.jboss.arquillian.drone.api.annotation.Drone;
-import org.keycloak.admin.client.resource.ClientResource;
 import org.keycloak.authentication.actiontoken.resetcred.ResetCredentialsActionToken;
 import org.jboss.arquillian.graphene.page.Page;
 import org.keycloak.events.Details;
@@ -26,7 +25,6 @@ import org.keycloak.events.Errors;
 import org.keycloak.events.EventType;
 import org.keycloak.models.Constants;
 import org.keycloak.models.utils.SystemClientUtil;
-import org.keycloak.representations.idm.ClientRepresentation;
 import org.keycloak.representations.idm.EventRepresentation;
 import org.keycloak.representations.idm.RealmRepresentation;
 import org.keycloak.representations.idm.UserRepresentation;
@@ -42,7 +40,6 @@ import org.keycloak.testsuite.pages.LoginPasswordResetPage;
 import org.keycloak.testsuite.pages.LoginPasswordUpdatePage;
 import org.keycloak.testsuite.pages.VerifyEmailPage;
 import org.keycloak.testsuite.updaters.ClientAttributeUpdater;
-import org.keycloak.testsuite.updaters.RealmAttributeUpdater;
 import org.keycloak.testsuite.util.GreenMailRule;
 import org.keycloak.testsuite.util.MailUtils;
 import org.keycloak.testsuite.util.OAuthClient;
@@ -86,6 +83,7 @@ public class ResetPasswordTest extends AbstractTestRealmKeycloakTest {
 
     @Before
     public void setup() {
+        log.info("Adding login-test user");
         UserRepresentation user = UserBuilder.create()
                 .username("login-test")
                 .email("login@test.com")
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/MultipleRealmsTest.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/MultipleRealmsTest.java
index bb0b7108ec..14dad74d16 100755
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/MultipleRealmsTest.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/model/MultipleRealmsTest.java
@@ -118,14 +118,17 @@ public class MultipleRealmsTest extends AbstractTestRealmKeycloakTest {
             UserModel user1 = currentSession.users().getUserByUsername("user1", realm1);
             UserModel user1a = currentSession.users().getUserByUsername("user1", realm2);
 
-            UserManager um = new UserManager(session);
+            UserManager um = new UserManager(currentSession);
             if (user1 != null) {
                 um.removeUser(realm1, user1);
             }
             if (user1a != null) {
                 um.removeUser(realm2, user1a);
             }
+        });
 
+        KeycloakModelUtils.runJobInTransaction(session.getKeycloakSessionFactory(), (KeycloakSession sessionTestUser3) -> {
+            KeycloakSession currentSession = sessionTestUser3;
             currentSession.realms().removeRealm("id1");
             currentSession.realms().removeRealm("id2");
         });
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/util/KeycloakModelUtils.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/util/KeycloakModelUtils.java
index 10a737a459..1770b6b287 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/util/KeycloakModelUtils.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/util/KeycloakModelUtils.java
@@ -55,7 +55,7 @@ public class KeycloakModelUtils {
 
     public static CredentialRepresentation generateSecret(ClientRepresentation client) {
         UserCredentialModel secret = UserCredentialModel.generateSecret();
-        client.setSecret(secret.getValue());
+        client.setSecret(secret.getChallengeResponse());
         return ModelToRepresentation.toRepresentation(secret);
     }
 }
diff --git a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/util/UserBuilder.java b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/util/UserBuilder.java
index e27e97bd52..08efcfcd46 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/util/UserBuilder.java
+++ b/testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/util/UserBuilder.java
@@ -22,6 +22,9 @@ import java.util.Arrays;
 import java.util.HashMap;
 import java.util.LinkedList;
 
+import org.keycloak.models.credential.OTPCredentialModel;
+import org.keycloak.models.utils.HmacOTP;
+import org.keycloak.models.utils.ModelToRepresentation;
 import org.keycloak.representations.idm.CredentialRepresentation;
 import org.keycloak.representations.idm.UserRepresentation;
 
@@ -141,26 +144,26 @@ public class UserBuilder {
         return this;
     }
 
-    public UserBuilder secret(String type, String secret) {
+    public UserBuilder secret(CredentialRepresentation credential) {
         if (rep.getCredentials() == null) {
             rep.setCredentials(new LinkedList<>());
         }
 
-        CredentialRepresentation credential = new CredentialRepresentation();
-        credential.setType(type);
-        credential.setValue(secret);
-
         rep.getCredentials().add(credential);
         rep.setTotp(true);
         return this;
     }
 
     public UserBuilder totpSecret(String totpSecret) {
-        return secret(CredentialRepresentation.TOTP, totpSecret);
+        CredentialRepresentation credential = ModelToRepresentation.toRepresentation(
+                OTPCredentialModel.createTOTP(totpSecret, 6, 30, HmacOTP.HMAC_SHA1));
+        return secret(credential);
     }
 
     public UserBuilder hotpSecret(String hotpSecret) {
-        return secret(CredentialRepresentation.HOTP, hotpSecret);
+        CredentialRepresentation credential = ModelToRepresentation.toRepresentation(
+                OTPCredentialModel.createHOTP(hotpSecret, 6, 0, HmacOTP.HMAC_SHA1));
+        return secret(credential);
     }
 
     public UserBuilder otpEnabled() {
diff --git a/testsuite/integration-arquillian/tests/base/src/test/resources/ldap/fed-provider-export.json b/testsuite/integration-arquillian/tests/base/src/test/resources/ldap/fed-provider-export.json
index d4e5f34997..128c220b70 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/resources/ldap/fed-provider-export.json
+++ b/testsuite/integration-arquillian/tests/base/src/test/resources/ldap/fed-provider-export.json
@@ -239,324 +239,6 @@
     "en"
   ],
   "defaultLocale": "en",
-  "authenticationFlows": [
-    {
-      "id": "b12463a9-5d33-4f27-b010-4005db77e602",
-      "alias": "Handle Existing Account",
-      "description": "Handle what to do if there is existing account with same email/username like authenticated identity provider",
-      "providerId": "basic-flow",
-      "topLevel": false,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "idp-confirm-link",
-          "requirement": "REQUIRED",
-          "priority": 10,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "idp-email-verification",
-          "requirement": "ALTERNATIVE",
-          "priority": 20,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "requirement": "ALTERNATIVE",
-          "priority": 30,
-          "flowAlias": "Verify Existing Account by Re-authentication",
-          "userSetupAllowed": false,
-          "autheticatorFlow": true
-        }
-      ]
-    },
-    {
-      "id": "c1684fc8-a99d-4e19-a795-478e4d793fb5",
-      "alias": "Verify Existing Account by Re-authentication",
-      "description": "Reauthentication of existing account",
-      "providerId": "basic-flow",
-      "topLevel": false,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "idp-username-password-form",
-          "requirement": "REQUIRED",
-          "priority": 10,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "auth-otp-form",
-          "requirement": "OPTIONAL",
-          "priority": 20,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        }
-      ]
-    },
-    {
-      "id": "09af30d8-8c2a-45a4-a2be-b7617e9d0185",
-      "alias": "browser",
-      "description": "browser based authentication",
-      "providerId": "basic-flow",
-      "topLevel": true,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "auth-cookie",
-          "requirement": "ALTERNATIVE",
-          "priority": 10,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "auth-spnego",
-          "requirement": "DISABLED",
-          "priority": 20,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "identity-provider-redirector",
-          "requirement": "ALTERNATIVE",
-          "priority": 25,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "requirement": "ALTERNATIVE",
-          "priority": 30,
-          "flowAlias": "forms",
-          "userSetupAllowed": false,
-          "autheticatorFlow": true
-        }
-      ]
-    },
-    {
-      "id": "6cdf31d0-9c91-4ea6-8e37-da6e8fa7544c",
-      "alias": "clients",
-      "description": "Base authentication for clients",
-      "providerId": "client-flow",
-      "topLevel": true,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "client-secret",
-          "requirement": "ALTERNATIVE",
-          "priority": 10,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "client-jwt",
-          "requirement": "ALTERNATIVE",
-          "priority": 20,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        }
-      ]
-    },
-    {
-      "id": "c9a38de8-4c0c-496a-9936-b9753f73bfcc",
-      "alias": "direct grant",
-      "description": "OpenID Connect Resource Owner Grant",
-      "providerId": "basic-flow",
-      "topLevel": true,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "direct-grant-validate-username",
-          "requirement": "REQUIRED",
-          "priority": 10,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "direct-grant-validate-password",
-          "requirement": "REQUIRED",
-          "priority": 20,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "direct-grant-validate-otp",
-          "requirement": "OPTIONAL",
-          "priority": 30,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        }
-      ]
-    },
-    {
-      "id": "3755e297-7907-4c14-8c5f-d77e2bfe4b5d",
-      "alias": "first broker login",
-      "description": "Actions taken after first broker login with identity provider account, which is not yet linked to any Keycloak account",
-      "providerId": "basic-flow",
-      "topLevel": true,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticatorConfig": "review profile config",
-          "authenticator": "idp-review-profile",
-          "requirement": "REQUIRED",
-          "priority": 10,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticatorConfig": "create unique user config",
-          "authenticator": "idp-create-user-if-unique",
-          "requirement": "ALTERNATIVE",
-          "priority": 20,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "requirement": "ALTERNATIVE",
-          "priority": 30,
-          "flowAlias": "Handle Existing Account",
-          "userSetupAllowed": false,
-          "autheticatorFlow": true
-        }
-      ]
-    },
-    {
-      "id": "f35b2f00-3e84-4f2e-b48e-3e4159d88a06",
-      "alias": "forms",
-      "description": "Username, password, otp and other auth forms.",
-      "providerId": "basic-flow",
-      "topLevel": false,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "auth-username-password-form",
-          "requirement": "REQUIRED",
-          "priority": 10,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "auth-otp-form",
-          "requirement": "OPTIONAL",
-          "priority": 20,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        }
-      ]
-    },
-    {
-      "id": "441b4480-1ace-483a-bffb-f0cb6659fe32",
-      "alias": "registration",
-      "description": "registration flow",
-      "providerId": "basic-flow",
-      "topLevel": true,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "registration-page-form",
-          "requirement": "REQUIRED",
-          "priority": 10,
-          "flowAlias": "registration form",
-          "userSetupAllowed": false,
-          "autheticatorFlow": true
-        }
-      ]
-    },
-    {
-      "id": "c7de2a37-29a1-471a-9b51-699a69032b00",
-      "alias": "registration form",
-      "description": "registration form",
-      "providerId": "form-flow",
-      "topLevel": false,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "registration-user-creation",
-          "requirement": "REQUIRED",
-          "priority": 20,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "registration-profile-action",
-          "requirement": "REQUIRED",
-          "priority": 40,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "registration-password-action",
-          "requirement": "REQUIRED",
-          "priority": 50,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "registration-recaptcha-action",
-          "requirement": "DISABLED",
-          "priority": 60,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        }
-      ]
-    },
-    {
-      "id": "d362be0a-df20-4ce7-9288-f8448e0c4647",
-      "alias": "reset credentials",
-      "description": "Reset credentials for a user if they forgot their password or something",
-      "providerId": "basic-flow",
-      "topLevel": true,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "reset-credentials-choose-user",
-          "requirement": "REQUIRED",
-          "priority": 10,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "reset-credential-email",
-          "requirement": "REQUIRED",
-          "priority": 20,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "reset-password",
-          "requirement": "REQUIRED",
-          "priority": 30,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        },
-        {
-          "authenticator": "reset-otp",
-          "requirement": "OPTIONAL",
-          "priority": 40,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        }
-      ]
-    },
-    {
-      "id": "c2d7a1ae-57c9-4f3b-a4ce-55c3f0d9869f",
-      "alias": "saml ecp",
-      "description": "SAML ECP Profile Authentication Flow",
-      "providerId": "basic-flow",
-      "topLevel": true,
-      "builtIn": true,
-      "authenticationExecutions": [
-        {
-          "authenticator": "http-basic-authenticator",
-          "requirement": "REQUIRED",
-          "priority": 10,
-          "userSetupAllowed": false,
-          "autheticatorFlow": false
-        }
-      ]
-    }
-  ],
   "authenticatorConfig": [
     {
       "id": "a2490828-becb-435f-9c3c-318b3939bf64",
diff --git a/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-1.9.8.Final.json b/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-1.9.8.Final.json
index f2c436c151..169be8a5fc 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-1.9.8.Final.json
+++ b/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-1.9.8.Final.json
@@ -342,12 +342,8 @@
     "emailVerified" : false,
     "credentials" : [ {
       "type" : "password",
-      "hashedSaltedValue" : "Y71bKP3V5cvqiPGxPspDCQRraGbJD4IGxjYOez4QdubTYpoFjYb2wdC+pRoXskBvOaCYQcGzMa3SatDrFlBm9Q==",
-      "salt" : "o6D0KTKeFVejy00RhKZxvQ==",
-      "hashIterations" : 20000,
-      "counter" : 0,
-      "algorithm" : "pbkdf2",
-      "digits" : 0,
+      "credentialData" : "{\"hashIterations\" : 20000, \"algorithm\" : \"pbkdf2\"}",
+      "secretData" : "{\"value\":\"Y71bKP3V5cvqiPGxPspDCQRraGbJD4IGxjYOez4QdubTYpoFjYb2wdC+pRoXskBvOaCYQcGzMa3SatDrFlBm9Q==\",\"salt\":\"o6D0KTKeFVejy00RhKZxvQ==\"}",
       "createdDate" : 1476260086000
     } ],
     "requiredActions" : [ ],
@@ -1745,12 +1741,8 @@
     "emailVerified" : false,
     "credentials" : [ {
       "type" : "password",
-      "hashedSaltedValue" : "Y71bKP3V5cvqiPGxPspDCQRraGbJD4IGxjYOez4QdubTYpoFjYb2wdC+pRoXskBvOaCYQcGzMa3SatDrFlBm9Q==",
-      "salt" : "o6D0KTKeFVejy00RhKZxvQ==",
-      "hashIterations" : 20000,
-      "counter" : 0,
-      "algorithm" : "pbkdf2",
-      "digits" : 0,
+      "secretData" : "{\"value\" : \"Y71bKP3V5cvqiPGxPspDCQRraGbJD4IGxjYOez4QdubTYpoFjYb2wdC+pRoXskBvOaCYQcGzMa3SatDrFlBm9Q==\",\"salt\" : \"o6D0KTKeFVejy00RhKZxvQ==\"}",
+      "credentialData" : "{\"hashIterations\" : 20000,\"algorithm\" : \"pbkdf2\"}",
       "createdDate" : 1476260086000
     } ],
     "requiredActions" : [ ],
diff --git a/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-2.5.5.Final.json b/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-2.5.5.Final.json
index bf3469676e..fe4f156788 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-2.5.5.Final.json
+++ b/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-2.5.5.Final.json
@@ -484,15 +484,9 @@
     "emailVerified" : false,
     "credentials" : [ {
       "type" : "password",
-      "hashedSaltedValue" : "UahGF6QpiHbshvw6GmaLR+cgM7v6ZxNKd3mPywudvAz3KWOhv0sMvespERCykvSC2xP4OBMzbwwxBACRSmGE0w==",
-      "salt" : "mnR0QbmURHVkSej+2eG9ng==",
-      "hashIterations" : 20000,
-      "counter" : 0,
-      "algorithm" : "pbkdf2",
-      "digits" : 0,
-      "period" : 0,
-      "createdDate" : 1489756582960,
-      "config" : { }
+      "secretData" : "{\"value\", : \"UahGF6QpiHbshvw6GmaLR+cgM7v6ZxNKd3mPywudvAz3KWOhv0sMvespERCykvSC2xP4OBMzbwwxBACRSmGE0w==\",\"salt\" : \"mnR0QbmURHVkSej+2eG9ng==\"}",
+      "credentialData" : "{\"hashIterations\" : 20000,\"algorithm\" : \"pbkdf2\"}",
+      "createdDate" : 1489756582960
     } ],
     "disableableCredentialTypes" : [ "password" ],
     "requiredActions" : [ ],
diff --git a/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-3.4.3.Final.json b/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-3.4.3.Final.json
index 87e6073b19..2a0215f328 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-3.4.3.Final.json
+++ b/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-3.4.3.Final.json
@@ -3522,15 +3522,9 @@
     "emailVerified" : false,
     "credentials" : [ {
       "type" : "password",
-      "hashedSaltedValue" : "JOrh81WYkyhsdJSYiQZEpbtV4FQYEMmqRxncHiBZKunm8g0zNqQOezqEF20IJZWvxvudT6wAcmTzWsv4Qd1tvg==",
-      "salt" : "no71Rq8NWrZUpRY8cPxo2Q==",
-      "hashIterations" : 27500,
-      "counter" : 0,
-      "algorithm" : "pbkdf2-sha256",
-      "digits" : 0,
-      "period" : 0,
-      "createdDate" : 1531932343560,
-      "config" : { }
+      "secretData" : "{\"value\" : \"JOrh81WYkyhsdJSYiQZEpbtV4FQYEMmqRxncHiBZKunm8g0zNqQOezqEF20IJZWvxvudT6wAcmTzWsv4Qd1tvg==\",\"salt\" : \"no71Rq8NWrZUpRY8cPxo2Q==\"}",
+      "credentialData" : "{\"hashIterations\" : 27500,\"algorithm\" : \"pbkdf2-sha256\"}",
+      "createdDate" : 1531932343560
     } ],
     "disableableCredentialTypes" : [ "password" ],
     "requiredActions" : [ ],
diff --git a/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-4.8.3.Final.json b/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-4.8.3.Final.json
index 82eff63464..31716044b7 100644
--- a/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-4.8.3.Final.json
+++ b/testsuite/integration-arquillian/tests/base/src/test/resources/migration-test/migration-realm-4.8.3.Final.json
@@ -3476,15 +3476,9 @@
     "emailVerified" : false,
     "credentials" : [ {
       "type" : "password",
-      "hashedSaltedValue" : "3zv1UVKNodAZKHmUlGDAECl+5CbriP4G+JPkuuCxg4q95GzrFECCYmChYeo6a3OByPFwwG24K5xwIypiQ+awuw==",
-      "salt" : "PeH5KAhoLsRmrd4fJVvn3A==",
-      "hashIterations" : 27500,
-      "counter" : 0,
-      "algorithm" : "pbkdf2-sha256",
-      "digits" : 0,
-      "period" : 0,
-      "createdDate" : 1550660988731,
-      "config" : { }
+      "secretData" : "{\"hashedSaltedValue\" : \"3zv1UVKNodAZKHmUlGDAECl+5CbriP4G+JPkuuCxg4q95GzrFECCYmChYeo6a3OByPFwwG24K5xwIypiQ+awuw==\",\"salt\" : \"PeH5KAhoLsRmrd4fJVvn3A==\"}",
+      "credentialData" : "{\"hashIterations\" : 27500,\"algorithm\" : \"pbkdf2-sha256\"}",
+      "createdDate" : 1550660988731
     } ],
     "disableableCredentialTypes" : [ "password" ],
     "requiredActions" : [ ],
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_ca.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_ca.properties
index 1380d2eaa6..5d133289be 100755
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_ca.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_ca.properties
@@ -70,7 +70,7 @@ gssDelegationCredential=GSS Delegation Credential
 loginTotpStep1=Instal\u00B7la <a href=\"https://freeotp.github.io/\" target=\"_blank\">FreeOTP</a> o Google Authenticator al teu tel\u00E8fon m\u00F2bil. Les dues aplicacions estan disponibles a <a href=\"https://play.google.com\">Google Play</a> i en l''App Store d''Apple.
 loginTotpStep2=Obre l''aplicaci\u00F3 i escaneja el codi o introdueix la clau.
 loginTotpStep3=Introdueix el codi \u00FAnic que et mostra l''aplicaci\u00F3 d''autenticaci\u00F3 i fes clic a Envia per finalitzar la configuraci\u00F3
-loginTotpOneTime=Codi d''un sol \u00FAs
+loginOtpOneTime=Codi d''un sol \u00FAs
 
 oauthGrantRequest=Vols permetre aquests privilegis d''acc\u00E9s?
 inResource=a
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_de.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_de.properties
index d790954bca..40f4c99377 100755
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_de.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_de.properties
@@ -75,7 +75,7 @@ loginTotpManualStep2=\u00D6ffnen Sie die Applikation und geben Sie den folgenden
 loginTotpManualStep3=Verwenden Sie die folgenden Konfigurationswerte, falls Sie diese f\u00FCr die Applikation anpassen k\u00F6nnen:
 loginTotpUnableToScan=Sie k\u00F6nnen den Barcode nicht scannen?
 loginTotpScanBarcode=Barcode scannen?
-loginTotpOneTime=One-time code
+loginOtpOneTime=One-time code
 loginTotpType=Typ
 loginTotpAlgorithm=Algorithmus
 loginTotpDigits=Ziffern
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_es.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_es.properties
index c6f442da71..94210fd6c5 100755
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_es.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_es.properties
@@ -70,7 +70,7 @@ gssDelegationCredential=GSS Delegation Credential
 loginTotpStep1=Instala <a href=\"https://freeotp.github.io/\" target=\"_blank\">FreeOTP</a> o Google Authenticator en tu tel\u00E9fono m\u00F3vil. Ambas aplicaciones est\u00E1n disponibles en <a href=\"https://play.google.com\">Google Play</a> y en la App Store de Apple.
 loginTotpStep2=Abre la aplicacvi\u00F3n y escanea el c\u00F3digo o introduce la clave.
 loginTotpStep3=Introduce el c\u00F3digo \u00FAnico que te muestra la aplicaci\u00F3n de autenticaci\u00F3n y haz clic en Enviar para finalizar la configuraci\u00F3n
-loginTotpOneTime=C\u00F3digo de un solo uso
+loginOtpOneTime=C\u00F3digo de un solo uso
 
 oauthGrantRequest=\u00BFQuieres permitir estos privilegios de acceso?
 inResource=en
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_fr.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_fr.properties
index 322d025c90..32526439b0 100644
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_fr.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_fr.properties
@@ -83,7 +83,7 @@ loginTotpManualStep2=Ouvrez l''application et saisissez la cl\u00e9
 loginTotpManualStep3=Utilisez la configuration de valeur suivante si l''application permet son \u00e9dition
 loginTotpUnableToScan=Impossible de scanner?
 loginTotpScanBarcode=Scanner le code barre ?
-loginTotpOneTime=Code \u00e0 usage unique
+loginOtpOneTime=Code \u00e0 usage unique
 loginTotpType=Type
 loginTotpAlgorithm=Algorithme
 loginTotpDigits=Chiffres
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_it.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_it.properties
index 9d5b825cde..6608f58f76 100755
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_it.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_it.properties
@@ -66,7 +66,7 @@ gssDelegationCredential=Credenziali GSS Delegation
 loginTotpStep1=Installa <a href="https://freeotp.github.io/" target="_blank">FreeOTP</a> or <a href="http://code.google.com/p/google-authenticator/" target="_blank">Google Authenticator</a> sul tuo dispositivo mobile
 loginTotpStep2=Apri l''applicazione e scansione il barcode o scrivi la chiave
 loginTotpStep3=Scrivi il codice one-time fornito dall''applicazione e premi Invia per finire il setup
-loginTotpOneTime=Codice one-time
+loginOtpOneTime=Codice one-time
 
 oauthGrantRequest=Vuoi assegnare questi privilegi di accesso?
 inResource=per
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_ja.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_ja.properties
index a35b0e4d00..efd1d7c811 100644
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_ja.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_ja.properties
@@ -89,7 +89,7 @@ loginTotpManualStep2=アプリケーションを開き、キーを入力して
 loginTotpManualStep3=アプリケーションが設定できる場合は、次の設定値を使用してください
 loginTotpUnableToScan=スキャンできませんか？
 loginTotpScanBarcode=バーコードをスキャンしますか？
-loginTotpOneTime=ワンタイムコード
+loginOtpOneTime=ワンタイムコード
 loginTotpType=タイプ
 loginTotpAlgorithm=アルゴリズム
 loginTotpDigits=桁
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_lt.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_lt.properties
index 02fcf88611..515d02f569 100644
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_lt.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_lt.properties
@@ -71,7 +71,7 @@ gssDelegationCredential=GSS prisijungimo duomenų delegavimas
 loginTotpStep1=Įdiekite <a href="https://freeotp.github.io/" target="_blank">FreeOTP</a> arba Google Authenticator savo įrenginyje. Programėlės prieinamos <a href="https://play.google.com">Google Play</a> ir Apple App Store.
 loginTotpStep2=Atidarykite programėlę ir nuskenuokite barkodą arba įveskite kodą.
 loginTotpStep3=Įveskite programėlėje sugeneruotą vieną kartą galiojantį kodą ir paspauskite Saugoti norėdami prisijungti.
-loginTotpOneTime=Vienkartinis kodas
+loginOtpOneTime=Vienkartinis kodas
 
 oauthGrantRequest=Ar Jūs suteikiate šias prieigos teises?
 inResource=į
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_nl.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_nl.properties
index c9d31e804f..e85ea6e3d0 100644
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_nl.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_nl.properties
@@ -89,7 +89,7 @@ loginTotpManualStep2=Open de applicatie en voer de sleutel in
 loginTotpManualStep3=Gebruik de volgende configuratiewaarden (als de applicatie dit ondersteund)
 loginTotpUnableToScan=Lukt het scannen niet?
 loginTotpScanBarcode=Scan barcode?
-loginTotpOneTime=Eenmalige code
+loginOtpOneTime=Eenmalige code
 loginTotpType=Type
 loginTotpAlgorithm=Algoritme
 loginTotpDigits=Cijfers
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_no.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_no.properties
index 9bb99b20ac..4104d292be 100644
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_no.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_no.properties
@@ -70,7 +70,7 @@ gssDelegationCredential=GSS legitimasjons-delegering
 loginTotpStep1=Installer <a href="https://freeotp.github.io/" target="_blank">FreeOTP</a> eller Google Authenticator p\u00E5 din mobiltelefon. Begge applikasjoner er tilgjengelige p\u00E5 <a href="https://play.google.com">Google Play</a> og Apple App Store.
 loginTotpStep2=\u00C5pne applikasjonen og skann strekkoden eller skriv inn koden
 loginTotpStep3=Skriv inn engangskoden fra applikasjonen og klikk send inn for \u00E5 fullf\u00F8re
-loginTotpOneTime=Engangskode
+loginOtpOneTime=Engangskode
 
 oauthGrantRequest=Vil du gi disse tilgangsrettighetene?
 inResource=i
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_pl.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_pl.properties
index 841aca91f2..41f935f869 100644
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_pl.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_pl.properties
@@ -89,7 +89,7 @@ loginTotpManualStep2=Otwórz aplikację i wprowadź klucz
 loginTotpManualStep3=Użyj poniższych wartości konfiguracji, jeśli aplikacja pozwala na ich ustawienie
 loginTotpUnableToScan=Nie można skanować?
 loginTotpScanBarcode=Zeskanować kod paskowy?
-loginTotpOneTime=Kod jednorazowy
+loginOtpOneTime=Kod jednorazowy
 loginTotpType=Typ
 loginTotpAlgorithm=Algorytm
 loginTotpDigits=Cyfry
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_pt_BR.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_pt_BR.properties
index ac7d67fc6c..9b04a459c1 100755
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_pt_BR.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_pt_BR.properties
@@ -70,7 +70,7 @@ gssDelegationCredential=gss delega\u00E7\u00E3o credencial
 loginTotpStep1=Instale <a href="https://freeotp.github.io/" target="_blank">FreeOTP</a> ou <a href="http://code.google.com/p/google-authenticator/" target="_blank">Google Authenticator</a> em seu celular
 loginTotpStep2=Abra o aplicativo e escaneie o c\u00F3digo de barras ou digite o c\u00F3digo
 loginTotpStep3=Digite o c\u00F3digo fornecido pelo aplicativo e clique em Enviar para concluir a configura\u00E7\u00E3o
-loginTotpOneTime=C\u00F3digo autenticador
+loginOtpOneTime=C\u00F3digo autenticador
 
 oauthGrantRequest=Voc\u00EA concede esses privil\u00E9gios de acesso?
 inResource=em
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_ru.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_ru.properties
index d63dfb0db1..13118efba9 100644
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_ru.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_ru.properties
@@ -71,7 +71,7 @@ gssDelegationCredential=Делегирование учетных данных G
 loginTotpStep1=Установите <a href="https://freeotp.github.io/" target="_blank">FreeOTP</a> или Google Authenticator. Оба приложения доступны в <a href="https://play.google.com">Google Play</a> и Apple App Store.
 loginTotpStep2=Откройте приложение и просканируйте баркод, либо введите ключ
 loginTotpStep3=Введите одноразовый пароль, выданный приложением, и нажмите сохранить для завершения установки
-loginTotpOneTime=Одноразовый пароль
+loginOtpOneTime=Одноразовый пароль
 
 oauthGrantRequest=Вы согласуете доступ к этим привелегиям?
 inResource=в
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_sk.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_sk.properties
index 4abf8d02e2..0825e4e24e 100644
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_sk.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_sk.properties
@@ -75,7 +75,7 @@ loginTotpManualStep2=Otvorte aplikáciu a zadajte kľúč
 loginTotpManualStep3=Používajte nasledujúce hodnoty konfigurácie, ak aplikácia umožňuje ich nastavenie
 loginTotpUnableToScan=Nemožno skenovať?
 loginTotpScanBarcode=Skenovať čiarový kód?
-loginTotpOneTime=Jednorázový kód
+loginOtpOneTime=Jednorázový kód
 loginTotpType=Typ
 loginTotpAlgorithm=Algoritmus
 loginTotpDigits=Číslica
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_sv.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_sv.properties
index 6cb18c15f2..7c2335674e 100755
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_sv.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_sv.properties
@@ -68,7 +68,7 @@ gssDelegationCredential=GSS Delegation Credential
 loginTotpStep1=Installera <a href="https://freeotp.github.io/" target="_blank">FreeOTP</a> eller Google Authenticator på din mobil. Båda applikationerna finns tillgängliga hos <a href="https://play.google.com">Google Play</a> och Apple App Store.
 loginTotpStep2=Öppna applikationen och skanna streckkoden eller skriv i nyckeln
 loginTotpStep3=Fyll i engångskoden som tillhandahålls av applikationen och klicka på Spara för att avsluta inställningarna
-loginTotpOneTime=Engångskod
+loginOtpOneTime=Engångskod
 
 oauthGrantRequest=Godkänner du tillgång till de här rättigheterna?
 inResource=i
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_tr.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_tr.properties
index 7e45cdccad..f1f2f4f611 100755
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_tr.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_tr.properties
@@ -90,7 +90,7 @@ loginTotpManualStep2=Uygulamay\u0131 a\u00E7\u0131n ve anahtar\u0131 girin
 loginTotpManualStep3=Uygulama bunlar\u0131 ayarlamaya izin veriyorsa a\u015Fa\u011F\u0131daki yap\u0131land\u0131rma de\u011Ferlerini kullan\u0131n.
 loginTotpUnableToScan=Taranam\u0131yor?
 loginTotpScanBarcode=Barkod tara?
-loginTotpOneTime=Tek seferlik kod
+loginOtpOneTime=Tek seferlik kod
 loginTotpType=Tip
 loginTotpAlgorithm=Algoritma
 loginTotpDigits=Basamak
diff --git a/themes/src/main/resources-community/theme/base/login/messages/messages_zh_CN.properties b/themes/src/main/resources-community/theme/base/login/messages/messages_zh_CN.properties
index 0fa1291832..5af0c0e87e 100644
--- a/themes/src/main/resources-community/theme/base/login/messages/messages_zh_CN.properties
+++ b/themes/src/main/resources-community/theme/base/login/messages/messages_zh_CN.properties
@@ -71,7 +71,7 @@ gssDelegationCredential=GSS Delegation Credential
 loginTotpStep1=在手机安装 <a href="https://fedorahosted.org/freeotp/" target="_blank">FreeOTP</a> 或 Google Authenticator. 这两个应用可以在 <a href="https://play.google.com">Google Play</a> 和 Apple App Store找到.
 loginTotpStep2=打开应用扫描二维码或者输入一次性码
 loginTotpStep3=输入应用提供的一次性码点击提交完成设置
-loginTotpOneTime=一次性验证码
+loginOtpOneTime=一次性验证码
 
 oauthGrantRequest=您是否想要授予下列权限?
 inResource=in
diff --git a/themes/src/main/resources/theme/base/account/template.ftl b/themes/src/main/resources/theme/base/account/template.ftl
index d372ad5b17..a3ff99e562 100644
--- a/themes/src/main/resources/theme/base/account/template.ftl
+++ b/themes/src/main/resources/theme/base/account/template.ftl
@@ -69,8 +69,8 @@
             <#if message?has_content>
                 <div class="alert alert-${message.type}">
                     <#if message.type=='success' ><span class="pficon pficon-ok"></span></#if>
-                    <#if message.type=='error' ><span class="pficon pficon-error-octagon"></span><span class="pficon pficon-error-exclamation"></span></#if>
-                    ${kcSanitize(message.summary)?no_esc}
+                    <#if message.type = 'error'><span class="pficon-layered" ng-show="notification.type == 'danger'"><span class="pficon pficon-error-octagon"></span><span class="pficon pficon-error-exclamation"></span></span></#if>
+                    <span class="kc-feedback-text">${kcSanitize(message.summary)?no_esc}</span>
                 </div>
             </#if>
 
diff --git a/themes/src/main/resources/theme/base/account/totp.ftl b/themes/src/main/resources/theme/base/account/totp.ftl
index 8ed3fdacc3..176bd98196 100755
--- a/themes/src/main/resources/theme/base/account/totp.ftl
+++ b/themes/src/main/resources/theme/base/account/totp.ftl
@@ -1,99 +1,119 @@
 <#import "template.ftl" as layout>
 <@layout.mainLayout active='totp' bodyClass='totp'; section>
 
+    <h2>${msg("authenticatorTitle")}</h2>
     <#if totp.enabled>
-<h2>${msg("authenticatorTitle")}</h2>
-
-<table class="table table-bordered table-striped">
-    <thead>
-        <tr>
-            <th colspan="2">${msg("configureAuthenticators")}</th>
-            </tr>
-        </thead>
-    <tbody>
-        <tr>
-            <td class="provider">${msg("mobile")}</td>
-            <td class="action">
-                <form action="${url.totpUrl}" method="post" class="form-inline">
-                    <input type="hidden" id="stateChecker" name="stateChecker" value="${stateChecker}">
-                    <input type="hidden" id="submitAction" name="submitAction" value="Delete">
-                    <button id="remove-mobile" class="btn btn-default"><i class="pficon pficon-delete"></i></button>
-                </form>
-                </td>
+        <table class="table table-bordered table-striped">
+            <thead>
+            <tr>
+                <th colspan="4">${msg("configureAuthenticators")}</th>
             </tr>
-        </tbody>
-    </table>
-    <#else>
-<h2>${msg("authenticatorTitle")}</h2>
-
-<hr/>
-
-<ol>
-    <li>
-        <p>${msg("totpStep1")}</p>
-
-        <ul>
-            <#list totp.policy.supportedApplications as app>
-            <li>${app}</li>
+            </thead>
+            <tbody>
+            <#list totp.otpCredentials as credential>
+                <tr>
+                    <td class="provider">${msg("mobile")}</td>
+                    <td class="provider">${credential.id}</td>
+                    <td class="provider">${credential.userLabel}</td>
+                    <td class="action">
+                        <form action="${url.totpUrl}" method="post" class="form-inline">
+                            <input type="hidden" id="stateChecker" name="stateChecker" value="${stateChecker}">
+                            <input type="hidden" id="submitAction" name="submitAction" value="Delete">
+                            <input type="hidden" id="credentialId" name="credentialId" value="${credential.id}">
+                            <button id="remove-mobile" class="btn btn-default">
+                                <i class="pficon pficon-delete"></i>
+                            </button>
+                        </form>
+                    </td>
+                </tr>
             </#list>
-        </ul>
-    </li>
+            </tbody>
+        </table>
+    </#if>
 
-    <#if mode?? && mode = "manual">
-        <li>
-            <p>${msg("totpManualStep2")}</p>
-            <p><span id="kc-totp-secret-key">${totp.totpSecretEncoded}</span></p>
-            <p><a href="${totp.qrUrl}" id="mode-barcode">${msg("totpScanBarcode")}</a></p>
-        </li>
+    <hr/>
+
+    <ol>
         <li>
-            <p>${msg("totpManualStep3")}</p>
+            <p>${msg("totpStep1")}</p>
+
             <ul>
-                <li id="kc-totp-type">${msg("totpType")}: ${msg("totp." + totp.policy.type)}</li>
-                <li id="kc-totp-algorithm">${msg("totpAlgorithm")}: ${totp.policy.getAlgorithmKey()}</li>
-                <li id="kc-totp-digits">${msg("totpDigits")}: ${totp.policy.digits}</li>
-                <#if totp.policy.type = "totp">
-                    <li id="kc-totp-period">${msg("totpInterval")}: ${totp.policy.period}</li>
-                <#elseif totp.policy.type = "hotp">
-                    <li id="kc-totp-counter">${msg("totpCounter")}: ${totp.policy.initialCounter}</li>
-                </#if>
+                <#list totp.policy.supportedApplications as app>
+                    <li>${app}</li>
+                </#list>
             </ul>
         </li>
-    <#else>
+
+        <#if mode?? && mode = "manual">
+            <li>
+                <p>${msg("totpManualStep2")}</p>
+                <p><span id="kc-totp-secret-key">${totp.totpSecretEncoded}</span></p>
+                <p><a href="${totp.qrUrl}" id="mode-barcode">${msg("totpScanBarcode")}</a></p>
+            </li>
+            <li>
+                <p>${msg("totpManualStep3")}</p>
+                <ul>
+                    <li id="kc-totp-type">${msg("totpType")}: ${msg("totp." + totp.policy.type)}</li>
+                    <li id="kc-totp-algorithm">${msg("totpAlgorithm")}: ${totp.policy.getAlgorithmKey()}</li>
+                    <li id="kc-totp-digits">${msg("totpDigits")}: ${totp.policy.digits}</li>
+                    <#if totp.policy.type = "totp">
+                        <li id="kc-totp-period">${msg("totpInterval")}: ${totp.policy.period}</li>
+                    <#elseif totp.policy.type = "hotp">
+                        <li id="kc-totp-counter">${msg("totpCounter")}: ${totp.policy.initialCounter}</li>
+                    </#if>
+                </ul>
+            </li>
+        <#else>
+            <li>
+                <p>${msg("totpStep2")}</p>
+                <p><img src="data:image/png;base64, ${totp.totpSecretQrCode}" alt="Figure: Barcode"></p>
+                <p><a href="${totp.manualUrl}" id="mode-manual">${msg("totpUnableToScan")}</a></p>
+            </li>
+        </#if>
         <li>
-            <p>${msg("totpStep2")}</p>
-            <p><img src="data:image/png;base64, ${totp.totpSecretQrCode}" alt="Figure: Barcode"></p>
-            <p><a href="${totp.manualUrl}" id="mode-manual">${msg("totpUnableToScan")}</a></p>
+            <p>${msg("totpStep3")}</p>
         </li>
-    </#if>
-    <li>
-        <p>${msg("totpStep3")}</p>
-    </li>
-</ol>
+    </ol>
+
+    <hr/>
+
+    <form action="${url.totpUrl}" class="form-horizontal" method="post">
+        <input type="hidden" id="stateChecker" name="stateChecker" value="${stateChecker}">
+        <div class="form-group">
+            <div class="col-sm-2 col-md-2">
+                <label for="totp" class="control-label">${msg("authenticatorCode")}</label>
+            </div>
+
+            <div class="col-sm-10 col-md-10">
+                <input type="text" class="form-control" id="totp" name="totp" autocomplete="off" autofocus>
+                <input type="hidden" id="totpSecret" name="totpSecret" value="${totp.totpSecret}"/>
+            </div>
 
-<hr/>
 
-<form action="${url.totpUrl}" class="form-horizontal" method="post">
-    <input type="hidden" id="stateChecker" name="stateChecker" value="${stateChecker}">
-    <div class="form-group">
-        <div class="col-sm-2 col-md-2">
-            <label for="totp" class="control-label">${msg("authenticatorCode")}</label>
+        </div>
+
+        <div class="form-group">
+            <div class="col-sm-2 col-md-2">
+                <label for="userLabel" class="control-label">Device Name</label>
             </div>
 
-        <div class="col-sm-10 col-md-10">
-            <input type="text" class="form-control" id="totp" name="totp" autocomplete="off" autofocus autocomplete="off">
-            <input type="hidden" id="totpSecret" name="totpSecret" value="${totp.totpSecret}" />
+            <div class="col-sm-10 col-md-10">
+                <input type="text" class="form-control" id="userLabel" name="userLabel" autocomplete="off">
             </div>
         </div>
 
-    <div class="form-group">
-        <div id="kc-form-buttons" class="col-md-offset-2 col-md-10 submit">
-            <div class="">
-                <button type="submit" class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}" name="submitAction" value="Save">${msg("doSave")}</button>
-                <button type="submit" class="${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!}" name="submitAction" value="Cancel">${msg("doCancel")}</button>
+        <div class="form-group">
+            <div id="kc-form-buttons" class="col-md-offset-2 col-md-10 submit">
+                <div class="">
+                    <button type="submit"
+                            class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}"
+                            name="submitAction" value="Save">${msg("doSave")}</button>
+                    <button type="submit"
+                            class="${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!}"
+                            name="submitAction" value="Cancel">${msg("doCancel")}</button>
                 </div>
             </div>
         </div>
     </form>
-    </#if>
 
 </@layout.mainLayout>
diff --git a/themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties b/themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties
index 30ba312f71..6745a259a3 100644
--- a/themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties
+++ b/themes/src/main/resources/theme/base/admin/messages/admin-messages_en.properties
@@ -516,6 +516,10 @@ consent-text=Consent Text
 consent-text.tooltip=Text to display on consent page.
 mapper-type=Mapper Type
 mapper-type.tooltip=Type of the mapper
+user-label=User Label
+data=Data
+show-data=Show data...
+position=Position
 # realm identity providers
 identity-providers=Identity Providers
 table-of-identity-providers=Table of identity providers
@@ -770,7 +774,7 @@ select-a-role=Select a role
 select-realm-role=Select realm role
 client-roles.tooltip=Client roles that can be selected.
 select-client-role=Select client role
-        
+
 client-saml-endpoint=Client SAML Endpoint
 add-client-scope=Add client scope
 
@@ -1163,6 +1167,7 @@ revoke=Revoke
 new-password=New Password
 password-confirmation=Password Confirmation
 reset-password=Reset Password
+set-password=Set Password
 credentials.temporary.tooltip=If enabled user is required to change password on next login
 remove-totp=Remove OTP
 credentials.remove-totp.tooltip=Remove one time password generator for user.
@@ -1501,6 +1506,7 @@ disable-credential-types=Disable Credential Types
 credentials.disable.tooltip=Click button to disable selected credential types
 credential-types=Credential Types
 manage-user-password=Manage Password
+manage-credentials=Manage Credentials
 disable-credentials=Disable Credentials
 credential-reset-actions=Credential Reset
 credential-reset-actions-timeout=Expires In
diff --git a/themes/src/main/resources/theme/base/admin/resources/js/controllers/users.js b/themes/src/main/resources/theme/base/admin/resources/js/controllers/users.js
index 820929b036..6b2974ae01 100755
--- a/themes/src/main/resources/theme/base/admin/resources/js/controllers/users.js
+++ b/themes/src/main/resources/theme/base/admin/resources/js/controllers/users.js
@@ -232,17 +232,17 @@ module.controller('UserOfflineSessionsCtrl', function($scope, $location, realm,
 
 
 module.controller('UserListCtrl', function($scope, realm, User, UserSearchState, UserImpersonation, BruteForce, Notifications, $route, Dialog) {
-    
+
     $scope.init = function() {
         $scope.realm = realm;
-        
+
         UserSearchState.query.realm = realm.realm;
         $scope.query = UserSearchState.query;
         $scope.query.briefRepresentation = 'true';
-        
+
         if (!UserSearchState.isFirstSearch) $scope.searchQuery();
     };
-    
+
     $scope.impersonate = function(userId) {
         UserImpersonation.save({realm : realm.realm, user: userId}, function (data) {
             if (data.sameRealm) {
@@ -296,11 +296,11 @@ module.controller('UserListCtrl', function($scope, realm, User, UserSearchState,
                 userId : user.id
             }, function() {
                 $route.reload();
-                
+
                 if ($scope.users.length === 1 && $scope.query.first > 0) {
                     $scope.previousPage();
-                } 
-                
+                }
+
                 Notifications.success("The user has been deleted.");
             }, function() {
                 Notifications.error("User couldn't be deleted");
@@ -512,6 +512,100 @@ module.controller('UserDetailCtrl', function($scope, realm, user, BruteForceUser
 module.controller('UserCredentialsCtrl', function($scope, realm, user, $route, RequiredActions, User, UserExecuteActionsEmail, UserCredentials, Notifications, Dialog, TimeUnit2) {
     console.log('UserCredentialsCtrl');
 
+    $scope.hasPassword = false;
+
+    $scope.showData = {};
+
+    loadCredentials();
+
+    $scope.keys = function(object) {
+        return object ? Object.keys(object) : [];
+    }
+
+    $scope.saveCredential = function(credential) {
+        UserCredentials.updateCredential({ realm: realm.realm, userId: user.id, credentialId: credential.id }, {
+            'id': credential.id,
+            'userLabel': credential.userLabel,
+            // We JSONify the credential data
+            'credentialData': JSON.stringify(credential.credentialData)
+        }, function() {
+            Notifications.success("Credentials saved!");
+        }, function(err) {
+            Notifications.error("Error while updating the credential. See console for more information.");
+            console.log(err);
+        });
+    }
+
+    $scope.deleteCredential = function(credential) {
+        Dialog.confirm('Delete credentials', 'Are you sure you want to delete these users credentials?', function() {
+            UserCredentials.deleteCredential({ realm: realm.realm, userId: user.id, credentialId: credential.id }, null, function() {
+                Notifications.success("Credentials deleted!");
+                $route.reload();
+            }, function(err) {
+                Notifications.error("Error while deleting the credential. See console for more information.");
+                console.log(err);
+            });
+        });
+    }
+
+    $scope.moveUp = function(credentials, index) {
+        // Safety first
+        if (index == 0) {
+            return;
+        } else if (index == 1) {
+            UserCredentials.moveToFirst(
+                {
+                    realm: realm.realm,
+                    userId: user.id,
+                    credentialId: credentials[index].id
+                },
+                function () {
+                    $route.reload();
+                },
+                function (err) {
+                    Notifications.error("Error while moving the credential to top. See console for more information.");
+                    console.log(err);
+                });
+
+        } else {
+            UserCredentials.moveCredentialAfter(
+                {
+                    realm: realm.realm,
+                    userId: user.id,
+                    credentialId: credentials[index].id,
+                    newPreviousCredentialId: credentials[index - 2].id
+                },
+                function () {
+                    $route.reload();
+                },
+                function (err) {
+                    Notifications.error("Error while moving the credential up. See console for more information.");
+                    console.log(err);
+                });
+        }
+    }
+
+    $scope.moveDown = function(credentials, index) {
+        // Safety first
+        if (index == credentials.length - 1) {
+            return;
+        }
+        UserCredentials.moveCredentialAfter(
+            {
+                realm: realm.realm,
+                userId: user.id,
+                credentialId: credentials[index].id,
+                newPreviousCredentialId: credentials[index + 1].id
+            },
+            function() {
+                $route.reload();
+            },
+            function(err) {
+                Notifications.error("Error while moving the credential down. See console for more information.");
+                console.log(err);
+            });
+    }
+
     $scope.realm = realm;
     $scope.user = angular.copy(user);
     $scope.temporaryPassword = true;
@@ -533,10 +627,28 @@ module.controller('UserCredentialsCtrl', function($scope, realm, user, $route, R
 
     });
 
+    function loadCredentials() {
+        UserCredentials.getCredentials({ realm: realm.realm, userId: user.id }, null, function(credentials) {
+            $scope.credentials = credentials.map(function(c) {
+                // We de-JSONify the credential data
+                if (c.credentialData) {
+                    c.credentialData = JSON.parse(c.credentialData);
+                }
+                if (c.type == 'password') {
+                    $scope.hasPassword = true;
+                }
+                return c;
+            });
+        }, function(err) {
+            Notifications.error("Error while loading user credentials. See console for more information.");
+            console.log(err);
+        });
+    }
+
     $scope.resetPassword = function() {
         // hit enter without entering both fields - ignore
         if (!$scope.passwordAndConfirmPasswordEntered()) return;
-        
+
         if ($scope.pwdChange) {
             if ($scope.password != $scope.confirmPassword) {
                 Notifications.error("Password and confirmation does not match.");
@@ -544,12 +656,12 @@ module.controller('UserCredentialsCtrl', function($scope, realm, user, $route, R
             }
         }
 
-        var msgTitle = 'Change password';
-        var msg = 'Are you sure you want to change the users password?';
+        var msgTitle = 'Set password';
+        var msg = 'Are you sure you want to set a password for the user?';
 
         Dialog.confirm(msgTitle, msg, function() {
             UserCredentials.resetPassword({ realm: realm.realm, userId: user.id }, { type : "password", value : $scope.password, temporary: $scope.temporaryPassword }, function() {
-                Notifications.success("The password has been reset");
+                Notifications.success("The password has been set");
                 $scope.password = null;
                 $scope.confirmPassword = null;
                 $route.reload();
@@ -563,7 +675,7 @@ module.controller('UserCredentialsCtrl', function($scope, realm, user, $route, R
     $scope.passwordAndConfirmPasswordEntered = function() {
         return $scope.password && $scope.confirmPassword;
     }
-    
+
     $scope.disableCredentialTypes = function() {
         Dialog.confirm('Disable credentials', 'Are you sure you want to disable these users credentials?', function() {
             UserCredentials.disableCredentialTypes({ realm: realm.realm, userId: user.id }, $scope.disableableCredentialTypes, function() {
@@ -635,7 +747,7 @@ module.controller('UserFederationCtrl', function($scope, $location, $route, real
     $scope.instancesLoaded = false;
 
     if (!$scope.providers) $scope.providers = [];
-    
+
     $scope.addProvider = function(provider) {
         console.log('Add provider: ' + provider.id);
         $location.url("/create/user-storage/" + realm.realm + "/providers/" + provider.id);
@@ -788,7 +900,7 @@ module.controller('GenericUserStorageCtrl', function($scope, $location, Notifica
             if (!instance.config['priority']) {
                 instance.config['priority'] = ['0'];
             }
-            
+
             if (providerFactory.properties) {
                 for (var i = 0; i < providerFactory.properties.length; i++) {
                     var configProperty = providerFactory.properties[i];
@@ -1474,7 +1586,7 @@ module.controller('LDAPUserStorageCtrl', function($scope, $location, Notificatio
         console.log('GenericCtrl: triggerChangedUsersSync');
         triggerSync('triggerChangedUsersSync');
     }
-    
+
 
     function triggerSync(action) {
         UserStorageOperations.sync.save({ action: action, realm: $scope.realm.realm, componentId: $scope.instance.id }, {}, function(syncResult) {
diff --git a/themes/src/main/resources/theme/base/admin/resources/js/services.js b/themes/src/main/resources/theme/base/admin/resources/js/services.js
index 10ebd19d7d..40b3b16ccd 100755
--- a/themes/src/main/resources/theme/base/admin/resources/js/services.js
+++ b/themes/src/main/resources/theme/base/admin/resources/js/services.js
@@ -254,7 +254,7 @@ module.factory('ComponentUtils', function() {
     }
 
 
-    
+
     utils.addLastEmptyValueToMultivaluedLists = function(properties, config) {
         if (!properties) {
             return;
@@ -291,24 +291,24 @@ module.factory('ComponentUtils', function() {
             }
         }
     }
-    
+
     // Allows you to use ui-select2 with <input> tag.
     // In HTML you will then use property.mvOptions like this:
     // <input ui-select2="prop.mvOptions" ng-model="...
     utils.addMvOptionsToMultivaluedLists = function(properties) {
         if (!properties) return;
-        
+
         for (var i=0 ; i<properties.length ; i++) {
             var prop = properties[i];
             if (prop.type !== 'MultivaluedList') continue;
-            
+
             prop.mvOptions = {
                 'multiple' : true,
                 'simple_tags' : true,
                 'tags' : angular.copy(prop.options)
             }
         }
-        
+
     }
 
     return utils;
@@ -624,6 +624,27 @@ module.factory('UserImpersonation', function($resource) {
 module.factory('UserCredentials', function($resource) {
     var credentials = {};
 
+    credentials.getCredentials = $resource(authUrl + '/admin/realms/:realm/users/:userId/credentials', {
+        realm : '@realm',
+        userId : '@userId'
+    }).query;
+
+    credentials.deleteCredential = $resource(authUrl + '/admin/realms/:realm/users/:userId/credentials/:credentialId', {
+        realm : '@realm',
+        userId : '@userId',
+        credentialId : '@credentialId'
+    }).delete;
+
+    credentials.updateCredential = $resource(authUrl + '/admin/realms/:realm/users/:userId/credentials/:credentialId', {
+        realm : '@realm',
+        userId : '@userId',
+        credentialId : '@credentialId'
+    }, {
+        update : {
+            method : 'PUT'
+        }
+    }).update;
+
     credentials.resetPassword = $resource(authUrl + '/admin/realms/:realm/users/:userId/reset-password', {
         realm : '@realm',
         userId : '@userId'
@@ -651,6 +672,27 @@ module.factory('UserCredentials', function($resource) {
         }
     }).update;
 
+    credentials.moveCredentialAfter = $resource(authUrl + '/admin/realms/:realm/users/:userId/credentials/:credentialId/moveAfter/:newPreviousCredentialId', {
+        realm : '@realm',
+        userId : '@userId',
+        credentialId : '@credentialId',
+        newPreviousCredentialId : '@newPreviousCredentialId'
+    }, {
+        update : {
+            method : 'POST'
+        }
+    }).update;
+
+    credentials.moveToFirst = $resource(authUrl + '/admin/realms/:realm/users/:userId/credentials/:credentialId/moveToFirst', {
+        realm : '@realm',
+        userId : '@userId',
+        credentialId : '@credentialId'
+    }, {
+        update : {
+            method : 'POST'
+        }
+    }).update;
+
     return credentials;
 });
 
@@ -908,7 +950,7 @@ function roleControl($scope, realm, role, roles, clients,
             Notifications.success("Role added to composite.");
         });
     };
-    
+
     $scope.deleteRealmRole = function() {
         $scope.compositeSwitchDisabled=true;
         $scope.selectedRealmMappingsToRemove = JSON.parse('[' + $scope.selectedRealmMappings + ']');
diff --git a/themes/src/main/resources/theme/base/admin/resources/partials/user-credentials.html b/themes/src/main/resources/theme/base/admin/resources/partials/user-credentials.html
index c35a767fd0..85c4cc5c71 100755
--- a/themes/src/main/resources/theme/base/admin/resources/partials/user-credentials.html
+++ b/themes/src/main/resources/theme/base/admin/resources/partials/user-credentials.html
@@ -7,10 +7,59 @@
     <kc-tabs-user></kc-tabs-user>
 
     <form class="form-horizontal" name="userForm" novalidate>
+
         <fieldset class="border-top">
-            <legend><span class="text">{{:: 'manage-user-password' | translate}}</span></legend>
+            <legend><span class="text">{{:: 'manage-credentials' | translate}}</span></legend>
+            <table class="datatable table table-bordered dataTable no-footer credentials-table">
+                <thead>
+                    <tr>
+                        <th>{{:: 'position' | translate}}</th>
+                        <th>{{:: 'type' | translate}}</th>
+                        <th>{{:: 'user-label' | translate}}</th>
+                        <th>{{:: 'data' | translate}}</th>
+                        <th colspan="2">{{:: 'actions' | translate}}</th>
+                    </tr>
+                </thead>
+                <tr ng-repeat="credential in credentials">
+                    <td>
+                        <button data-ng-disabled="$first" class="btn btn-default btn-sm" data-ng-click="moveUp(credentials, $index)"><i class="fa fa-angle-up"></i></button>
+                        <button data-ng-disabled="$last" class="btn btn-default btn-sm" data-ng-click="moveDown(credentials, $index)"><i class="fa fa-angle-down"></i></button>
+                    </td>
+                    <td>
+                        <b>{{credential.type}}</b>
+                    </td>
+                    <td class="credential-label-cell">
+                        <input type="text" class="form-control" data-ng-model="credential.userLabel"/>
+                    </td>
+                    <td class="credential-data-cell">
+                        <a data-ng-show="!showData[credential.id]" data-ng-click="showData[credential.id] = true">
+                            {{:: 'show-data' | translate}}
+                        </a>
+                        <table class="datatable table dataTable no-footer credential-data-table" data-ng-show="showData[credential.id]">
+                            <tr ng-repeat="key in keys(credential.credentialData) | orderBy">
+                                <td class="key">{{key}}</td>
+                                <td class="value"><input type="text" class="form-control" data-ng-model="credential.credentialData[key]" /></td>
+                            </tr>
+                        </table>
+                    </td>
+                    <td class="credential-action-cell" ng-class="{true:'expanded'}[showData[credential.id]]" >
+                        <div class="kc-action-cell" data-ng-click="deleteCredential(credential)">
+                            {{:: 'delete' | translate}}
+                        </div>
+                    </td>
+                    <td class="credential-action-cell" ng-class="{true:'expanded'}[showData[credential.id]]" >
+                        <div class="kc-action-cell" data-ng-click="saveCredential(credential)">
+                            {{:: 'save' | translate}}
+                        </div>
+                    </td>
+                </tr>
+            </table>
+        </fieldset>
+
+        <fieldset class="border-top" data-ng-show="!hasPassword">
+            <legend><span class="text">{{:: 'set-password' | translate}}</span></legend>
             <div class="form-group">
-                    <label class="col-md-2 control-label" for="newPas">{{:: 'new-password' | translate}} <span class="required" data-ng-show="create">*</span></label>
+                    <label class="col-md-2 control-label" for="newPas">{{:: 'password' | translate}} <span class="required" data-ng-show="create">*</span></label>
                     <div class="col-md-6">
                         <input class="form-control" kc-password type="text" id="newPas" name="newPas" data-ng-model="password" required>
                     </div>
@@ -33,7 +82,7 @@
 
                 <div class="form-group">
                     <div class="col-md-10 col-md-offset-2">
-                        <button data-ng-disabled="!passwordAndConfirmPasswordEntered()" class="btn btn-default" type="submit" data-ng-click="resetPassword(true)">{{:: 'reset-password' | translate}}</button>
+                        <button data-ng-disabled="!passwordAndConfirmPasswordEntered()" class="btn btn-default" type="submit" data-ng-click="resetPassword(true)">{{:: 'set-password' | translate}}</button>
                     </div>
                 </div>
             </fieldset>
diff --git a/themes/src/main/resources/theme/base/login/login-totp.ftl b/themes/src/main/resources/theme/base/login/login-otp.ftl
similarity index 58%
rename from themes/src/main/resources/theme/base/login/login-totp.ftl
rename to themes/src/main/resources/theme/base/login/login-otp.ftl
index 2c31e61b1b..fd2a4983ed 100755
--- a/themes/src/main/resources/theme/base/login/login-totp.ftl
+++ b/themes/src/main/resources/theme/base/login/login-otp.ftl
@@ -1,16 +1,17 @@
-<#import "template.ftl" as layout>
+<#import "select.ftl" as layout>
 <@layout.registrationLayout; section>
     <#if section = "header">
         ${msg("doLogIn")}
     <#elseif section = "form">
-        <form id="kc-totp-login-form" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
+        <form id="kc-otp-login-form" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
             <div class="${properties.kcFormGroupClass!}">
                 <div class="${properties.kcLabelWrapperClass!}">
-                    <label for="totp" class="${properties.kcLabelClass!}">${msg("loginTotpOneTime")}</label>
+                    <label for="otp" class="${properties.kcLabelClass!}">${msg("loginOtpOneTime")}</label>
                 </div>
 
                 <div class="${properties.kcInputWrapperClass!}">
-                    <input id="totp" name="totp" autocomplete="off" type="text" class="${properties.kcInputClass!}" autofocus />
+                    <input id="otp" name="otp" autocomplete="off" type="text" class="${properties.kcInputClass!}"
+                           autofocus/>
                 </div>
             </div>
 
@@ -22,8 +23,11 @@
 
                 <div id="kc-form-buttons" class="${properties.kcFormButtonsClass!}">
                     <div class="${properties.kcFormButtonsWrapperClass!}">
-                        <input class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}" name="login" id="kc-login" type="submit" value="${msg("doLogIn")}"/>
-                        <input class="${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!}" name="cancel" id="kc-cancel" type="submit" value="${msg("doCancel")}"/>
+                        <input type="hidden" id="id-hidden-input" name="credentialId" <#if selectedCredential?has_content>value="${selectedCredential}"</#if>/>
+                        <input class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonLargeClass!}"
+                               name="login" id="kc-login" type="submit" value="${msg("doLogIn")}"/>
+                        <input class="${properties.kcButtonClass!} ${properties.kcButtonDefaultClass!} ${properties.kcButtonLargeClass!}"
+                               name="cancel" id="kc-cancel" type="submit" value="${msg("doCancel")}"/>
                     </div>
                 </div>
             </div>
diff --git a/themes/src/main/resources/theme/base/login/login-password.ftl b/themes/src/main/resources/theme/base/login/login-password.ftl
new file mode 100755
index 0000000000..5b948b92aa
--- /dev/null
+++ b/themes/src/main/resources/theme/base/login/login-password.ftl
@@ -0,0 +1,34 @@
+<#import "select.ftl" as layout>
+<@layout.registrationLayout displayInfo=social.displayInfo displayWide=(realm.password && social.providers??); section>
+    <#if section = "header">
+        ${msg("doLogIn")}
+    <#elseif section = "form">
+    <div id="kc-form">
+      <div id="kc-form-wrapper">
+            <form id="kc-form-login" onsubmit="login.disabled = true; return true;" action="${url.loginAction}" method="post">
+
+                <div class="${properties.kcFormGroupClass!}">
+                    <label for="password" class="${properties.kcLabelClass!}">${msg("password")}</label>
+                    <input tabindex="2" id="password" class="${properties.kcInputClass!}" name="password" type="password" autocomplete="off" />
+                </div>
+
+                <div class="${properties.kcFormGroupClass!} ${properties.kcFormSettingClass!}">
+                    <div id="kc-form-options">
+                        </div>
+                        <div class="${properties.kcFormOptionsWrapperClass!}">
+                            <#if realm.resetPasswordAllowed>
+                                <span><a tabindex="5" href="${url.loginResetCredentialsUrl}">${msg("doForgotPassword")}</a></span>
+                            </#if>
+                        </div>
+                  </div>
+
+                  <div id="kc-form-buttons" class="${properties.kcFormGroupClass!}">
+                      <input type="hidden" id="id-hidden-input" name="credentialId" <#if selectedCredential?has_content>value="${selectedCredential}"</#if>/>
+                    <input tabindex="4" class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}" name="login" id="kc-login" type="submit" value="${msg("doLogIn")}"/>
+                  </div>
+            </form>
+        </div>
+      </div>
+    </#if>
+
+</@layout.registrationLayout>
diff --git a/themes/src/main/resources/theme/base/login/login-username.ftl b/themes/src/main/resources/theme/base/login/login-username.ftl
new file mode 100755
index 0000000000..7d082aa027
--- /dev/null
+++ b/themes/src/main/resources/theme/base/login/login-username.ftl
@@ -0,0 +1,49 @@
+<#import "template.ftl" as layout>
+<@layout.registrationLayout displayInfo=social.displayInfo displayWide=(realm.password && social.providers??); section>
+    <#if section = "header">
+        ${msg("doLogIn")}
+    <#elseif section = "form">
+    <div id="kc-form">
+      <div id="kc-form-wrapper">
+            <form id="kc-form-login" onsubmit="login.disabled = true; return true;" action="${url.loginAction}" method="post">
+                <div class="${properties.kcFormGroupClass!}">
+                    <label for="username" class="${properties.kcLabelClass!}"><#if !realm.loginWithEmailAllowed>${msg("username")}<#elseif !realm.registrationEmailAsUsername>${msg("usernameOrEmail")}<#else>${msg("email")}</#if></label>
+
+                    <#if usernameEditDisabled??>
+                        <input tabindex="1" id="username" class="${properties.kcInputClass!}" name="username" value="${(login.username!'')}" type="text" disabled />
+                    <#else>
+                        <input tabindex="1" id="username" class="${properties.kcInputClass!}" name="username" value="${(login.username!'')}"  type="text" autofocus autocomplete="off" />
+                    </#if>
+                </div>
+
+                <div class="${properties.kcFormGroupClass!} ${properties.kcFormSettingClass!}">
+                    <div id="kc-form-options">
+                        <#if realm.rememberMe && !usernameEditDisabled??>
+                            <div class="checkbox">
+                                <label>
+                                    <#if login.rememberMe??>
+                                        <input tabindex="3" id="rememberMe" name="rememberMe" type="checkbox" checked> ${msg("rememberMe")}
+                                    <#else>
+                                        <input tabindex="3" id="rememberMe" name="rememberMe" type="checkbox"> ${msg("rememberMe")}
+                                    </#if>
+                                </label>
+                            </div>
+                        </#if>
+                        </div>
+                  </div>
+
+                  <div id="kc-form-buttons" class="${properties.kcFormGroupClass!}">
+                    <input tabindex="4" class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}" name="login" id="kc-login" type="submit" value="${msg("doLogIn")}"/>
+                  </div>
+            </form>
+        </div>
+      </div>
+    <#elseif section = "info" >
+        <#if realm.password && realm.registrationAllowed && !usernameEditDisabled??>
+            <div id="kc-registration">
+                <span>${msg("noAccount")} <a tabindex="6" href="${url.registrationUrl}">${msg("doRegister")}</a></span>
+            </div>
+        </#if>
+    </#if>
+
+</@layout.registrationLayout>
diff --git a/themes/src/main/resources/theme/base/login/login.ftl b/themes/src/main/resources/theme/base/login/login.ftl
index 1c792ae22b..88b6f54472 100755
--- a/themes/src/main/resources/theme/base/login/login.ftl
+++ b/themes/src/main/resources/theme/base/login/login.ftl
@@ -45,7 +45,8 @@
                   </div>
 
                   <div id="kc-form-buttons" class="${properties.kcFormGroupClass!}">
-                    <input tabindex="4" class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}" name="login" id="kc-login" type="submit" value="${msg("doLogIn")}"/>
+                      <input type="hidden" id="id-hidden-input" name="credentialId" <#if selectedCredential?has_content>value="${selectedCredential}"</#if>/>
+                      <input tabindex="4" class="${properties.kcButtonClass!} ${properties.kcButtonPrimaryClass!} ${properties.kcButtonBlockClass!} ${properties.kcButtonLargeClass!}" name="login" id="kc-login" type="submit" value="${msg("doLogIn")}"/>
                   </div>
             </form>
         </#if>
diff --git a/themes/src/main/resources/theme/base/login/messages/messages_en.properties b/themes/src/main/resources/theme/base/login/messages/messages_en.properties
index 7ab1421ed5..e58254a7af 100755
--- a/themes/src/main/resources/theme/base/login/messages/messages_en.properties
+++ b/themes/src/main/resources/theme/base/login/messages/messages_en.properties
@@ -2,6 +2,7 @@ doLogIn=Log In
 doRegister=Register
 doCancel=Cancel
 doSubmit=Submit
+doBack=Back
 doYes=Yes
 doNo=No
 doContinue=Continue
@@ -89,7 +90,7 @@ loginTotpManualStep2=Open the application and enter the key
 loginTotpManualStep3=Use the following configuration values if the application allows setting them
 loginTotpUnableToScan=Unable to scan?
 loginTotpScanBarcode=Scan barcode?
-loginTotpOneTime=One-time code
+loginOtpOneTime=One-time code
 loginTotpType=Type
 loginTotpAlgorithm=Algorithm
 loginTotpDigits=Digits
@@ -99,6 +100,7 @@ loginTotpCounter=Counter
 loginTotp.totp=Time-based
 loginTotp.hotp=Counter-based
 
+loginChooseAuthenticator=Select your authentication method
 
 oauthGrantRequest=Do you grant these access privileges?
 inResource=in
@@ -317,4 +319,11 @@ console-accept=y
 openshift.scope.user_info=User information
 openshift.scope.user_check-access=User access information
 openshift.scope.user_full=Full Access
-openshift.scope.list-projects=List projects
\ No newline at end of file
+openshift.scope.list-projects=List projects
+
+#authenticators
+auth-otp-form=OTP
+auth-password-form=Password
+auth-username-form=Username
+auth-username-password-form=Username and password
+identity-provider-redirector=Connect with another Identity Provider
\ No newline at end of file
diff --git a/themes/src/main/resources/theme/base/login/select.ftl b/themes/src/main/resources/theme/base/login/select.ftl
new file mode 100644
index 0000000000..b3763ff8a3
--- /dev/null
+++ b/themes/src/main/resources/theme/base/login/select.ftl
@@ -0,0 +1,44 @@
+<#macro registrationLayout bodyClass="" displayInfo=false displayMessage=true displayWide=false>
+<#import "template.ftl" as layout>
+<@layout.registrationLayout; section>
+    <#if section = "header">
+        <script type="text/javascript">
+            // Fill up the two hidden and submit the form
+            function fillAndSubmit() {
+                var selectValue = document.getElementById('authenticators-choice').value;
+                if (selectValue != '') {
+                    var split = selectValue.split("|");
+                    document.getElementById('authexec-hidden-input').value = split[0];
+                    document.getElementById('credentialId-hidden-input').value = split[1];
+                    document.getElementById('kc-select-credential-form').submit();
+                }
+            }
+            <#if authenticationSelections?size gt 1>
+                // We bind the action to the select
+                window.addEventListener('load', function() {
+                    document.getElementById('authenticators-choice').addEventListener('change', fillAndSubmit);
+                });
+            </#if>
+        </script>
+        <#nested "header">
+    <#elseif section = "form">
+        <#if authenticationSelections?size gt 1>
+            <form id="kc-select-credential-form" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
+                <select id="authenticators-choice" size="1">
+                    <#list authenticationSelections as authenticationSelection>
+                        <#if authenticationSelection.credentialId?has_content>
+                            <option value="${authenticationSelection.id}" <#if selectedCredential?has_content && authenticationSelection.credentialId == selectedCredential>selected</#if>><#if authenticationSelection.showCredentialType()>${msg('${authenticationSelection.authExecName}')}</#if>${authenticationSelection.credentialName}</option>
+                        <#else >
+                            <option value="${authenticationSelection.id}" <#if authenticationSelection.authExecId == execution>selected</#if>>${msg('${authenticationSelection.authExecName}')}</option>
+                        </#if>
+                    </#list>
+                </select>
+                <input type="hidden" id="authexec-hidden-input" name="authenticationExecution" />
+                <input type="hidden" id="credentialId-hidden-input" name="credentialId" <#if selectedCredential?has_content>value="${selectedCredential}"</#if>/>
+            </form>
+        </#if>
+        <br><br>
+        <#nested "form">
+    </#if>
+</@layout.registrationLayout>
+</#macro>
diff --git a/themes/src/main/resources/theme/base/login/template.ftl b/themes/src/main/resources/theme/base/login/template.ftl
index a09fd8f95c..e33d2943a3 100644
--- a/themes/src/main/resources/theme/base/login/template.ftl
+++ b/themes/src/main/resources/theme/base/login/template.ftl
@@ -68,6 +68,16 @@
           </#if>
 
           <#nested "form">
+            <#if url.hasAction() >
+                <form id="kc-select-back-form" class="${properties.kcFormClass!}" action="${url.loginAction}" method="post">
+                    <div id="kc-form-buttons" class="${properties.kcFormButtonsClass!}">
+                        <div class="${properties.kcFormButtonsWrapperClass!}">
+                            <input class="${properties.kcButtonClass!} ${properties.kcButtonLargeClass!}"
+                                   name="back" id="kc-back" type="submit" value="${msg("doBack")}"/>
+                        </div>
+                    </div>
+                </form>
+            </#if>
 
           <#if displayInfo>
               <div id="kc-info" class="${properties.kcSignUpClass!}">
diff --git a/themes/src/main/resources/theme/keycloak/admin/resources/css/styles.css b/themes/src/main/resources/theme/keycloak/admin/resources/css/styles.css
index c846ed73ab..925348a869 100755
--- a/themes/src/main/resources/theme/keycloak/admin/resources/css/styles.css
+++ b/themes/src/main/resources/theme/keycloak/admin/resources/css/styles.css
@@ -220,7 +220,7 @@ th.w-40 {
 
 .sidebar-pf .nav-pills > li > a:hover{
   background: #393f44;
-  border-color:#292e34; 
+  border-color:#292e34;
   border-left-color: #393f44;
   color: #fff;
 }
@@ -423,3 +423,67 @@ div[tree-model] li .deactivate_selected {
     font-weight: bold;
     padding: 1px 5px;
 }
+
+/* Manage credentials */
+table.credentials-table {
+    margin-top: 0;
+    margin-bottom: 20px;
+}
+
+table.credentials-table td.kc-action-cell {
+    vertical-align: middle;
+}
+
+table.credentials-table input[type='text'] {
+    width: 100%;
+}
+
+td.credential-label-cell {
+    padding: 5px !important;
+}
+
+td.credential-data-cell {
+    padding: 0 !important;
+}
+
+td.credential-data-cell a {
+    margin-left: 5px;
+    line-height: 2.5em;
+    cursor: pointer;
+}
+
+td.credential-action-cell {
+    padding: 0px !important;
+}
+
+td.credential-action-cell div.kc-action-cell {
+    width: 100%;
+    height: 36px;
+    line-height: 34px;
+}
+
+td.credential-action-cell.expanded div.kc-action-cell {
+    border-bottom: 1px solid #d1d1d1;
+}
+
+table.credential-data-table {
+    margin-top: 0;
+}
+
+table.credential-data-table tr:first-child td {
+    border-top: 0;
+}
+
+table.credential-data-table td:first-child {
+    width: 150px;
+}
+
+table.credential-data-table td.key {
+    text-align: right;
+    padding-top: 8px;
+}
+
+table.credential-data-table td.value {
+    text-align: right;
+    padding: 5px;
+}
\ No newline at end of file
diff --git a/wildfly/adduser/src/main/java/org/keycloak/wildfly/adduser/AddUser.java b/wildfly/adduser/src/main/java/org/keycloak/wildfly/adduser/AddUser.java
index 573b0e0a23..7c956a29d9 100644
--- a/wildfly/adduser/src/main/java/org/keycloak/wildfly/adduser/AddUser.java
+++ b/wildfly/adduser/src/main/java/org/keycloak/wildfly/adduser/AddUser.java
@@ -40,6 +40,8 @@ import org.keycloak.credential.CredentialModel;
 import org.keycloak.credential.hash.PasswordHashProvider;
 import org.keycloak.credential.hash.PasswordHashProviderFactory;
 import org.keycloak.models.PasswordPolicy;
+import org.keycloak.models.credential.PasswordCredentialModel;
+import org.keycloak.models.utils.ModelToRepresentation;
 import org.keycloak.representations.idm.CredentialRepresentation;
 import org.keycloak.representations.idm.RealmRepresentation;
 import org.keycloak.representations.idm.UserRepresentation;
@@ -173,15 +175,9 @@ public class AddUser {
         PasswordHashProviderFactory hashProviderFactory = getHashProviderFactory(DEFAULT_HASH_ALGORITH);
         PasswordHashProvider hashProvider = hashProviderFactory.create(null);
 
-        CredentialModel credentialModel = new CredentialModel();
-        hashProvider.encode(password, iterations > 0 ? iterations : DEFAULT_HASH_ITERATIONS, credentialModel);
+        PasswordCredentialModel credentialModel = hashProvider.encodedCredential(password, iterations > 0 ? iterations : DEFAULT_HASH_ITERATIONS);
 
-        CredentialRepresentation credentials = new CredentialRepresentation();
-        credentials.setType(credentialModel.getType());
-        credentials.setAlgorithm(credentialModel.getAlgorithm());
-        credentials.setHashIterations(credentialModel.getHashIterations());
-        credentials.setSalt(Base64.encodeBytes(credentialModel.getSalt()));
-        credentials.setHashedSaltedValue(credentialModel.getValue());
+        CredentialRepresentation credentials = ModelToRepresentation.toRepresentation(credentialModel);
 
         user.getCredentials().add(credentials);
 
